<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!--
Copyright (c) 2021 STMicroelectronics.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device schemaVersion="1.1"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>STM32H503</name>
  <version>0.1</version>    
  <description>STM32H503</description>  
  <cpu>
    <name>CM33</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits> 
  <width>32</width>
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals> 
    <peripheral>
        <name>ADC</name>
        <description>Analog to digital converter</description>
		<groupName>ADC</groupName>
        <baseAddress>0x42028000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>ADC1</name>
          <description>ADC1 global interrupt</description>
          <value>37</value>
        </interrupt>
        <registers>
          <register>
            <name>ADC_ISR</name>
            <displayName>ADC_ISR</displayName>
            <description>ADC interrupt and status register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADRDY</name>
                <description>ADC ready
This bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.
It is cleared by software writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC is ready to start conversion</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSMP</name>
                <description>End of sampling flag
This bit is set by hardware during the conversion of any channel (only for regular channels), at the end of the sampling phase.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of sampling phase reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOC</name>
                <description>End of conversion flag
This bit is set by hardware at the end of each regular conversion of a channel when a new data is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Regular channel conversion not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Regular channel conversion complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOS</name>
                <description>End of regular sequence flag
This bit is set by hardware at the end of the conversions of a regular sequence of channels. It is cleared by software writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Regular Conversions sequence not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Regular Conversions sequence complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVR</name>
                <description>ADC overrun
This bit is set by hardware when an overrun occurs on a regular channel, meaning that a new conversion has completed while the EOC flag was already set. It is cleared by software writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEOC</name>
                <description>Injected channel end of conversion flag
This bit is set by hardware at the end of each injected conversion of a channel when a new data is available in the corresponding ADC_JDRy register. It is cleared by software writing 1 to it or by reading the corresponding ADC_JDRy register</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Injected channel conversion not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected channel conversion complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEOS</name>
                <description>Injected channel end of sequence flag
This bit is set by hardware at the end of the conversions of all injected channels in the group. It is cleared by software writing 1 to it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Injected conversion sequence not complete (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected conversions complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1</name>
                <description>Analog watchdog 1 flag
This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT1[11:0] and HT1[11:0] of ADC_TR1 register. It is cleared by software. writing 1 to it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog 1 event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2</name>
                <description>Analog watchdog 2 flag
This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT2[7:0] and HT2[7:0] of ADC_TR2 register. It is cleared by software writing 1 to it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog 2 event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 2 event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3</name>
                <description>Analog watchdog 3 flag
This bit is set by hardware when the converted voltage crosses the values programmed in the fields LT3[7:0] and HT3[7:0] of ADC_TR3 register. It is cleared by software writing 1 to it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No analog watchdog 3 event occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 3 event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JQOVF</name>
                <description>Injected context queue overflow
This bit is set by hardware when an Overflow of the Injected Queue of Context occurs. It is cleared by software writing 1 to it. Refer to  for more information.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No injected context queue overflow occurred (or the flag event was already acknowledged and cleared by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected context queue overflow has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_IER</name>
            <displayName>ADC_IER</displayName>
            <description>ADC interrupt enable register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADRDYIE</name>
                <description>ADC ready interrupt enable
This bit is set and cleared by software to enable/disable the ADC Ready interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADRDY interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSMPIE</name>
                <description>End of sampling flag interrupt enable for regular conversions
This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt for regular conversions.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOSMP interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOCIE</name>
                <description>End of regular conversion interrupt enable
This bit is set and cleared by software to enable/disable the end of a regular conversion interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOC interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOC interrupt enabled. An interrupt is generated when the EOC bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOSIE</name>
                <description>End of regular sequence of conversions interrupt enable
This bit is set and cleared by software to enable/disable the end of regular sequence of conversions interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOS interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOS interrupt enabled. An interrupt is generated when the EOS bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRIE</name>
                <description>Overrun interrupt enable
This bit is set and cleared by software to enable/disable the Overrun interrupt of a regular conversion.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Overrun interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEOCIE</name>
                <description>End of injected conversion interrupt enable
This bit is set and cleared by software to enable/disable the end of an injected conversion interrupt.
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>JEOC interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEOSIE</name>
                <description>End of injected sequence of conversions interrupt enable
This bit is set and cleared by software to enable/disable the end of injected sequence of conversions interrupt.
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>JEOS interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>JEOS interrupt enabled. An interrupt is generated when the JEOS bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1IE</name>
                <description>Analog watchdog 1 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog 1 interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD2IE</name>
                <description>Analog watchdog 2 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 2 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 2 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD3IE</name>
                <description>Analog watchdog 3 interrupt enable
This bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 3 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 3 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JQOVFIE</name>
                <description>Injected context queue overflow interrupt enable
This bit is set and cleared by software to enable/disable the Injected Context Queue Overflow interrupt.
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Injected Context Queue Overflow interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected Context Queue Overflow interrupt enabled. An interrupt is generated when the JQOVF bit is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CR</name>
            <displayName>ADC_CR</displayName>
            <description>ADC control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x20000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADEN</name>
                <description>ADC enable control
This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the flag ADRDY has been set.
It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.
Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0) except for bit ADVREGEN which must be 1 (and the software must have wait for the startup time of the voltage regulator)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC is disabled (OFF state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to enable the ADC.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDIS</name>
                <description>ADC disable command
This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).
It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).
Note: The software is allowed to set ADDIS only when ADEN = 1 and both ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no ADDIS command ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADSTART</name>
                <description>ADC start of regular conversion
This bit is set by software to start ADC conversion of regular channels. Depending on the configuration bits EXTEN, a conversion immediately starts (software trigger configuration) or once a regular hardware trigger event occurs (hardware trigger configuration).
It is cleared by hardware:
in Single conversion mode when software trigger is selected (EXTSEL = 0x0): at the assertion of the End of Regular Conversion Sequence (EOS) flag.
in all cases: after the execution of the ADSTP command, at the same time that ADSTP is cleared by hardware.
Note: The software is allowed to set ADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC)
In auto-injection mode (JAUTO = 1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC regular conversion is ongoing.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to start regular conversions. Read 1 means that the ADC is operating and eventually converting a regular channel.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JADSTART</name>
                <description>ADC start of injected conversion
This bit is set by software to start ADC conversion of injected channels. Depending on the configuration bits JEXTEN, a conversion immediately starts (software trigger configuration) or once an injected hardware trigger event occurs (hardware trigger configuration).
It is cleared by hardware:
in Single conversion mode when software trigger is selected (JEXTSEL = 0x0): at the assertion of the End of Injected Conversion Sequence (JEOS) flag.
in all cases: after the execution of the JADSTP command, at the same time that JADSTP is cleared by hardware.
Note: The software is allowed to set JADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC).
In auto-injection mode (JAUTO = 1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC injected conversion is ongoing.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to start injected conversions. Read 1 means that the ADC is operating and eventually converting an injected channel.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADSTP</name>
                <description>ADC stop of regular conversion command
This bit is set by software to stop and discard an ongoing regular conversion (ADSTP Command).
It is cleared by hardware when the conversion is effectively discarded and the ADC regular sequence and triggers can be re-configured. The ADC is then ready to accept a new start of regular conversions (ADSTART command).
Note: The software is allowed to set ADSTP only when ADSTART = 1 and ADDIS = 0 (ADC is enabled and eventually converting a regular conversion and there is no pending request to disable the ADC).
In auto-injection mode (JAUTO = 1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC stop regular conversion command ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to stop regular conversions ongoing. Read 1 means that an ADSTP command is in progress.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JADSTP</name>
                <description>ADC stop of injected conversion command
This bit is set by software to stop and discard an ongoing injected conversion (JADSTP Command).
It is cleared by hardware when the conversion is effectively discarded and the ADC injected sequence and triggers can be re-configured. The ADC is then ready to accept a new start of injected conversions (JADSTART command).
Note: The software is allowed to set JADSTP only when JADSTART = 1 and ADDIS = 0 (ADC is enabled and eventually converting an injected conversion and there is no pending request to disable the ADC)
In Auto-injection mode (JAUTO = 1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No ADC stop injected conversion command ongoing</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to stop injected conversions ongoing. Read 1 means that an ADSTP command is in progress.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADVREGEN</name>
                <description>ADC voltage regulator enable
This bits is set by software to enable the ADC voltage regulator.
Before performing any operation such as launching a calibration or enabling the ADC, the ADC voltage regulator must first be enabled and the software must wait for the regulator start-up time.
For more details about the ADC voltage regulator enable and disable sequences, refer to (ADVREGEN).
The software can program this bit field only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC Voltage regulator disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC Voltage regulator enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEEPPWD</name>
                <description>Deep-power-down enable
This bit is set and cleared by software to put the ADC in Deep-power-down mode.
Note: The software is allowed to write this bit only when the ADC is disabled (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC not in Deep-power down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC in Deep-power-down (default reset state)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCALDIF</name>
                <description>Differential mode for calibration
This bit is set and cleared by software to configure the Single-ended or Differential inputs mode for the calibration.
Note: The software is allowed to write this bit only when the ADC is disabled and is not calibrating (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing ADCAL launches a calibration in Single-ended inputs mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing ADCAL launches a calibration in Differential inputs mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADCAL</name>
                <description>ADC calibration
This bit is set by software to start the calibration of the ADC. Program first the bit ADCALDIF to determine if this calibration applies for Single-ended or Differential inputs mode.
It is cleared by hardware after calibration is complete.
Note: The software is allowed to launch a calibration by setting ADCAL only when ADEN = 0.
The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN = 1 and ADSTART = 0 and JADSTART = 0 (ADC enabled and no conversion is ongoing)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Calibration complete</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Write 1 to calibrate the ADC. Read at 1 means that a calibration in progress.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CFGR</name>
            <displayName>ADC_CFGR</displayName>
            <description>ADC configuration register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAEN</name>
                <description>Direct memory access enable
This bit is set and cleared by software to enable the generation of DMA requests. This allows to use the DMA to manage automatically the converted data. For more details, refer to conversions using the DMA.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMACFG</name>
                <description>Direct memory access configuration
This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.
For more details, refer to
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA One Shot mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA Circular mode selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RES</name>
                <description>Data resolution
These bits are written by software to select the resolution of the conversion.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>12-bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>10-bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8-bit</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>6-bit</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL0</name>
                <description>External trigger selection for regular group
These bits select the external event used to trigger the start of conversion of a regular group:
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_ext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_ext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_ext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_ext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_ext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_ext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_ext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_ext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL1</name>
                <description>External trigger selection for regular group
These bits select the external event used to trigger the start of conversion of a regular group:
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_ext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_ext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_ext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_ext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_ext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_ext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_ext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_ext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL2</name>
                <description>External trigger selection for regular group
These bits select the external event used to trigger the start of conversion of a regular group:
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_ext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_ext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_ext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_ext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_ext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_ext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_ext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_ext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL3</name>
                <description>External trigger selection for regular group
These bits select the external event used to trigger the start of conversion of a regular group:
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_ext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_ext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_ext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_ext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_ext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_ext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_ext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_ext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTSEL4</name>
                <description>External trigger selection for regular group
These bits select the external event used to trigger the start of conversion of a regular group:
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_ext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_ext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_ext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_ext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_ext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_ext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_ext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_ext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTEN</name>
                <description>External trigger enable and polarity selection for regular channels
These bits are set and cleared by software to select the external trigger polarity and enable the trigger of a regular group.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Hardware trigger detection disabled (conversions can be launched by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Hardware trigger detection on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Hardware trigger detection on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Hardware trigger detection on both the rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRMOD</name>
                <description>Overrun mode
This bit is set and cleared by software and configure the way data overrun is managed.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC_DR register is preserved with the old data when an overrun is detected. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC_DR register is overwritten with the last conversion result when an overrun is detected.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CONT</name>
                <description>Single / Continuous conversion mode for regular conversions
This bit is set and cleared by software. If it is set, regular conversion takes place continuously until it is cleared.
Note: It is not possible to have both Discontinuous mode and Continuous mode enabled: it is forbidden to set both DISCEN = 1 and CONT = 1.
The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Single conversion mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Continuous conversion mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTDLY</name>
                <description>Delayed conversion mode
This bit is set and cleared by software to enable/disable the Auto Delayed Conversion mode..
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Auto-delayed conversion mode off</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Auto-delayed conversion mode on</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALIGN</name>
                <description>Data alignment
This bit is set and cleared by software to select right or left alignment. Refer to register, data alignment and offset (ADC_DR, OFFSET, OFFSET_CH, ALIGN).
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Right alignment</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Left alignment</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISCEN</name>
                <description>Discontinuous mode for regular channels
This bit is set and cleared by software to enable/disable Discontinuous mode for regular channels.
Note: It is not possible to have both Discontinuous mode and Continuous mode enabled: it is forbidden to set both DISCEN = 1 and CONT = 1.
It is not possible to use both auto-injected mode and Discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.
The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Discontinuous mode for regular channels disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Discontinuous mode for regular channels enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DISCNUM</name>
                <description>Discontinuous mode channel count
These bits are written by software to define the number of regular channels to be converted in Discontinuous mode, after receiving an external trigger.
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 channel</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 channels</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8 channels</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JDISCEN</name>
                <description>Discontinuous mode on injected channels
This bit is set and cleared by software to enable/disable Discontinuous mode on the injected channels of a group.
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).
It is not possible to use both auto-injected mode and Discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Discontinuous mode on injected channels disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Discontinuous mode on injected channels enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JQM</name>
                <description>JSQR queue mode
This bit is set and cleared by software.
It defines how an empty Queue is managed.
Refer to  for more information.
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>JSQR mode 0: The Queue is never empty and maintains the last written configuration into JSQR.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>JSQR mode 1: The Queue can be empty and when this occurs, the software and hardware triggers of the injected sequence are both internally disabled just after the completion of the last valid injected sequence.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1SGL</name>
                <description>Enable the watchdog 1 on a single channel or on all channels
This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWD1CH[4:0] bits or on all the channels
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 enabled on all channels</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 enabled on a single channel</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1EN</name>
                <description>Analog watchdog 1 enable on regular channels
This bit is set and cleared by software
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 disabled on regular channels</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 enabled on regular channels</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JAWD1EN</name>
                <description>Analog watchdog 1 enable on injected channels
This bit is set and cleared by software
Note: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog watchdog 1 disabled on injected channels</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog watchdog 1 enabled on injected channels</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JAUTO</name>
                <description>Automatic injected group conversion
This bit is set and cleared by software to enable/disable automatic injected group conversion after regular group conversion.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no regular nor injected conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Automatic injected group conversion disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Automatic injected group conversion enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AWD1CH</name>
                <description>Analog watchdog 1 channel selection
These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.
.....
others: reserved, must not be used
Note: Some channels are not connected physically. Keep the corresponding AWD1CH[4:0] setting to the reset value.
The channel selected by AWD1CH must be also selected into the SQRi or JSQRi registers.
The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC analog input channel 0 monitored by AWD1 </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC analog input channel 1 monitored by AWD1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>ADC analog input channel 19 monitored by AWD1</description>
                    <value>0x13</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JQDIS</name>
                <description>Injected Queue disable
These bits are set and cleared by software to disable the Injected Queue mechanism :
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no regular nor injected conversion is ongoing).
A set or reset of JQDIS bit causes the injected queue to be flushed and the JSQR register is cleared.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Injected Queue enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected Queue disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CFGR2</name>
            <displayName>ADC_CFGR2</displayName>
            <description>ADC configuration register 2 </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROVSE</name>
                <description>Regular Oversampling Enable
This bit is set and cleared by software to enable regular oversampling.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Regular Oversampling disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Regular Oversampling enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JOVSE</name>
                <description>Injected Oversampling Enable
This bit is set and cleared by software to enable injected oversampling.
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Injected Oversampling disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Injected Oversampling enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVSR</name>
                <description>Oversampling ratio
This bitfield is set and cleared by software to define the oversampling ratio.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>4x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8x</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>16x</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>32x</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>64x</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>128x</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>256x</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVSS</name>
                <description>Oversampling shift
This bitfield is set and cleared by software to define the right shifting applied to the raw oversampling result.
Other codes reserved
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No shift</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Shift 1-bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Shift 2-bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Shift 3-bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Shift 4-bits</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Shift 5-bits</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Shift 6-bits</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Shift 7-bits</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Shift 8-bits</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TROVS</name>
                <description>Triggered Regular Oversampling
This bit is set and cleared by software to enable triggered oversampling
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>All oversampled conversions for a channel are done consecutively following a trigger</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Each oversampled conversion for a channel needs a new trigger</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ROVSM</name>
                <description>Regular Oversampling mode
This bit is set and cleared by software to select the regular oversampling mode.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Continued mode: When injected conversions are triggered, the oversampling is temporary stopped and continued after the injection sequence (oversampling buffer is maintained during injected sequence)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resumed mode: When injected conversions are triggered, the current oversampling is aborted and resumed from start after the injection sequence (oversampling buffer is zeroed by injected sequence start)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWTRIG</name>
                <description>Software trigger bit for sampling time control trigger mode
This bit is set and cleared by software to enable the bulb sampling mode.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Software trigger starts the conversion for sampling time control trigger mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Software trigger starts the sampling for sampling time control trigger mode </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BULB</name>
                <description>Bulb sampling mode
This bit is set and cleared by software to enable the bulb sampling mode.
SAMPTRIG bit must not be set when the BULB bit is set.
The very first ADC conversion is performed with the sampling time specified in SMPx bits.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bulb sampling mode disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bulb sampling mode enabled. The sampling period starts just after the previous end of conversion.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPTRIG</name>
                <description>Sampling time control trigger mode
This bit is set and cleared by software to enable the sampling time control trigger mode.
The sampling time starts on the trigger rising edge, and the conversion on the trigger falling edge.
EXTEN bit should be set to 01. BULB bit must not be set when the SMPTRIG bit is set.
When EXTEN bit is set to 00, set SWTRIG to start the sampling and clear SWTRIG bit to start the conversion.
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sampling time control trigger mode disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sampling time control trigger mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SMPR1</name>
            <displayName>ADC_SMPR1</displayName>
            <description>ADC sample time register 1 </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMP0</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP1</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP2</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP3</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP4</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP5</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP6</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP7</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP8</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP9</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMPPLUS</name>
                <description>Addition of one clock cycle to the sampling time.
To make sure no conversion is ongoing, the software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2.5 ADC clock cycle sampling time becomes 3.5 ADC clock cycles for the ADC_SMPR1 and ADC_SMPR2 registers.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The sampling time remains set to 2.5 ADC clock cycles remains </description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SMPR2</name>
            <displayName>ADC_SMPR2</displayName>
            <description>ADC sample time register 2 </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMP10</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP11</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP12</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP13</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP14</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP15</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP16</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP17</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP18</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMP19</name>
                <description>Channel x sampling time selection
These bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>2.5 ADC clock cycles</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>6.5 ADC clock cycles</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>12.5 ADC clock cycles</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>24.5 ADC clock cycles</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>47.5 ADC clock cycles</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>92.5 ADC clock cycles</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>247.5 ADC clock cycles</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>640.5 ADC clock cycles</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_TR1</name>
            <displayName>ADC_TR1</displayName>
            <description>ADC watchdog threshold register 1 </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x0FFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT1</name>
                <description>Analog watchdog 1 lower threshold
These bits are written by software to define the lower threshold for the analog watchdog 1.
Refer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AWDFILT</name>
                <description>Analog watchdog filtering parameter
This bit is set and cleared by software.
...
Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filtering </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>two consecutive detection generates an AWDx flag or an interrupt</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Eight consecutive detection generates an AWDx flag or an interrupt</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HT1</name>
                <description>Analog watchdog 1 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog 1.
Refer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_TR2</name>
            <displayName>ADC_TR2</displayName>
            <description>ADC watchdog threshold register 2 </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00FF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT2</name>
                <description>Analog watchdog 2 lower threshold
These bits are written by software to define the lower threshold for the analog watchdog 2.
Refer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT2</name>
                <description>Analog watchdog 2 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog 2.
Refer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_TR3</name>
            <displayName>ADC_TR3</displayName>
            <description>ADC watchdog threshold register 3 </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00FF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LT3</name>
                <description>Analog watchdog 3 lower threshold
These bits are written by software to define the lower threshold for the analog watchdog 3.
This watchdog compares the 8-bit of LT3 with the 8 MSB of the converted data.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HT3</name>
                <description>Analog watchdog 3 higher threshold
These bits are written by software to define the higher threshold for the analog watchdog 3.
Refer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SQR1</name>
            <displayName>ADC_SQR1</displayName>
            <description>ADC regular sequence register 1 </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L</name>
                <description>Regular channel sequence length
These bits are written by software to define the total number of conversions in the regular channel conversion sequence.
...
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 conversions</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>16 conversions</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SQ1</name>
                <description>1st conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 1st in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ2</name>
                <description>2nd conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 2nd in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ3</name>
                <description>3rd conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 3rd in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ4</name>
                <description>4th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 4th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SQR2</name>
            <displayName>ADC_SQR2</displayName>
            <description>ADC regular sequence register 2 </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SQ5</name>
                <description>5th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 5th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ6</name>
                <description>6th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 6th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ7</name>
                <description>7th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 7th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ8</name>
                <description>8th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 8th in the regular conversion sequence
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ9</name>
                <description>9th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 9th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SQR3</name>
            <displayName>ADC_SQR3</displayName>
            <description>ADC regular sequence register 3 </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SQ10</name>
                <description>10th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 10th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ11</name>
                <description>11th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 11th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ12</name>
                <description>12th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 12th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ13</name>
                <description>13th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 13th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ14</name>
                <description>14th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 14th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SQR4</name>
            <displayName>ADC_SQR4</displayName>
            <description>ADC regular sequence register 4 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SQ15</name>
                <description>15th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 15th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SQ16</name>
                <description>16th conversion in regular sequence
These bits are written by software with the channel number (0 to 19) assigned as the 16th in the regular conversion sequence.
Note: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_DR</name>
            <displayName>ADC_DR</displayName>
            <description>ADC regular data register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDATA</name>
                <description>Regular data converted
These bits are read-only. They contain the conversion result from the last converted regular channel. The data are left- or right-aligned as described in .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_JSQR</name>
            <displayName>ADC_JSQR</displayName>
            <description>ADC injected sequence register </description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>JL</name>
                <description>Injected channel sequence length
These bits are written by software to define the total number of conversions in the injected channel conversion sequence.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 conversion</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 conversions</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 conversions</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4 conversions</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEXTSEL</name>
                <description>External Trigger Selection for injected group
These bits select the external event used to trigger the start of conversion of an injected group:
...
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_jext_trg0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_jext_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_jext_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_jext_trg3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>adc_jext_trg4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>adc_jext_trg5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>adc_jext_trg6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>adc_jext_trg7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>adc_jext_trg31</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JEXTEN</name>
                <description>External trigger enable and polarity selection for injected channels
These bits are set and cleared by software to select the external trigger polarity and enable the trigger of an injected group.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).
If JQM = 1 and if the Queue of Context becomes empty, the software and hardware triggers of the injected sequence are both internally disabled (refer to Queue of context for injected conversions)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>If JQDIS = 0 (queue enabled), hardware and software trigger detection disabled. Otherwise, the queue is disabled as well as hardware trigger detection (conversions can be launched by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Hardware trigger detection on the rising edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Hardware trigger detection on the falling edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Hardware trigger detection on both the rising and falling edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>JSQ1</name>
                <description>1st conversion in the injected sequence
These bits are written by software with the channel number (0 to 19) assigned as the 1st in the injected conversion sequence.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>JSQ2</name>
                <description>2nd conversion in the injected sequence
These bits are written by software with the channel number (0 to 19) assigned as the 2nd in the injected conversion sequence.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>JSQ3</name>
                <description>3rd conversion in the injected sequence
These bits are written by software with the channel number (0 to 19) assigned as the 3rd in the injected conversion sequence.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>JSQ4</name>
                <description>4th conversion in the injected sequence
These bits are written by software with the channel number (0 to 19) assigned as the 4th in the injected conversion sequence.
Note: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).</description>
                <bitOffset>27</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_OFR1</name>
            <displayName>ADC_OFR1</displayName>
            <description>ADC offset 1 register</description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET</name>
                <description>Data offset y for the channel programmed into bits OFFSET_CH[4:0]
These bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
If several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.
Ex: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSETPOS</name>
                <description>Positive offset
This bit is set and cleared by software to enable the positive offset.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Negative offset </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Positive offset </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SATEN</name>
                <description>Saturation enable
This bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No saturation control, offset result can be signed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Saturation enabled, offset result unsigned and saturated at 0x000 and 0xFFF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OFFSET_CH</name>
                <description>Channel selection for the data offset y
These bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the data offset y.
If OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_EN</name>
                <description>Offset y enable
This bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_OFR2</name>
            <displayName>ADC_OFR2</displayName>
            <description>ADC offset 2 register</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET</name>
                <description>Data offset y for the channel programmed into bits OFFSET_CH[4:0]
These bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
If several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.
Ex: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSETPOS</name>
                <description>Positive offset
This bit is set and cleared by software to enable the positive offset.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Negative offset </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Positive offset </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SATEN</name>
                <description>Saturation enable
This bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No saturation control, offset result can be signed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Saturation enabled, offset result unsigned and saturated at 0x000 and 0xFFF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OFFSET_CH</name>
                <description>Channel selection for the data offset y
These bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the data offset y.
If OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_EN</name>
                <description>Offset y enable
This bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_OFR3</name>
            <displayName>ADC_OFR3</displayName>
            <description>ADC offset 3 register</description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET</name>
                <description>Data offset y for the channel programmed into bits OFFSET_CH[4:0]
These bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
If several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.
Ex: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSETPOS</name>
                <description>Positive offset
This bit is set and cleared by software to enable the positive offset.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Negative offset </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Positive offset </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SATEN</name>
                <description>Saturation enable
This bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No saturation control, offset result can be signed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Saturation enabled, offset result unsigned and saturated at 0x000 and 0xFFF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OFFSET_CH</name>
                <description>Channel selection for the data offset y
These bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the data offset y.
If OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_EN</name>
                <description>Offset y enable
This bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_OFR4</name>
            <displayName>ADC_OFR4</displayName>
            <description>ADC offset 4 register</description>
            <addressOffset>0x6c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET</name>
                <description>Data offset y for the channel programmed into bits OFFSET_CH[4:0]
These bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
If several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.
Ex: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSETPOS</name>
                <description>Positive offset
This bit is set and cleared by software to enable the positive offset.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Negative offset </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Positive offset </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SATEN</name>
                <description>Saturation enable
This bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No saturation control, offset result can be signed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Saturation enabled, offset result unsigned and saturated at 0x000 and 0xFFF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OFFSET_CH</name>
                <description>Channel selection for the data offset y
These bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.
Note: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the data offset y.
If OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_EN</name>
                <description>Offset y enable
This bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].
Note: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_JDR1</name>
            <displayName>ADC_JDR1</displayName>
            <description>ADC injected channel 1 data register</description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>JDATA</name>
                <description>Injected data
These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_JDR2</name>
            <displayName>ADC_JDR2</displayName>
            <description>ADC injected channel 2 data register</description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>JDATA</name>
                <description>Injected data
These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_JDR3</name>
            <displayName>ADC_JDR3</displayName>
            <description>ADC injected channel 3 data register</description>
            <addressOffset>0x88</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>JDATA</name>
                <description>Injected data
These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_JDR4</name>
            <displayName>ADC_JDR4</displayName>
            <description>ADC injected channel 4 data register</description>
            <addressOffset>0x8c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>JDATA</name>
                <description>Injected data
These bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD2CR</name>
            <displayName>ADC_AWD2CR</displayName>
            <description>ADC Analog Watchdog 2 Configuration Register </description>
            <addressOffset>0xa0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AWD2CH</name>
                <description>Analog watchdog 2 channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 2.
AWD2CH[i] = 0: ADC analog input channel i is not monitored by AWD2
AWD2CH[i] = 1: ADC analog input channel i is monitored by AWD2
When AWD2CH[19:0] = 000..0, the analog Watchdog 2 is disabled
Note: The channels selected by AWD2CH must be also selected into the SQRi or JSQRi registers.
The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the analog watchdog.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_AWD3CR</name>
            <displayName>ADC_AWD3CR</displayName>
            <description>ADC Analog Watchdog 3 Configuration Register </description>
            <addressOffset>0xa4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AWD3CH</name>
                <description>Analog watchdog 3 channel selection
These bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 3.
AWD3CH[i] = 0: ADC analog input channel i is not monitored by AWD3
AWD3CH[i] = 1: ADC analog input channel i is monitored by AWD3
When AWD3CH[19:0] = 000..0, the analog Watchdog 3 is disabled
Note: The channels selected by AWD3CH must be also selected into the SQRi or JSQRi registers.
The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).
Some channels are not connected physically and must not be selected for the analog watchdog.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_DIFSEL</name>
            <displayName>ADC_DIFSEL</displayName>
            <description>ADC Differential mode Selection Register </description>
            <addressOffset>0xb0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIFSEL</name>
                <description>Differential mode for channels 19 to 0.
These bits are set and cleared by software. They allow to select if a channel is configured as Single-ended or Differential mode.
DIFSEL[i] = 0: ADC analog input channel is configured in Single-ended mode
DIFSEL[i] = 1: ADC analog input channel i is configured in Differential mode
Note: The DIFSEL bits corresponding to channels that are either connected to a single-ended I/O port or to an internal channel must be kept their reset value (Single-ended input mode).
The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CALFACT</name>
            <displayName>ADC_CALFACT</displayName>
            <description>ADC Calibration Factors </description>
            <addressOffset>0xb4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CALFACT_S</name>
                <description>Calibration Factors In Single-ended mode
These bits are written by hardware or by software.
Once a single-ended inputs calibration is complete, they are updated by hardware with the calibration factors.
Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new single-ended calibration is launched.
Note: The software is allowed to write these bits only when ADEN = 1, ADSTART = 0 and JADSTART = 0 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALFACT_D</name>
                <description>Calibration Factors in differential mode
These bits are written by hardware or by software.
Once a differential inputs calibration is complete, they are updated by hardware with the calibration factors.
Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new differential calibration is launched.
Note: The software is allowed to write these bits only when ADEN = 1, ADSTART = 0 and JADSTART = 0 (ADC is enabled and no calibration is ongoing and no conversion is ongoing).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_OR</name>
            <displayName>ADC_OR</displayName>
            <description>ADC option register </description>
            <addressOffset>0xc8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OP0</name>
                <description>Option bit 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VDDCORE channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VDDCORE channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OP1</name>
                <description>Option bit 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>INP0 GPIO switch control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>INP0 GPIO switch control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_CCR</name>
            <displayName>ADC_CCR</displayName>
            <description>ADC common control register </description>
            <addressOffset>0x308</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CKMODE</name>
                <description>ADC clock mode
These bits are set and cleared by software to define the ADC clock scheme (which is common to both master and slave ADCs):
In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.
Note: The software is allowed to write these bits only when the ADCs are disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>adc_ker_ck (x = 1) (Asynchronous clock mode), generated at product level (refer to Section 6: Reset and clock control (RCC))</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>adc_hclk/1 (Synchronous clock mode). This configuration must be enabled only if the AHB clock prescaler is set to 1 (HPRE[3:0] = 0XXX in RCC_CFGR register) and if the system clock has a 50% duty cycle.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>adc_hclk/2 (Synchronous clock mode)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>adc_hclk/4 (Synchronous clock mode)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRESC</name>
                <description>ADC prescaler
These bits are set and cleared by software to select the frequency of the clock to the ADC. The clock is common for all the ADCs.
other: reserved
Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0). The ADC prescaler value is applied only when CKMODE[1:0] = 0b00.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>input ADC clock not divided</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>input ADC clock divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>input ADC clock divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>input ADC clock divided by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>input ADC clock divided by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>input ADC clock divided by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>input ADC clock divided by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>input ADC clock divided by 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>input ADC clock divided by 32</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>input ADC clock divided by 64</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>input ADC clock divided by 128</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>input ADC clock divided by 256</description>
                    <value>0xB</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VREFEN</name>
                <description>VREFINT enable
This bit is set and cleared by software to enable/disable the VREFINT channel.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VREFINT channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VREFINT channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSEN</name>
                <description>VSENSE enable
This bit is set and cleared by software to control VSENSE.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Temperature sensor channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Temperature sensor channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VBATEN</name>
                <description>VBAT enable
This bit is set and cleared by software to control.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VBAT channel disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VBAT channel enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_HWCFGR0</name>
            <displayName>ADC_HWCFGR0</displayName>
            <description>ADC hardware configuration register </description>
            <addressOffset>0x3f0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00001211</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADCNUM</name>
                <description>Number of ADCs implemented</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>One ADC instance implemented</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Two ADC instances implemented</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Three ADCs instances implemented</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MULPIPE</name>
                <description>Number of pipeline stages</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>One-stage pipeline</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPBITS</name>
                <description>Number of option bits
0002: 2 option bits implemented in the ADC option register (ADC_OR) at address offset 0xC8</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No option register implemented</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEVALUE</name>
                <description>Idle value for non-selected channels</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Dummy channel selection is 0x13</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Dummy channel selection is 0x1F</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_VERR</name>
            <displayName>ADC_VERR</displayName>
            <description>ADC version register </description>
            <addressOffset>0x3f4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000012</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MINREV</name>
                <description>Minor revision
These bits returns the ADC IP minor revision
0002: Major revision = X.2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Major revision = X.1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MAJREV</name>
                <description>Major revision
These bits returns the ADC IP major revision</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Major revision = 1.X</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_IPDR</name>
            <displayName>ADC_IPDR</displayName>
            <description>ADC identification register </description>
            <addressOffset>0x3f8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00110006</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ID</name>
                <description>Peripheral identifier
These bits returns the ADC identifier.
ID[31:0] = 0x0011 0006: c7amba_aditf5_90_v1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_SIDR</name>
            <displayName>ADC_SIDR</displayName>
            <description>ADC size identification register </description>
            <addressOffset>0x3fc</addressOffset>
            <size>0x20</size>
            <resetValue>0xA3C5DD01</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SID</name>
                <description>Size Identification
SID[31:8]: fixed code that characterizes the ADC_SIDR register. This field is always read at 0xA3C5DD.
SID[7:0]: read-only numeric field that returns the address offset (in Kbytes) of the identification registers from the IP base address:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 Kbytes address offset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 Kbytes address offset</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>4 Kbytes address offset</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>8  Kbytes address offset</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>CRC</name>
        <description>Cyclic redundancy check calculation unit</description>
		<groupName>CRC</groupName>
        <baseAddress>0x40023000</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>CRC_DR</name>
            <displayName>CRC_DR</displayName>
            <description>CRC data register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data register bits
This register is used to write new data to the CRC calculator.
It holds the previous CRC calculation result when it is read.
If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_IDR</name>
            <displayName>CRC_IDR</displayName>
            <description>CRC independent data register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDR</name>
                <description>General-purpose 32-bit data register bits
These bits can be used as a temporary storage location for four bytes.
This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_CR</name>
            <displayName>CRC_CR</displayName>
            <description>CRC control register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESET</name>
                <description>RESET bit
This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLYSIZE</name>
                <description>Polynomial size
These bits control the size of the polynomial.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>32 bit polynomial</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>16 bit polynomial</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>8 bit polynomial</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>7 bit polynomial</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_IN</name>
                <description>Reverse input data
These bits control the reversal of the bit order of the input data</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit reversal done by byte</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Bit reversal done by half-word</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Bit reversal done by word</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>Reverse output data
This bit controls the reversal of the bit order of the output data.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit order not affected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit-reversed output format</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_INIT</name>
            <displayName>CRC_INIT</displayName>
            <description>CRC initial value </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT</name>
                <description>Programmable initial CRC value
This register is used to write the CRC initial value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC_POL</name>
            <displayName>CRC_POL</displayName>
            <description>CRC polynomial </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x04C11DB7</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POL</name>
                <description>Programmable polynomial
This register is used to write the coefficients of the polynomial to be used for CRC calculation.
If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
      </registers>
    </peripheral>
    <peripheral>
        <name>DAC</name>
        <description>Digital to analog converter</description>
		<groupName>DAC</groupName>
        <baseAddress>0x42028400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>DAC1</name>
          <description>DAC1 global interrupt</description>   
          <value>38</value>
        </interrupt>
        <registers>
          <register>
            <name>DAC_CR</name>
            <displayName>DAC_CR</displayName>
            <description>DAC control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN1</name>
                <description>DAC channel1 enable
This bit is set and cleared by software to enable/disable DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEN1</name>
                <description>DAC channel1 trigger enable
This bit is set and cleared by software to enable/disable DAC channel1 trigger.
Note: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_hclk clock cycle.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 trigger disabled and data written into the DAC_DHR1 register are transferred one dac_hclk clock cycle later to the DAC_DOR1 register</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 trigger enabled and data from the DAC_DHR1 register are transferred three dac_hclk clock cycles later to the DAC_DOR1 register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSEL1</name>
                <description>DAC channel1 trigger selection
These bits select the external event used to trigger DAC channel1
...
Refer to the trigger selection tables in  for details on trigger configuration and mapping.
Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SWTRIG1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>dac_ch1_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>dac_ch1_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>dac_ch1_trg15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAVE1</name>
                <description>DAC channel1 noise/triangle wave generation enable
These bits are set and cleared by software.
1x: Triangle wave generation enabled
Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>wave generation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise wave generation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MAMP1</name>
                <description>DAC channel1 mask/amplitude selector
These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.
≥ 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Unmask bit0 of LFSR/ triangle amplitude equal to 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047</description>
                    <value>0xA</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAEN1</name>
                <description>DAC channel1 DMA enable
This bit is set and cleared by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 DMA mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 DMA mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAUDRIE1</name>
                <description>DAC channel1 DMA Underrun Interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 DMA Underrun Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 DMA Underrun Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CEN1</name>
                <description>DAC channel1 calibration enable
This bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1 = 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 in Normal operating mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 in calibration mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EN2</name>
                <description>DAC channel2 enable
This bit is set and cleared by software to enable/disable DAC channel2.
Note: These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEN2</name>
                <description>DAC channel2 trigger enable
This bit is set and cleared by software to enable/disable DAC channel2 trigger
Note: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_hclk clock cycle.
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 trigger disabled and data written into the DAC_DHR2 register are transferred one dac_hclk clock cycle later to the DAC_DOR2 register</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 trigger enabled and data from the DAC_DHR2 register are transferred three dac_hclk clock cycles later to the DAC_DOR2 register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSEL2</name>
                <description>DAC channel2 trigger selection
These bits select the external event used to trigger DAC channel2
...
Refer to the trigger selection tables in  for details on trigger configuration and mapping.
Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SWTRIG2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>dac_ch2_trg1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>dac_ch2_trg2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>dac_ch2_trg15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAVE2</name>
                <description>DAC channel2 noise/triangle wave generation enable
These bits are set/reset by software.
1x: Triangle wave generation enabled
Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>wave generation disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise wave generation enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MAMP2</name>
                <description>DAC channel2 mask/amplitude selector
These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.
≥ 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
Note: These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Unmask bit0 of LFSR/ triangle amplitude equal to 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047</description>
                    <value>0xA</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAEN2</name>
                <description>DAC channel2 DMA enable
This bit is set and cleared by software.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 DMA mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 DMA mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAUDRIE2</name>
                <description>DAC channel2 DMA underrun interrupt enable
This bit is set and cleared by software.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 DMA underrun interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 DMA underrun interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CEN2</name>
                <description>DAC channel2 calibration enable
This bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 in Normal operating mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 in calibration mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SWTRGR</name>
            <displayName>DAC_SWTRGR</displayName>
            <description>DAC software trigger register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SWTRIG1</name>
                <description>DAC channel1 software trigger
This bit is set by software to trigger the DAC in software trigger mode.
Note: This bit is cleared by hardware (one dac_hclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWTRIG2</name>
                <description>DAC channel2 software trigger
This bit is set by software to trigger the DAC in software trigger mode.
Note: This bit is cleared by hardware (one dac_hclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12R1</name>
            <displayName>DAC_DHR12R1</displayName>
            <description>DAC channel1 12-bit right-aligned data holding register	</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 12-bit right-aligned data
These bits are written by software. They specify 12-bit data for DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC1DHRB</name>
                <description>DAC channel1 12-bit right-aligned data B
These bits are written by software. They specify 12-bit data for DAC channel1 when the DAC operates in Double data mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12L1</name>
            <displayName>DAC_DHR12L1</displayName>
            <description>DAC channel1 12-bit left aligned data holding register	</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 12-bit left-aligned data
These bits are written by software.
They specify 12-bit data for DAC channel1.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC1DHRB</name>
                <description>DAC channel1 12-bit left-aligned data B
These bits are written by software. They specify 12-bit data for DAC channel1 when the DAC operates in Double data mode.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR8R1</name>
            <displayName>DAC_DHR8R1</displayName>
            <description>DAC channel1 8-bit right aligned data holding register	</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 8-bit right-aligned data
These bits are written by software. They specify 8-bit data for DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC1DHRB</name>
                <description>DAC channel1 8-bit right-aligned data
These bits are written by software. They specify 8-bit data for DAC channel1 when the DAC operates in Double data mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12R2</name>
            <displayName>DAC_DHR12R2</displayName>
            <description>DAC channel2 12-bit right aligned data holding register	</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 12-bit right-aligned data
These bits are written by software. They specify 12-bit data for DAC channel2.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHRB</name>
                <description>DAC channel2 12-bit right-aligned data
These bits are written by software. They specify 12-bit data for DAC channel2 when the DAC operates in DMA Double data mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12L2</name>
            <displayName>DAC_DHR12L2</displayName>
            <description>DAC channel2 12-bit left aligned data holding register 	</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 12-bit left-aligned data
These bits are written by software which specify 12-bit data for DAC channel2.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHRB</name>
                <description>DAC channel2 12-bit left-aligned data B
These bits are written by software. They specify 12-bit data for DAC channel2 when the DAC operates in Double data mode.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR8R2</name>
            <displayName>DAC_DHR8R2</displayName>
            <description>DAC channel2 8-bit right-aligned data holding register	</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 8-bit right-aligned data
These bits are written by software which specifies 8-bit data for DAC channel2.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHRB</name>
                <description>DAC channel2 8-bit right-aligned data
These bits are written by software. They specify 8-bit data for DAC channel2 when the DAC operates in Double data mode.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12RD</name>
            <displayName>DAC_DHR12RD</displayName>
            <description>Dual DAC 12-bit right-aligned data holding register	</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 12-bit right-aligned data
These bits are written by software which specifies 12-bit data for DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 12-bit right-aligned data
These bits are written by software which specifies 12-bit data for DAC channel2.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR12LD</name>
            <displayName>DAC_DHR12LD</displayName>
            <description>Dual DAC 12-bit left aligned data holding register	</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 12-bit left-aligned data
These bits are written by software which specifies 12-bit data for DAC channel1.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 12-bit left-aligned data
These bits are written by software which specifies 12-bit data for DAC channel2.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DHR8RD</name>
            <displayName>DAC_DHR8RD</displayName>
            <description>Dual DAC 8-bit right aligned data holding register	</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DHR</name>
                <description>DAC channel1 8-bit right-aligned data
These bits are written by software which specifies 8-bit data for DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DACC2DHR</name>
                <description>DAC channel2 8-bit right-aligned data
These bits are written by software which specifies 8-bit data for DAC channel2.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DOR1</name>
            <displayName>DAC_DOR1</displayName>
            <description>DAC channel1 data output register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC1DOR</name>
                <description>DAC channel1 data output
These bits are read-only, they contain data output for DAC channel1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DACC1DORB</name>
                <description>DAC channel1 data output
These bits are read-only. They contain data output for DAC channel1 B.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_DOR2</name>
            <displayName>DAC_DOR2</displayName>
            <description>DAC channel2 data output register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DACC2DOR</name>
                <description>DAC channel2 data output
These bits are read-only, they contain data output for DAC channel2.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DACC2DORB</name>
                <description>DAC channel2 data output
These bits are read-only. They contain data output for DAC channel2 B.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SR</name>
            <displayName>DAC_SR</displayName>
            <description>DAC status register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAC1RDY</name>
                <description>DAC channel1 ready status bit
This bit is set and cleared by hardware.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel1 is not yet ready to accept the trigger nor output data</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel1 is ready to accept the trigger or output data</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DORSTAT1</name>
                <description>DAC channel1 output register status bit
This bit is set and cleared by hardware. It is applicable only when the DAC operates in Double data mode.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DOR[11:0] is used actual DAC output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DORB[11:0] is used actual DAC output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAUDR1</name>
                <description>DAC channel1 DMA underrun flag
This bit is set by hardware and cleared by software (by writing it to 1).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No DMA underrun error condition occurred for DAC channel1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA underrun error condition occurred for DAC channel1 (the currently selected trigger is driving DAC channel1 conversion at a frequency higher than the DMA service capability rate)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAL_FLAG1</name>
                <description>DAC channel1 calibration offset status
This bit is set and cleared by hardware</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>calibration trimming value is lower than the offset correction value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>calibration trimming value is equal or greater than the offset correction value</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BWST1</name>
                <description>DAC channel1 busy writing sample time flag
This bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI/LSE periods of synchronization).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>There is no write operation of DAC_SHSR1 ongoing: DAC_SHSR1 can be written</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>There is a write operation of DAC_SHSR1 ongoing: DAC_SHSR1 cannot be written</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAC2RDY</name>
                <description>DAC channel2 ready status bit
This bit is set and cleared by hardware.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 is not yet ready to accept the trigger nor output data</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC channel2 is ready to accept the trigger or output data</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DORSTAT2</name>
                <description>DAC channel2 output register status bit
This bit is set and cleared by hardware. It is applicable only when the DAC operates in Double data mode.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DOR[11:0] is used actual DAC output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DORB[11:0] is used actual DAC output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAUDR2</name>
                <description>DAC channel2 DMA underrun flag
This bit is set by hardware and cleared by software (by writing it to 1).
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No DMA underrun error condition occurred for DAC channel2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA underrun error condition occurred for DAC channel2 (the currently selected trigger is driving DAC channel2 conversion at a frequency higher than the DMA service capability rate).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAL_FLAG2</name>
                <description>DAC channel2 calibration offset status
This bit is set and cleared by hardware
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>calibration trimming value is lower than the offset correction value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>calibration trimming value is equal or greater than the offset correction value</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BWST2</name>
                <description>DAC channel2 busy writing sample time flag
This bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI/LSE periods of synchronization).
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>There is no write operation of DAC_SHSR2 ongoing: DAC_SHSR2 can be written</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>There is a write operation of DAC_SHSR2 ongoing: DAC_SHSR2 cannot be written</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_CCR</name>
            <displayName>DAC_CCR</displayName>
            <description>DAC calibration control register </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF00FF00</resetMask>
            <fields>
              <field>
                <name>OTRIM1</name>
                <description>DAC channel1 offset trimming value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OTRIM2</name>
                <description>DAC channel2 offset trimming value
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_MCR</name>
            <displayName>DAC_MCR</displayName>
            <description>DAC mode control register </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE1</name>
                <description>DAC channel1 mode
These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1 = 0 and bit CEN1 = 0 in the DAC_CR register). If EN1 = 1 or CEN1 = 1 the write operation is ignored.
They can be set and cleared by software to select the DAC channel1 mode:
DAC channel1 in Normal mode
DAC channel1 in sample &amp; hold mode
Note: This register can be modified only when EN1 = 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
              <enumeratedValue>
                <name>B_0x0</name>
                <description>DAC channel1 is connected to external pin with Buffer enabled</description>
                <value>0x0</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x1</name>
                <description>DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled</description>
                <value>0x1</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x2</name>
                <description>DAC channel1 is connected to external pin with Buffer disabled</description>
                <value>0x2</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x3</name>
                <description>DAC channel1 is connected to on chip peripherals with Buffer disabled</description>
                <value>0x3</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x4</name>
                <description>DAC channel1 is connected to external pin with Buffer enabled</description>
                <value>0x4</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x5</name>
                <description>DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled</description>
                <value>0x5</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x6</name>
                <description>DAC channel1 is connected to external pin and to on chip peripherals with Buffer disabled</description>
                <value>0x6</value>
              </enumeratedValue>
              <enumeratedValue>
                <name>B_0x7</name>
                <description>DAC channel1 is connected to on chip peripherals with Buffer disabled</description>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
              </field>
              <field>
                <name>DMADOUBLE1</name>
                <description>DAC channel1 DMA double data mode
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA Normal mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA Double data mode selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINFORMAT1</name>
                <description>Enable signed format for DAC channel1
This bit is set and cleared by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input data is in unsigned format </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input data is in signed format (2’s complement). The MSB bit represents the sign.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HFSEL0</name>
                <description>High frequency interface mode selection</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High frequency interface mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High frequency interface mode compatible to AHB&gt;80 MHz enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High frequency interface mode compatible to AHB&gt;160 MHz enabled</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HFSEL1</name>
                <description>High frequency interface mode selection</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High frequency interface mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High frequency interface mode compatible to AHB&gt;80 MHz enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High frequency interface mode compatible to AHB&gt;160 MHz enabled</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>DAC channel2 mode
These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2 = 0 and bit CEN2 = 0 in the DAC_CR register). If EN2 = 1 or CEN2 = 1 the write operation is ignored.
They can be set and cleared by software to select the DAC channel2 mode:
DAC channel2 in Normal mode
DAC channel2 in Sample and hold mode
Note: This register can be modified only when EN2 = 0.
Refer to  for the availability of DAC channel2.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC channel2 is connected to external pin with Buffer enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>DAC channel2 is connected to external pin with buffer disabled</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>DAC channel2 is connected to external pin with Buffer enabled</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>DAC channel2 is connected to external pin with Buffer disabled</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMADOUBLE2</name>
                <description>DAC channel2 DMA double data mode
This bit is set and cleared by software.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA Normal mode selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA Double data mode selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SINFORMAT2</name>
                <description>Enable signed format for DAC channel2
This bit is set and cleared by software.
Note: This bit is available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input data is in unsigned format </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Input data is in signed format (2’s complement). The MSB bit represents the sign.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SHSR1</name>
            <displayName>DAC_SHSR1</displayName>
            <description>DAC channel1 sample and hold sample time register	</description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSAMPLE1</name>
                <description>DAC channel1 sample time (only valid in Sample and hold mode)
These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1 = 1, the write operation is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SHSR2</name>
            <displayName>DAC_SHSR2</displayName>
            <description>DAC channel2 sample and hold sample time register 	</description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSAMPLE2</name>
                <description>DAC channel2 sample time (only valid in Sample and hold mode)
These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2 = 1, the write operation is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SHHR</name>
            <displayName>DAC_SHHR</displayName>
            <description>DAC sample and hold time register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00010001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THOLD1</name>
                <description>DAC channel1 hold time (only valid in Sample and hold mode)
Hold time = (THOLD[9:0]) x LSI/LSE clock period
Note: This register can be modified only when EN1 = 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THOLD2</name>
                <description>DAC channel2 hold time (only valid in Sample and hold mode).
Hold time = (THOLD[9:0]) x LSI/LSE clock period
Note: This register can be modified only when EN2 = 0.
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_SHRR</name>
            <displayName>DAC_SHRR</displayName>
            <description>DAC sample and hold refresh time register </description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00010001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TREFRESH1</name>
                <description>DAC channel1 refresh time (only valid in Sample and hold mode)
Refresh time = (TREFRESH[7:0]) x LSI/LSE clock period
Note: This register can be modified only when EN1 = 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TREFRESH2</name>
                <description>DAC channel2 refresh time (only valid in Sample and hold mode)
Refresh time = (TREFRESH[7:0]) x LSI/LSE clock period
Note: This register can be modified only when EN2 = 0.
These bits are available only on dual-channel DACs. Refer to implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>EXTI</name>
        <description>Extended interrupt/event controller</description>
        <groupName>EXTI</groupName>
		<baseAddress>0x44022000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>EXTI0</name>
          <description>EXTI Line0 interrupt</description>
          <value>11</value>
        </interrupt>
		<interrupt>
          <name>EXTI1</name>
          <description>EXTI Line1 interrupt</description>
          <value>12</value>
        </interrupt>
		<interrupt>
          <name>EXTI2</name>
          <description>EXTI Line2 interrupt</description>
          <value>13</value>
        </interrupt>		
		<interrupt>
          <name>EXTI3</name>
          <description>EXTI Line3 interrupt</description>
          <value>14</value>
        </interrupt>
		<interrupt>
          <name>EXTI4</name>
          <description>EXTI Line4 interrupt</description>
          <value>15</value>
        </interrupt>
		<interrupt>
          <name>EXTI5</name>
          <description>EXTI Line5 interrupt</description>
          <value>16</value>
        </interrupt>
		<interrupt>
          <name>EXTI6</name>
          <description>EXTI Line6 interrupt</description>
          <value>17</value>
        </interrupt>
		<interrupt>
          <name>EXTI7</name>
          <description>EXTI Line7 interrupt</description>
          <value>18</value>
        </interrupt>
		<interrupt>
          <name>EXTI8</name>
          <description>EXTI Line8 interrupt</description>
          <value>19</value>
        </interrupt>
		<interrupt>
          <name>EXTI9</name>
          <description>EXTI Line9 interrupt</description>
          <value>20</value>
        </interrupt>
		<interrupt>
          <name>EXTI10</name>
          <description>EXTI Line10 interrupt</description>
          <value>21</value>
        </interrupt>
		<interrupt>
          <name>EXTI11</name>
          <description>EXTI Line11 interrupt</description>
          <value>22</value>
        </interrupt>
		<interrupt>
          <name>EXTI12</name>
          <description>EXTI Line12 interrupt</description>
          <value>23</value>
        </interrupt>
		<interrupt>
          <name>EXTI13</name>
          <description>EXTI Line13 interrupt</description>
          <value>24</value>
        </interrupt>
		<interrupt>
          <name>EXTI14</name>
          <description>EXTI Line14 interrupt</description>
          <value>25</value>
        </interrupt>
		<interrupt>
          <name>EXTI15</name>
          <description>EXTI Line15 interrupt</description>
          <value>26</value>
        </interrupt>
        <registers>
          <register>
            <name>EXTI_RTSR1</name>
            <displayName>EXTI_RTSR1</displayName>
            <description>EXTI rising trigger selection register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RT0</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT1</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT2</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT3</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT4</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT5</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT6</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT7</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT8</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT9</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT10</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT11</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT12</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT13</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT14</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT15</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT16</name>
                <description>Rising trigger event configuration bit of configurable event input x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FTSR1</name>
            <displayName>EXTI_FTSR1</displayName>
            <description>EXTI falling trigger selection register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FT0</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT1</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT2</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT3</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT4</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT5</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT6</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT7</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT8</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT9</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT10</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT11</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT12</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT13</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT14</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT15</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT16</name>
                <description>Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_SWIER1</name>
            <displayName>EXTI_SWIER1</displayName>
            <description>EXTI software interrupt event register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SWI0</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI1</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI2</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI3</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI4</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI5</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI6</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI7</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI8</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI9</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI10</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI11</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI12</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI13</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI14</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI15</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI16</name>
                <description>Software interrupt on event x (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_RPR1</name>
            <displayName>EXTI_RPR1</displayName>
            <description>EXTI rising edge pending register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RPIF0</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF1</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF2</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF3</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF4</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF5</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF6</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF7</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF8</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF9</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF10</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF11</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF12</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF13</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF14</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF15</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF16</name>
                <description>configurable event inputs x rising edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FPR1</name>
            <displayName>EXTI_FPR1</displayName>
            <description>EXTI falling edge pending register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FPIF0</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF1</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF2</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF3</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF4</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF5</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF6</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF7</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF8</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF9</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF10</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF11</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF12</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF13</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF14</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF15</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF16</name>
                <description>configurable event inputs x falling edge pending bit (x = 16 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_PRIVCFGR1</name>
            <displayName>EXTI_PRIVCFGR1</displayName>
            <description>EXTI privilege configuration register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV0</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV1</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV2</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV3</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV4</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV5</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV6</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV7</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV8</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV9</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV10</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV11</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV12</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV13</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV14</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV15</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV16</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV17</name>
                <description>Privilege enable on event input x (x = 17 to 0)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV19</name>
                <description>Privilege enable on event input 19</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV21</name>
                <description>Privilege enable on event input x (x = 22 to 21)</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV22</name>
                <description>Privilege enable on event input x (x = 22 to 21)</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV24</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV25</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV26</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV27</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV28</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV29</name>
                <description>Privilege enable on event input x (x = 29 to 24)</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_RTSR2</name>
            <displayName>EXTI_RTSR2</displayName>
            <description>EXTI rising trigger selection register 2 </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RT50</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RT53</name>
                <description>Rising trigger event configuration bit of configurable event input x
When EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rising trigger disabled (for event and interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising trigger enabled (for event and interrupt) for input line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FTSR2</name>
            <displayName>EXTI_FTSR2</displayName>
            <description>EXTI falling trigger selection register 2 </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FT50</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FT53</name>
                <description>Falling trigger event configuration bit of configurable event input x
When EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Falling trigger disabled (for event and Interrupt) for input line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling trigger enabled (for event and Interrupt) for input line.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_SWIER2</name>
            <displayName>EXTI_SWIER2</displayName>
            <description>EXTI software interrupt event register 2 </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SWI50</name>
                <description>Software interrupt on event x
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWI53</name>
                <description>Software interrupt on event x
When EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.
A software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Writing 0 has no effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Writing 1 triggers a rising edge event on event x. This bit is auto cleared by hardware.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_RPR2</name>
            <displayName>EXTI_RPR2</displayName>
            <description>EXTI rising edge pending register 2 </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RPIF50</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RPIF53</name>
                <description>configurable event inputs x rising edge pending bit
When EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.
This bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No rising edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rising edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_FPR2</name>
            <displayName>EXTI_FPR2</displayName>
            <description>EXTI falling edge pending register 2 </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FPIF50</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FPIF53</name>
                <description>configurable event inputs x falling edge pending bit
When EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.
This bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No falling edge trigger request occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge trigger request occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_PRIVCFGR2</name>
            <displayName>EXTI_PRIVCFGR2</displayName>
            <description>EXTI privilege configuration register 2 </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIV37</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV38</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV39</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV40</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV41</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV42</name>
                <description>Privilege enable on event input x (x = 42 to 37)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV47</name>
                <description>Privilege enable on event input x</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV49</name>
                <description>Privilege enable on event input x (x = 50 to 49)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV50</name>
                <description>Privilege enable on event input x (x = 50 to 49)</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIV53</name>
                <description>Privilege enable on event input x</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Event privilege disabled (unprivileged)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Event privilege enabled (privileged)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR1</name>
            <displayName>EXTI_EXTICR1</displayName>
            <description>EXTI external interrupt selection register </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI0</name>
                <description>EXTI0 GPIO port selection
These bits are written by software to select the source input for EXTI0 external interrupt.
When EXTI_PRIVCFGR.PRIV0 is disabled, EXTI0 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV0 is enabled, EXTI0 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[0] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[0] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[0] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PH[0] pin </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI1</name>
                <description>EXTI1 GPIO port selection
These bits are written by software to select the source input for EXTI1 external interrupt.
When EXTI_PRIVCFGR.PRIV1 is disabled, EXTI1 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV1 is enabled, EXTI1 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[1] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[1] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[1] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PH[1] pin </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI2</name>
                <description>EXTI2 GPIO port selection
These bits are written by software to select the source input for EXTI2 external interrupt.
When EXTI_PRIVCFGR.PRIV2 is disabled, EXTI2 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV2 is enabled, EXTI2 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[2] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[2] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[2] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PD[2] pin </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI3</name>
                <description>EXTI3 GPIO port selectio
These bits are written by software to select the source input for EXTI3 external interrupt.
When EXTI_PRIVCFGR.PRIV3 is disabled, EXTI3 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV3 is enabled, EXTI3 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[3] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[3] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[3] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR2</name>
            <displayName>EXTI_EXTICR2</displayName>
            <description>EXTI external interrupt selection register </description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI4</name>
                <description>EXTI4 GPIO port selection
These bits are written by software to select the source input for EXTI4 external interrupt.
When EXTI_PRIVCFGR.PRIV4 is disabled, EXTI4 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV4 is enabled, EXTI4 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[4] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[4] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[4] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI5</name>
                <description>EXTI5 GPIO port selection
These bits are written by software to select the source input for EXTI5 external interrupt.
When EXTI_PRIVCFGR.PRIV5 is disabled, EXTI5 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV5 is enabled, EXTI5 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[5] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[5] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[5] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI6</name>
                <description>EXTI6 GPIO port selection
These bits are written by software to select the source input for EXTI6 external interrupt.
When EXTI_PRIVCFGR.PRIV6 is disabled, EXTI6 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV6 is enabled, EXTI6 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[6] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[6] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[6] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI7</name>
                <description>EXTI7 GPIO port selection
These bits are written by software to select the source input for EXTI7 external interrupt.
When EXTI_PRIVCFGR.PRIV7 is disabled, EXTI7 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV7 is enabled, EXTI7 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[7] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[7] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[7] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR3</name>
            <displayName>EXTI_EXTICR3</displayName>
            <description>EXTI external interrupt selection register </description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI8</name>
                <description>EXTI8 GPIO port selection
These bits are written by software to select the source input for EXTIm external interrupt.
When EXTI_PRIVCFGR.PRIV8 is disabled, EXTI8 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV8 is enabled, EXTI8 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[8] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[8] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[8] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI9</name>
                <description>EXTI9 GPIO port selection
These bits are written by software to select the source input for EXTI9 external interrupt.
When EXTI_PRIVCFGR.PRIV9 is disabled, EXTI9 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV9 is enabled, EXTI9 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[9] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[9] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI10</name>
                <description>EXTI10 GPIO port selection
These bits are written by software to select the source input for EXTI10 external interrupt.
When EXTI_PRIVCFGR.PRIV10 is disabled, EXTI10 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV10 is enabled, EXTI10 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[10] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[10] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[10] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI11</name>
                <description>EXTI11 GPIO port selection
These bits are written by software to select the source input for EXTI11 external interrupt.
When EXTI_PRIVCFGR.PRIV11 is disabled, EXTI11 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV11 is enabled, EXTI11 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[11] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[11] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EXTICR4</name>
            <displayName>EXTI_EXTICR4</displayName>
            <description>EXTI external interrupt selection register </description>
            <addressOffset>0x6c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EXTI12</name>
                <description>EXTI12 GPIO port selection
These bits are written by software to select the source input for EXTI12 external interrupt.
When EXTI_PRIVCFGR.PRIV12 is disabled, EXTI12 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV12 is enabled, EXTI12 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[12] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[12] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[12] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI13</name>
                <description>EXTI13 GPIO port selection
These bits are written by software to select the source input for EXTI13 external interrupt.
When EXTI_PRIVCFGR.PRIV13 is disabled, EXTI13 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV13 is enabled, EXTI13 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[13] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[13] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[13] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI14</name>
                <description>EXTI14 GPIO port selection
These bits are written by software to select the source input for EXTI14 external interrupt.
When EXTI_PRIVCFGR.PRIV14 is disabled, EXTI14 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV14 is enabled, EXTI14 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[14] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[14] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[14] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTI15</name>
                <description>EXTI15 GPIO port selection
These bits are written by software to select the source input for EXTI15 external interrupt.
When EXTI_PRIVCFGR.PRIV15 is disabled, EXTI15 can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIV15 is enabled, EXTI15 can only be accessed with privileged access. Unprivileged write to this bit is discarded.
Others: reserved</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PA[15] pin </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PB[15] pin </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PC[15] pin </description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_IMR1</name>
            <displayName>EXTI_IMR1</displayName>
            <description>EXTI CPU wakeup with interrupt mask register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFE0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IM0</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM1</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM2</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM3</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM4</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM5</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM6</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM7</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM8</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM9</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM10</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM11</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM12</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM13</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM14</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM15</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM16</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM17</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM19</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM21</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 22 to 21)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM22</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 22 to 21)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM24</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM25</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM26</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM27</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM28</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM29</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EMR1</name>
            <displayName>EXTI_EMR1</displayName>
            <description>EXTI CPU wakeup with event mask register </description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFE0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EM0</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM1</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM2</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM3</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM4</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM5</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM6</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM7</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM8</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM9</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM10</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM11</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM12</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM13</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM14</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM15</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM16</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM17</name>
                <description>CPU wakeup with event generation mask on event input x (x = 17 to 0)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM19</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM21</name>
                <description>CPU wakeup with event generation mask on event input x (x = 22 to 21)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM22</name>
                <description>CPU wakeup with event generation mask on event input x (x = 22 to 21)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM24</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM25</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM26</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM27</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM28</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM29</name>
                <description>CPU wakeup with event generation mask on event input x (x = 29 to 24)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_IMR2</name>
            <displayName>EXTI_IMR2</displayName>
            <description>EXTI CPU wakeup with interrupt mask register 2 </description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00DBBFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IM37</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM38</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM39</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM40</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM41</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM42</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM47</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM49</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 50 to 49)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM50</name>
                <description>CPU wakeup with interrupt mask on event input x  (x = 50 to 49)
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IM53</name>
                <description>CPU wakeup with interrupt mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with interrupt request from input event x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with interrupt request from input event x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>EXTI_EMR2</name>
            <displayName>EXTI_EMR2</displayName>
            <description>EXTI CPU wakeup with event mask register 2 </description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00DBBFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EM37</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM38</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM39</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM40</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM41</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM42</name>
                <description>CPU wakeup with event generation mask on event input x (x = 42 to 37)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM47</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM49</name>
                <description>CPU wakeup with event generation mask on event input x (x = 50 to 49)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM50</name>
                <description>CPU wakeup with event generation mask on event input x (x = 50 to 49)
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EM53</name>
                <description>CPU wakeup with event generation mask on event input x
When EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.
When EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup with event generation from Line x is masked.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup with event generation from Line x is unmasked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	
	<peripheral>
      <name>FDCAN1</name>
	  <description>Controller area network</description>
	  <groupName>FDCAN</groupName>
      <baseAddress>0x4000A400</baseAddress>
	  <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
	  <interrupt>
        <name>FDCAN1_IT0</name>
        <description>FDCAN1 interrupt 0</description>
        <value>39</value>
      </interrupt>
	  <interrupt>
        <name>FDCAN1_IT1</name>
        <description>FDCAN1 interrupt 1</description>
        <value>40</value>
      </interrupt>
	  <registers>
          <register>
            <name>FDCAN_CREL</name>
            <displayName>FDCAN_CREL</displayName>
            <description>FDCAN core release register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x32141218</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAY</name>
                <description>18</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MON</name>
                <description>12</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>YEAR</name>
                <description>4</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SUBSTEP</name>
                <description>1</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STEP</name>
                <description>2</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REL</name>
                <description>3</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_ENDN</name>
            <displayName>FDCAN_ENDN</displayName>
            <description>FDCAN endian register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x87654321</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ETV</name>
                <description>Endianness test value
The endianness test value is 0x8765 4321.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_DBTP</name>
            <displayName>FDCAN_DBTP</displayName>
            <description>FDCAN data bit timing and prescaler register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000A33</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSJW</name>
                <description>Synchronization jump width
Must always be smaller than DTSEG2, valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1: tSJW = (DSJW + 1) x tq.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DTSEG2</name>
                <description>Data time segment after sample point
Valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS2 = (DTSEG2 + 1) x tq.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DTSEG1</name>
                <description>Data time segment before sample point
Valid values are 0 to 31. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS1 = (DTSEG1 + 1) x tq.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBRP</name>
                <description>Data bit rate prescaler
The value by which the oscillator frequency is divided to generate the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are 0 to 31. The hardware interpreters this value as the value programmed plus 1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TDC</name>
                <description>Transceiver delay compensation</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transceiver delay compensation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transceiver delay compensation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TEST</name>
            <displayName>FDCAN_TEST</displayName>
            <description>FDCAN test register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LBCK</name>
                <description>Loop back mode</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset value, Loop Back mode is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Loop Back mode is enabled (see Power down (Sleep mode))</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TX</name>
                <description>Control of transmit pin</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset value, FDCANx_TX TX is controlled by the CAN core, updated at the end of the CAN bit time</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sample point can be monitored at pin FDCANx_TX</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Dominant (0) level at pin FDCANx_TX</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Recessive (1) at pin FDCANx_TX</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RX</name>
                <description>Receive pin
Monitors the actual value of pin FDCANx_RX</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The CAN bus is dominant (FDCANx_RX = 0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The CAN bus is recessive (FDCANx_RX = 1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RWD</name>
            <displayName>FDCAN_RWD</displayName>
            <description>FDCAN RAM watchdog register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDC</name>
                <description>Watchdog configuration
Start value of the message RAM watchdog counter. With the reset value of 00, the counter is disabled.
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of FDCAN_CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDV</name>
                <description>Watchdog value
Actual message RAM watchdog counter value.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_CCCR</name>
            <displayName>FDCAN_CCCR</displayName>
            <description>FDCAN CC control register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INIT</name>
                <description>Initialization</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Initialization started</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCE</name>
                <description>Configuration change enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The CPU has no write access to the protected configuration registers.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The CPU has write access to the protected configuration registers (while CCCR.INIT = 1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ASM</name>
                <description>ASM restricted operation mode
The restricted operation mode is intended for applications that adapt themselves to different CAN bit rates. The application tests different bit rates and leaves the Restricted operation Mode after it has received a valid frame. In the optional Restricted operation Mode the node is able to transmit and receive data and remote frames and it gives acknowledge to valid frames, but it does not send active error frames or overload frames. In case of an error condition or overload condition, it does not send dominant bits, instead it waits for the occurrence of bus idle condition to resynchronize itself to the CAN communication. The error counters are not incremented. Bit ASM can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the software at any time.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal CAN operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Restricted operation Mode active</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSA</name>
                <description>Clock stop acknowledge</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No clock stop acknowledged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FDCAN may be set in power down by stopping APB clock and kernel clock.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSR</name>
                <description>Clock stop request</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No clock stop requested</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clock stop requested. When clock stop is requested, first INIT and then CSA is set after all pending transfer requests have been completed and the CAN bus reached idle.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MON</name>
                <description>Bus monitoring mode
Bit MON can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the Host at any time.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bus monitoring mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bus monitoring mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAR</name>
                <description>Disable automatic retransmission</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Automatic retransmission of messages not transmitted successfully enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Automatic retransmission disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEST</name>
                <description>Test mode enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal operation, register TEST holds reset values</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Test Mode, write access to register TEST enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FDOE</name>
                <description>FD operation enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FD operation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FD operation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BRSE</name>
                <description>FDCAN bit rate switching</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bit rate switching for transmissions disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bit rate switching for transmissions enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PXHD</name>
                <description>Protocol exception handling disable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Protocol exception handling enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Protocol exception handling disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EFBI</name>
                <description>Edge filtering during bus integration</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Edge filtering disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXP</name>
                <description>If this bit is set, the FDCAN pauses for two CAN bit times before starting the next transmission after successfully transmitting a frame.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NISO</name>
                <description>Non ISO operation
If this bit is set, the FDCAN uses the CAN FD frame format as specified by the Bosch CAN FD Specification V1.0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CAN FD frame format according to ISO11898-1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CAN FD frame format according to Bosch CAN FD Specification V1.0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_NBTP</name>
            <displayName>FDCAN_NBTP</displayName>
            <description>FDCAN nominal bit timing and prescaler register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x06000A03</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NTSEG2</name>
                <description>Nominal time segment after sample point
Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NTSEG1</name>
                <description>Nominal time segment before sample point
Valid values are 0 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NBRP</name>
                <description>Bit rate prescaler
Value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values are 0 to 511. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NSJW</name>
                <description>Nominal (re)synchronization jump width
Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that the used value is the one programmed incremented by one.
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TSCC</name>
            <displayName>FDCAN_TSCC</displayName>
            <description>FDCAN timestamp counter configuration register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSS</name>
                <description>Timestamp select
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timestamp counter value always 0x0000</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timestamp counter value incremented according to TCP</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>External timestamp counter from TIM3 value (tim3_cnt[0:15])</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Same as 00.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCP</name>
                <description>Timestamp counter prescaler
Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1 … 16].
The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
In CAN FD mode the internal timestamp counter TCP does not provide a constant time base due to the different CAN bit times between arbitration phase and data phase. Thus CAN FD requires an external counter for timestamp generation (TSS = 10).
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TSCV</name>
            <displayName>FDCAN_TSCV</displayName>
            <description>FDCAN timestamp counter value register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSC</name>
                <description>Timestamp counter
The internal/external timestamp counter value is captured on start of frame (both Rx and Tx). When TSCC[TSS] = 01, the timestamp counter is incremented in multiples of CAN bit times [1 … 16] depending on the configuration of TSCC[TCP]. A wrap around sets interrupt flag IR[TSW]. Write access resets the counter to 0.
When TSCC.TSS = 10, TSC reflects the external timestamp counter value. A write access has no impact.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TOCC</name>
            <displayName>FDCAN_TOCC</displayName>
            <description>FDCAN timeout counter configuration register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFF0000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ETOC</name>
                <description>Timeout counter enable
This is a protected write (P) bit, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timeout counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOS</name>
                <description>Timeout select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC[TOP] and continues down-counting. When the timeout counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC[TOP]. Down-counting is started when the first FIFO element is stored.
These are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Continuous operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout controlled by Tx event FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Timeout controlled by Rx FIFO 0</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Timeout controlled by Rx FIFO 1</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOP</name>
                <description>Timeout period
Start value of the timeout counter (down-counter). Configures the timeout period.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TOCV</name>
            <displayName>FDCAN_TOCV</displayName>
            <description>FDCAN timeout counter value register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TOC</name>
                <description>Timeout counter
The timeout counter is decremented in multiples of CAN bit times [1 … 16] depending on the configuration of TSCC.TCP. When decremented to 0, interrupt flag IR.TOO is set and the timeout counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_ECR</name>
            <displayName>FDCAN_ECR</displayName>
            <description>FDCAN error counter register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TEC</name>
                <description>Transmit error counter
Actual state of the transmit error counter, values between 0 and 255.
When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REC</name>
                <description>Receive error counter
Actual state of the receive error counter, values between 0 and 127.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RP</name>
                <description>Receive error passive</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The receive error counter is below the error passive level of 128.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The receive error counter has reached the error passive level of 128.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CEL</name>
                <description>CAN error logging
The counter is incremented each time when a CAN protocol error causes the transmit error counter or the receive error counter to be incremented. It is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR[ELO].
Access type is RX: reset on read.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_PSR</name>
            <displayName>FDCAN_PSR</displayName>
            <description>FDCAN protocol status register </description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000707</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LEC</name>
                <description>Last error code
The LEC indicates the type of the last error to occur on the CAN bus. This field is cleared to 0 when a message has been transferred (reception or transmission) without error.
Access type is RS: set on read.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Error: No error occurred since LEC has been reset by successful reception or transmission.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Form Error: A fixed format part of a received frame has the wrong format.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AckError: The message transmitted by the FDCAN was not acknowledged by another node.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Bit1Error: During the transmission of a message (with the exception of the arbitration field), the device wanted to send a recessive level (bit of logical value 1), but the monitored bus value was dominant.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value 0), but the monitored bus value was recessive. During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at dominant or continuously disturbed).</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>NoChange: Any read access to the Protocol status register re-initializes the LEC to ‘7’. When the LEC shows the value ‘7’, no CAN bus event was detected since the last CPU read access to the Protocol status register.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACT</name>
                <description>Activity
Monitors the module’s CAN communication state.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Synchronizing: node is synchronizing on CAN communication.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle: node is neither receiver nor transmitter.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Receiver: node is operating as receiver.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Transmitter: node is operating as transmitter.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP</name>
                <description>Error passive</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The FDCAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The FDCAN is in the Error_Passive state.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EW</name>
                <description>Warning Sstatus</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Both error counters are below the Error_Warning limit of 96.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>At least one of error counter has reached the Error_Warning limit of 96.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BO</name>
                <description>Bus_Off status</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The FDCAN is not Bus_Off.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The FDCAN is in Bus_Off state.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DLEC</name>
                <description>Data last error code
Type of last error that occurred in the data phase of a FDCAN format frame with its BRS flag set. Coding is the same as for LEC. This field is cleared to 0 when a FDCAN format frame with its BRS flag set has been transferred (reception or transmission) without error.
Access type is RS: set on read.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESI</name>
                <description>ESI flag of last received FDCAN message
This bit is set together with REDL, independent of acceptance filtering.
Access type is RX: reset on read.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Last received FDCAN message did not have its ESI flag set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Last received FDCAN message had its ESI flag set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RBRS</name>
                <description>BRS flag of last received FDCAN message
This bit is set together with REDL, independent of acceptance filtering.
Access type is RX: reset on read.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Last received FDCAN message did not have its BRS flag set.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Last received FDCAN message had its BRS flag set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REDL</name>
                <description>Received FDCAN message
This bit is set independent of acceptance filtering.
Access type is RX: reset on read.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Since this bit was reset by the CPU, no FDCAN message has been received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Message in FDCAN format with EDL flag set has been received.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PXE</name>
                <description>Protocol exception event</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No protocol exception event occurred since last read access</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Protocol exception event occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TDCV</name>
                <description>Transmitter delay compensation value
Position of the secondary sample point, defined by the sum of the measured delay from FDCAN_TX to FDCAN_RX and TDCR.TDCO. The SSP position is, in the data phase, the number of minimum time quanta (mtq) between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TDCR</name>
            <displayName>FDCAN_TDCR</displayName>
            <description>FDCAN transmitter delay compensation register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDCF</name>
                <description>Transmitter delay compensation filter window length
Defines the minimum value for the SSP position, dominant edges on FDCAN_RX that would result in an earlier SSP position are ignored for transmitter delay measurements.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TDCO</name>
                <description>Transmitter delay compensation offset
Offset value defining the distance between the measured delay from FDCAN_TX to FDCAN_RX and the secondary sample point. Valid values are 0 to 127 mtq.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_IR</name>
            <displayName>FDCAN_IR</displayName>
            <description>FDCAN interrupt register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RF0N</name>
                <description>Rx FIFO 0 new message</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No new message written to Rx FIFO 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>New message written to Rx FIFO 0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF0F</name>
                <description>Rx FIFO 0 full</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx FIFO 0 not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 0 full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF0L</name>
                <description>Rx FIFO 0 message lost</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Rx FIFO 0 message lost</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 0 message lost</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1N</name>
                <description>Rx FIFO 1 new message</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No new message written to Rx FIFO 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>New message written to Rx FIFO 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1F</name>
                <description>Rx FIFO 1 full</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx FIFO 1 not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 1 full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1L</name>
                <description>Rx FIFO 1 message lost</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Rx FIFO 1 message lost</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 1 message lost</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HPM</name>
                <description>High-priority message</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No high-priority message received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-priority message received</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission completed</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmission completed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission completed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCF</name>
                <description>Transmission cancellation finished</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmission cancellation finished</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission cancellation finished</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TFE</name>
                <description>Tx FIFO empty</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx FIFO non-empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx FIFO empty</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFN</name>
                <description>Tx event FIFO New Entry</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx event FIFO unchanged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx handler wrote Tx event FIFO element.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFF</name>
                <description>Tx event FIFO full</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx event FIFO Not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx event FIFO full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFL</name>
                <description>Tx event FIFO element lost</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Tx event FIFO element lost</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx event FIFO element lost</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSW</name>
                <description>Timestamp wraparound</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No timestamp counter wrap-around</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timestamp counter wrapped around</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MRAF</name>
                <description>Message RAM access failure
The flag is set when the Rx handler:
has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx handler starts processing of the following message.
was unable to write a message to the message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated. The partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the FDCAN is switched into Restricted operation Mode (see mode). To leave Restricted operation Mode, the Host CPU has to reset CCCR.ASM.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Message RAM access failure occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Message RAM access failure occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOO</name>
                <description>Timeout occurred</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No timeout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ELO</name>
                <description>Error logging overflow</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CAN error logging counter did not overflow.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overflow of CAN error logging counter occurred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP</name>
                <description>Error passive</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error_Passive status unchanged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error_Passive status changed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EW</name>
                <description>Warning status</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error_Warning status unchanged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error_Warning status changed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BO</name>
                <description>Bus_Off status</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bus_Off status unchanged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bus_Off status changed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDI</name>
                <description>Watchdog interrupt</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No message RAM watchdog event occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Message RAM watchdog event due to missing READY</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEA</name>
                <description>Protocol error in arbitration phase (nominal bit time is used)</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No protocol error in arbitration phase</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Protocol error in arbitration phase detected (PSR.LEC different from 0,7)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PED</name>
                <description>Protocol error in data phase (data bit time is used)</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No protocol error in data phase</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Protocol error in data phase detected (PSR.DLEC different from 0,7)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARA</name>
                <description>Access to reserved address</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No access to reserved address occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Access to reserved address occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_IE</name>
            <displayName>FDCAN_IE</displayName>
            <description>FDCAN interrupt enable register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RF0NE</name>
                <description>Rx FIFO 0 new message interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF0FE</name>
                <description>Rx FIFO 0 full interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF0LE</name>
                <description>Rx FIFO 0 message lost interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1NE</name>
                <description>Rx FIFO 1 new message interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1FE</name>
                <description>Rx FIFO 1 full interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1LE</name>
                <description>Rx FIFO 1 message lost interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HPME</name>
                <description>High-priority message interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCE</name>
                <description>Transmission completed interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCFE</name>
                <description>Transmission cancellation finished interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TFEE</name>
                <description>Tx FIFO empty interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFNE</name>
                <description>Tx event FIFO new entry interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFFE</name>
                <description>Tx event FIFO full interrupt enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFLE</name>
                <description>Tx event FIFO element lost interrupt enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSWE</name>
                <description>Timestamp wraparound interrupt enable</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MRAFE</name>
                <description>Message RAM access failure interrupt enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TOOE</name>
                <description>Timeout occurred interrupt enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ELOE</name>
                <description>Error logging overflow interrupt enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EPE</name>
                <description>Error passive interrupt enable</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EWE</name>
                <description>Warning status interrupt enable</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BOE</name>
                <description>Bus_Off status</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDIE</name>
                <description>Watchdog interrupt enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEAE</name>
                <description>Protocol error in arbitration phase enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PEDE</name>
                <description>Protocol error in data phase enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ARAE</name>
                <description>Access to reserved address enable</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_ILS</name>
            <displayName>FDCAN_ILS</displayName>
            <description>FDCAN interrupt line select register </description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RxFIFO0</name>
                <description>RX FIFO bit grouping the following interruption
RF0LL: Rx FIFO 0 message lost interrupt line
RF0FL: Rx FIFO 0 full interrupt line
RF0NL: Rx FIFO 0 new message interrupt line</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RxFIFO1</name>
                <description>RX FIFO bit grouping the following interruption
RF1LL: Rx FIFO 1 message lost interrupt line
RF1FL: Rx FIFO 1 full Interrupt line
RF1NL: Rx FIFO 1 new message interrupt line</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SMSG</name>
                <description>Status message bit grouping the following interruption
TCFL: Transmission cancellation finished interrupt line
TCL: Transmission completed interrupt line
HPML: High-priority message interrupt line</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TFERR</name>
                <description>Tx FIFO ERROR grouping the following interruption
TEFLL: Tx event FIFO element lost interrupt line
TEFFL: Tx event FIFO full interrupt line
TEFNL: Tx event FIFO new entry interrupt line
TFEL: Tx FIFO empty interrupt line</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MISC</name>
                <description>Interrupt regrouping the following interruption
TOOL: Timeout occurred interrupt line
MRAFL: Message RAM access failure interrupt line
TSWL: Timestamp wraparound interrupt line</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BERR</name>
                <description>Bit and line error grouping the following interruption
EPL Error passive interrupt line
ELOL: Error logging overflow interrupt line</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PERR</name>
                <description>Protocol error grouping the following interruption
ARAL: Access to reserved address line
PEDL: Protocol error in data phase line
PEAL: Protocol error in arbitration phase line
WDIL: Watchdog interrupt line
BOL: Bus_Off status
EWL: Warning status interrupt line</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_ILE</name>
            <displayName>FDCAN_ILE</displayName>
            <description>FDCAN interrupt line enable register </description>
            <addressOffset>0x5c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EINT0</name>
                <description>Enable interrupt line 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt line fdcan_intr1_it disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt line fdcan_intr1_it enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EINT1</name>
                <description>Enable interrupt line 1</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt line fdcan_intr0_it disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Interrupt line fdcan_intr0_it enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RXGFC</name>
            <displayName>FDCAN_RXGFC</displayName>
            <description>FDCAN global filter configuration register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RRFE</name>
                <description>Reject remote frames extended
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Filter remote frames with 29-bit standard IDs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reject all remote frames with 29-bit standard IDs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RRFS</name>
                <description>Reject remote frames standard
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Filter remote frames with 11-bit standard IDs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reject all remote frames with 11-bit standard IDs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANFE</name>
                <description>Accept non-matching frames extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Accept in Rx FIFO 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Accept in Rx FIFO 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Reject</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reject</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANFS</name>
                <description>Accept Non-matching frames standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Accept in Rx FIFO 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Accept in Rx FIFO 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Reject</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Reject</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>F1OM</name>
                <description>FIFO 1 operation mode (overwrite or blocking)
This is a protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>F0OM</name>
                <description>FIFO 0 operation mode (overwrite or blocking)
This is protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LSS</name>
                <description>List size standard
&gt;28: Values greater than 28 are interpreted as 28.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No standard message ID filter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xa</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xa</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xb</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xb</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xc</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xc</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xd</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xd</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xe</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xe</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xf</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0xf</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x12</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x14</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x15</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x16</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x17</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x18</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x19</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1a</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x1a</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1b</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x1b</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1c</name>
                    <description>Number of standard message ID filter elements</description>
                    <value>0x1c</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSE</name>
                <description>List size extended
&gt;8: Values greater than 8 are interpreted as 8.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No extended message ID filter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Number of extended message ID filter elements</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_XIDAM</name>
            <displayName>FDCAN_XIDAM</displayName>
            <description>FDCAN extended ID and mask register </description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x1FFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EIDM</name>
                <description>Extended ID mask
For acceptance filtering of extended frames the Extended ID AND Mask is AND-ed with the Message ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to 1 the mask is not active.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>29</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_HPMS</name>
            <displayName>FDCAN_HPMS</displayName>
            <description>FDCAN high-priority message status register </description>
            <addressOffset>0x88</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BIDX</name>
                <description>Buffer index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MSI</name>
                <description>Message storage indicator</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No FIFO selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO overrun</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Message stored in FIFO 0</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Message stored in FIFO 1</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIDX</name>
                <description>Filter index
Index of matching filter element. Range is 0 to RXGFC[LSS] - 1 or RXGFC[LSE] - 1.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FLST</name>
                <description>Filter list
Indicates the filter list of the matching filter element.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Standard filter list</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Extended filter list</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RXF0S</name>
            <displayName>FDCAN_RXF0S</displayName>
            <description>FDCAN Rx FIFO 0 status register </description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>F0FL</name>
                <description>Rx FIFO 0 fill level
Number of elements stored in Rx FIFO 0, range 0 to 3.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F0GI</name>
                <description>Rx FIFO 0 get index
Rx FIFO 0 read index pointer, range 0 to 2.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F0PI</name>
                <description>Rx FIFO 0 put index
Rx FIFO 0 write index pointer, range 0 to 2.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F0F</name>
                <description>Rx FIFO 0 full</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx FIFO 0 not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 0 full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF0L</name>
                <description>Rx FIFO 0 message lost
This bit is a copy of interrupt flag IR[RF0L]. When IR[RF0L] is reset, this bit is also reset.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Rx FIFO 0 message lost</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size 0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RXF0A</name>
            <displayName>FDCAN_RXF0A</displayName>
            <description>CAN Rx FIFO 0 acknowledge register </description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>F0AI</name>
                <description>Rx FIFO 0 acknowledge index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI. This sets the Rx FIFO 0 get index RXF0S[F0GI] to F0AI + 1 and update the FIFO 0 fill level RXF0S[F0FL].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RXF1S</name>
            <displayName>FDCAN_RXF1S</displayName>
            <description>FDCAN Rx FIFO 1 status register </description>
            <addressOffset>0x98</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>F1FL</name>
                <description>Rx FIFO 1 fill level
Number of elements stored in Rx FIFO 1, range 0 to 3.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F1GI</name>
                <description>Rx FIFO 1 get index
Rx FIFO 1 read index pointer, range 0 to 2.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F1PI</name>
                <description>Rx FIFO 1 put index
Rx FIFO 1 write index pointer, range 0 to 2.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>F1F</name>
                <description>Rx FIFO 1 full</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx FIFO 1 not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 1 full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RF1L</name>
                <description>Rx FIFO 1 message lost
This bit is a copy of interrupt flag IR[RF1L]. When IR[RF1L] is reset, this bit is also reset.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Rx FIFO 1 message lost</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size 0</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_RXF1A</name>
            <displayName>FDCAN_RXF1A</displayName>
            <description>FDCAN Rx FIFO 1 acknowledge register </description>
            <addressOffset>0x9c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>F1AI</name>
                <description>Rx FIFO 1 acknowledge index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI. This sets the Rx FIFO 1 get index RXF1S[F1GI] to F1AI + 1 and update the FIFO 1 Fill Level RXF1S[F1FL].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBC</name>
            <displayName>FDCAN_TXBC</displayName>
            <description>FDCAN Tx buffer configuration register </description>
            <addressOffset>0xc0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TFQM</name>
                <description>Tx FIFO/queue mode
This is a protected write (P) bit, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx FIFO operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx queue operation.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXFQS</name>
            <displayName>FDCAN_TXFQS</displayName>
            <description>FDCAN Tx FIFO/queue status register </description>
            <addressOffset>0xc4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000003</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TFFL</name>
                <description>Tx FIFO free level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC[TFQM] = 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TFGI</name>
                <description>Tx FIFO get index
Tx FIFO read index pointer, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC.TFQM = 1)</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TFQPI</name>
                <description>Tx FIFO/queue put index
Tx FIFO/queue write index pointer, range 0 to 3</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TFQF</name>
                <description>Tx FIFO/queue full</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx FIFO/queue not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx FIFO/queue full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBRP</name>
            <displayName>FDCAN_TXBRP</displayName>
            <description>FDCAN Tx buffer request pending register </description>
            <addressOffset>0xc8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRP</name>
                <description>Transmission request pending
Each Tx buffer has its own transmission request pending bit. The bits are set via register TXBAR. The bits are reset after a requested transmission has completed or has been canceled via register TXBCR.
After a TXBRP bit has been set, a Tx scan is started to check for the pending Tx request with the highest priority (Tx buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested, this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically canceled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmission request pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission request pending </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBAR</name>
            <displayName>FDCAN_TXBAR</displayName>
            <description>FDCAN Tx buffer add request register </description>
            <addressOffset>0xcc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AR</name>
                <description>Add request
Each Tx buffer has its own add request bit. Writing a 1 sets the corresponding add request bit; writing a 0 has no impact. This enables the Host to set transmission requests for multiple Tx buffers with one write to TXBAR. When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmission request added</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission requested added.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBCR</name>
            <displayName>FDCAN_TXBCR</displayName>
            <description>FDCAN Tx buffer cancellation request register </description>
            <addressOffset>0xd0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CR</name>
                <description>Cancellation request
Each Tx buffer has its own cancellation request bit. Writing a 1 sets the corresponding CR bit; writing a 0 has no impact.
This enables the Host to set cancellation requests for multiple Tx buffers with one write to TXBCR. The bits remain set until the corresponding TXBRP bit is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No cancellation pending</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Cancellation pending</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBTO</name>
            <displayName>FDCAN_TXBTO</displayName>
            <description>FDCAN Tx buffer transmission occurred register </description>
            <addressOffset>0xd4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TO</name>
                <description>Transmission occurred.
Each Tx buffer has its own TO bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmission occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBCF</name>
            <displayName>FDCAN_TXBCF</displayName>
            <description>FDCAN Tx buffer cancellation finished register </description>
            <addressOffset>0xd8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CF</name>
                <description>Cancellation finished
Each Tx buffer has its own CF bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No transmit buffer cancellation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit buffer cancellation finished</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBTIE</name>
            <displayName>FDCAN_TXBTIE</displayName>
            <description>FDCAN Tx buffer transmission interrupt enable register	</description>
            <addressOffset>0xdc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIE</name>
                <description>Transmission interrupt enable
Each Tx buffer has its own TIE bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission interrupt enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXBCIE</name>
            <displayName>FDCAN_TXBCIE</displayName>
            <description>FDCAN Tx buffer cancellation finished interrupt enable register	</description>
            <addressOffset>0xe0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CFIE</name>
                <description>Cancellation finished interrupt enable.
Each Tx buffer has its own CFIE bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Cancellation finished interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Cancellation finished interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXEFS</name>
            <displayName>FDCAN_TXEFS</displayName>
            <description>FDCAN Tx event FIFO status register </description>
            <addressOffset>0xe4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EFFL</name>
                <description>Event FIFO fill level
Number of elements stored in Tx event FIFO, range 0 to 3.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EFGI</name>
                <description>Event FIFO get index
Tx event FIFO read index pointer, range 0 to 3.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EFPI</name>
                <description>Event FIFO put index
Tx event FIFO write index pointer, range 0 to 3.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EFF</name>
                <description>Event FIFO full</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx event FIFO not full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx event FIFO full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TEFL</name>
                <description>Tx event FIFO element lost
This bit is a copy of interrupt flag IR[TEFL]. When IR[TEFL] is reset, this bit is also reset.
0 No Tx event FIFO element lost
1 Tx event FIFO element lost, also set after write attempt to Tx event FIFO of size 0.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_TXEFA</name>
            <displayName>FDCAN_TXEFA</displayName>
            <description>FDCAN Tx event FIFO acknowledge register </description>
            <addressOffset>0xe8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EFAI</name>
                <description>Event FIFO acknowledge index
After the Host has read an element or a sequence of elements from the Tx event FIFO, it has to write the index of the last element read from Tx event FIFO to EFAI. This sets the Tx event FIFO get index TXEFS[EFGI] to EFAI + 1 and updates the FIFO 0 fill level TXEFS[EFFL].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FDCAN_CKDIV</name>
            <displayName>FDCAN_CKDIV</displayName>
            <description>FDCAN CFG clock divider register </description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PDIV</name>
                <description>input clock divider
The APB clock could be divided prior to be used by the CAN sub system. The rate must be computed using the divider output clock.
These are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Divide by 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Divide by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Divide by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Divide by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Divide by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Divide by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Divide by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Divide by 14</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Divide by 16</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Divide by 18</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Divide by 20</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Divide by 22</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Divide by 24</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Divide by 26</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Divide by 28</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Divide by 30</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>  
    </peripheral>
    <peripheral>
        <name>FLASH</name>
         <description>FLASH address block description</description>
        <groupName>FLASH</groupName>
		<baseAddress>0x40022000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>FLASH</name>
          <description>FLASH non-secure global interrupt</description>
          <value>6</value>
        </interrupt>
        <registers>
          <register>
            <name>FLASH_ACR</name>
            <displayName>FLASH_ACR</displayName>
            <description>FLASH access control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000013</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LATENCY</name>
                <description>Read latency
These bits are used to control the number of wait states used during read operations on both non-volatile memory banks. The application software has to program them to the correct value depending on the embedded Flash memory interface frequency and voltage conditions.
...
Note: No check is performed by hardware to verify that the configuration is correct.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>zero wait state used to read a word from non-volatile memory</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>one wait state used to read a word from non-volatile memory</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>two wait states used to read a word from non-volatile memory</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>seven wait states used to read a word from non-volatile memory</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>15 wait states used to read from non-volatile memory</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WRHIGHFREQ</name>
                <description>Flash signal delay
These bits are used to control the delay between non-volatile memory signals during programming operations. Application software has to program them to the correct value depending on the embedded Flash memory interface frequency. Please refer to  for details.
Note: No check is performed to verify that the configuration is correct.
Two WRHIGHFREQ values can be selected for some frequencies.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRFTEN</name>
                <description>Prefetch enable. When bit value is modified, user must read back ACR register to be sure PRFTEN has been taken into account.
Bits used to control the prefetch.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prefetch disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>prefetch enabled when latency is at least one wait state.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>S_PRFTEN</name>
                <description>Smart prefetch enable. When bit value is modified, user must read back ACR register to be sure S_PRFTEN has been taken into account.
Bits used to control the prefetch functionality.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prefetch, if enabled fetches each instruction.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>prefetch, if enabled avoids fetch past branch to improve efficiency.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSKEYR</name>
            <displayName>FLASH_NSKEYR</displayName>
            <description>FLASH key register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NSKEY</name>
                <description>Non-volatile memory configuration access unlock key</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTKEYR</name>
            <displayName>FLASH_OPTKEYR</displayName>
            <description>FLASH option key register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OPTKEY</name>
                <description>FLASH option bytes control access unlock key</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPSR</name>
            <displayName>FLASH_OPSR</displayName>
            <description>FLASH operation status register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>ADDR_OP</name>
                <description>Interrupted operation address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BK_OP</name>
                <description>Interrupted operation bank
It indicates which bank was concerned by operation.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SYSF_OP</name>
                <description>Operation in system Flash memory interrupted
Indicates that reset interrupted an ongoing operation in System Flash.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OTP_OP</name>
                <description>OTP operation interrupted
Indicates that reset interrupted an ongoing operation in OTP area.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CODE_OP</name>
                <description>Flash memory operation code</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Flash operation on going during previous reset</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Single write operation interrupted </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Sector erase operation interrupted</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Bank erase operation interrupted </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Mass erase operation interrupted</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Option change operation interrupted</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTCR</name>
            <displayName>FLASH_OPTCR</displayName>
            <description>FLASH option control register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0x0FFFFFFF</resetMask>
            <fields>
              <field>
                <name>OPTLOCK</name>
                <description>FLASH_OPTCR lock option configuration bit
The OPTLOCK bit locks the FLASH_OPTCR register as well as all _PRG registers. The correct write sequence to FLASH_OPTKEYR register unlocks this bit. If a wrong sequence is executed, or the unlock sequence to FLASH_OPTKEYR is performed twice, this bit remains locked until next system reset.
It is possible to set OPTLOCK by programming it to 1. When set to 1, a new unlock sequence is mandatory to unlock it. When OPTLOCK changes from 0 to 1, the others bits of FLASH_OPTCR register do not change.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FLASH_OPTCR register unlocked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FLASH_OPTCR register locked.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPTSTRT</name>
                <description>Option byte start change option configuration bit
OPTSTRT triggers an option byte change operation. The user can set OPTSTRT only when the OPTLOCK bit is cleared to 0. It’s set only by Software and cleared when the option byte change is completed or an error occurs (PGSERR or OPTCHANGEERR). It’s reseted at the same time as BSY bit.
The user application cannot modify any FLASH_XXX_PRG embedded Flash memory register until the option change operation has been completed.
Before setting this bit, the user has to write the required values in the FLASH_XXX_PRG registers. The FLASH_XXX_PRG registers are locked until the option byte change operation has been executed in non-volatile memory.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWAP_BANK</name>
                <description>Bank swapping option configuration bit
SWAP_BANK controls whether Bank1 and Bank2 are swapped or not. This bit is loaded with the SWAP_BANK bit of FLASH_OPTSR_CUR register only after reset or POR.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bank1 and Bank2 not swapped</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bank1 and Bank2 swapped</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSSR</name>
            <displayName>FLASH_NSSR</displayName>
            <description>FLASH non-secure status register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF0</resetMask>
            <fields>
              <field>
                <name>BSY</name>
                <description>busy flag
BSY flag indicates that a Flash memory is busy by an operation (write, erase, option byte change). It is set at the beginning of a Flash memory operation and cleared when the operation finishes or an error occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no programming, erase or option byte change operation being executed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>programming, erase or option byte change operation being executed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WBNE</name>
                <description>write buffer not empty flag
WBNE flag is set when the embedded Flash memory is waiting for new data to complete the write buffer. In this state, the write buffer is not empty. WBNE is reset by hardware each time the write buffer is complete or the write buffer is emptied following one of the event below:
the application software forces the write operation using FW bit in FLASH_NSCR
the embedded Flash memory detects an error that involves data loss
This bit cannot be reset by software writing 0 directly. To reset it, clear the write buffer by performing any of the above listed actions, or send the missing data.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write buffer empty or full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write buffer waiting data to complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBNE</name>
                <description>data buffer not empty flag
DBNE flag is set when the embedded Flash memory interface is processing 6-bits ECC data in dedicated buffer. This bit cannot be set to 0 by software. The hardware resets it once the buffer is free.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data buffer not used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data buffer used, wait</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOP</name>
                <description>end of operation flag
EOP flag is set when a operation (program/erase) completes. An interrupt is generated if the EOPIE is set to 1. It is not necessary to reset EOP before starting a new operation. EOP bit is cleared by writing 1 to CLR_EOP bit in FLASH_NSCCR register.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no operation completed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a operation completed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WRPERR</name>
                <description>write protection error flag
WRPERR flag is raised when a protection error occurs during a program operation. An interrupt is also generated if the WRPERRIE is set to 1. Writing 1 to CLR_WRPERR bit in FLASH_NSCCR register clears WRPERR.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no write protection error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a write protection error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PGSERR</name>
                <description>programming sequence error flag
PGSERR flag is raised when a sequence error occurs. An interrupt is generated if the PGSERRIE bit is set to 1. Writing 1 to CLR_PGSERR bit in FLASH_NSCCR register clears PGSERR.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no sequence error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a sequence error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STRBERR</name>
                <description>strobe error flag
STRBERR flag is raised when a strobe error occurs (when the master attempts to write several times the same byte in the write buffer). An interrupt is generated if the STRBERRIE bit is set to 1. Writing 1 to CLR_STRBERR bit in FLASH_NSCCR register clears STRBERR.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no strobe error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a strobe error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INCERR</name>
                <description>inconsistency error flag
INCERR flag is raised when a inconsistency error occurs. An interrupt is generated if INCERRIE is set to 1. Writing 1 to CLR_INCERR bit in the FLASH_NSCCR register clears INCERR.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no inconsistency error occurs </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a inconsistency error occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPTCHANGEERR</name>
                <description>Option byte change error flag
OPTCHANGEERR flag indicates that an error occurred during an option byte change operation. When OPTCHANGEERR is set to 1, the option byte change operation did not successfully complete. An interrupt is generated when this flag is raised if the OPTCHANGEERRIE bit of FLASH_NSCR register is set to 1.
Writing 1 to CLR_OPTCHANGEERR of register FLASH_CCR clears OPTCHANGEERR.
Note: The OPTSTRT bit in FLASH_OPTCR cannot be set while OPTCHANGEERR is set.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no option byte change errors occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>one or more errors occurred during an option byte change operation.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>FLASH_SECSR</name>
            <displayName>FLASH_SECSR</displayName>
            <description>FLASH secure status register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF0</resetMask>
            <fields>
              <field>
                <name>SECBSY</name>
                <description>busy flag
BSY flag indicates that a FLASH memory is busy by an operation (write, erase, option byte change, OBK operations, PUF operation). It is set at the beginning of a Flash memory operation and cleared when the operation finishes or an error occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no programming, erase or option byte change operation being executed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>programming, erase or option byte change operation being executed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECWBNE</name>
                <description>write buffer not empty flag
WBNE flag is set when the embedded Flash memory is waiting for new data to complete the write buffer. In this state, the write buffer is not empty. WBNE is reset by hardware each time the write buffer is complete or the write buffer is emptied following one of the event below:
the application software forces the write operation using FW bit in FLASH_SECCR
the embedded Flash memory detects an error that involves data loss
This bit cannot be reset by writing 0 directly by software. To reset it, clear the write buffer by performing any of the above listed actions, or send the missing data.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write buffer empty or full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write buffer waiting data to complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>            
              <field>
                <name>SECDBNE</name>
                <description>data buffer not empty flag
DBNE flag is set when the embedded Flash memory interface is processing 6-bits ECC data in dedicated buffer. This bit cannot be set to 0 by software. The hardware resets it once the buffer is free.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data buffer not used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data buffer used, wait</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECEOP</name>
                <description>end of operation flag
EOP flag is set when a operation (program/erase) completes. An interrupt is generated if the EOPIE is set to. It is not necessary to reset EOP before starting a new operation. EOP bit is cleared by writing 1 to CLR_EOP bit in FLASH_SECCCR register.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no operation completed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a operation completed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECWRPERR</name>
                <description>write protection error flag
WRPERR flag is raised when a protection error occurs during a program operation. An interrupt is also generated if the WRPERRIE is set to 1. Writing 1 to CLR_WRPERR bit in FLASH_SECCCR register clears WRPERR.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no write protection error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a write protection error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECPGSERR</name>
                <description>programming sequence error flag
PGSERR flag is raised when a sequence error occurs. An interrupt is generated if the PGSERRIE bit is set to 1. Writing 1 to CLR_PGSERR bit in FLASH_SECCCR register clears PGSERR.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no sequence error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a sequence error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECSTRBERR</name>
                <description>strobe error flag
STRBERR flag is raised when a strobe error occurs (when the master attempts to write several times the same byte in the write buffer). An interrupt is generated if the STRBERRIE bit is set to 1. Writing 1 to CLR_STRBERR bit in FLASH_SECCCR register clears STRBERR.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no strobe error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a strobe error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SECINCERR</name>
                <description>inconsistency error flag
INCERR flag is raised when a inconsistency error occurs. An interrupt is generated if INCERRIE is set to 1. Writing 1 to CLR_INCERR bit in the FLASH_SECCCR register clears INCERR.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no inconsistency error occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a inconsistency error occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSCR</name>
            <displayName>FLASH_NSCR</displayName>
            <description>FLASH Non Secure control register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>configuration lock bit
This bit locks the FLASH_NSCR register. The correct write sequence to FLASH_NSKEYR register unlocks this bit. If a wrong sequence is executed, or if the unlock sequence to FLASH_NSKEYR is performed twice, this bit remains locked until the next system reset.
LOCK can be set by programming it to 1. When set to 1, a new unlock sequence is mandatory to unlock it. When LOCK changes from 0 to 1, the other bits of FLASH_NSCR register do not change.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FLASH_NSCR register unlocked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FLASH_NSCR register locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PG</name>
                <description>programming control bit
PG can be programmed only when LOCK is cleared to 0.
PG allows programming in Bank1 and Bank2.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>programming disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>programming enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SER</name>
                <description>sector erase request
Setting SER bit to 1 requests a sector erase. SER can be programmed only when LOCK is cleared to 0.
If MER and SER are also set, a PGSERR is raised.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>sector erase not requested</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>sector erase requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BER</name>
                <description>erase request
Setting BER bit to 1 requests a bank erase operation (user Flash memory only). BER can be programmed only when LOCK is cleared to 0.
If MER and SER are also set, a PGSERR is raised.
Note: Write protection error is triggered when a bank erase is required and some sectors are protected.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>bank erase not requested</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>bank erase requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FW</name>
                <description>write forcing control bit
FW forces a write operation even if the write buffer is not full. In this case all bits not written are set to 1 by hardware. FW can be programmed only when LOCK is cleared to 0.
The embedded Flash memory resets FW when the corresponding operation has been acknowledged.
Note: Using a force-write operation prevents the application from updating later the missing bits with something else than 1, because it is likely that it leads to permanent ECC error.
Write forcing is effective only if the write buffer is not empty (in particular, FW does not start several write operations when the force-write operations are performed consecutively).
Since there is just one write buffer, FW can force a write in bank1 or bank2.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STRT</name>
                <description>erase start control bit
STRT bit is used to start a sector erase or a bank erase operation. STRT can be programmed only when LOCK is cleared to 0.
STRT is reset at the end of the operation or when an error occurs. It cannot be reseted by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SNB</name>
                <description>sector erase selection number
These bits are used to select the target sector for an erase operation (they are unused otherwise). SNB can be programmed only when LOCK is cleared to 0.
...</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Sector 0 selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sector 1 selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Sector 7 selected</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MER</name>
                <description>Mass erase request
Setting MER bit to 1 requests a mass erase operation (user Flash memory only). MER can be programmed only when LOCK is cleared to 0.
If BER or SER are both set, a PGSERR is raised.
Error is triggered when a mass erase is required and some sectors are protected.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>mass erase not requested</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>mass erase requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOPIE</name>
                <description>end of operation interrupt control bit
Setting EOPIE bit to 1 enables the generation of an interrupt at the end of a program or erase operation. EOPIE can be programmed only when LOCK is cleared to 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated at the end of operation. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled when at the end of operation</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WRPERRIE</name>
                <description>write protection error interrupt enable bit
When WRPERRIE bit is set to 1, an interrupt is generated when a protection error occurs during a program operation. WRPERRIE can be programmed only when LOCK is cleared to 0.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated when a protection error occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when a protection error occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PGSERRIE</name>
                <description>programming sequence error interrupt enable bit
When PGSERRIE bit is set to 1, an interrupt is generated when a sequence error occurs during a program operation. PGSERRIE can be programmed only when LOCK is cleared to 0.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated when a sequence error occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when sequence error occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STRBERRIE</name>
                <description>strobe error interrupt enable bit
When STRBERRIE bit is set to 1, an interrupt is generated when a strobe error occurs (the master programs several times the same byte in the write buffer) during a write operation. STRBERRIE can be programmed only when LOCK is cleared to 0.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated when a strobe error occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when strobe error occurs.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INCERRIE</name>
                <description>inconsistency error interrupt enable bit
When INCERRIE bit is set to 1, an interrupt is generated when an inconsistency error occurs during a write operation. INCERRIE can be programmed only when LOCK is cleared to 0.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated when a inconsistency error occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when a inconsistency error occurs.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPTCHANGEERRIE</name>
                <description>Option byte change error interrupt enable bit
OPTCHANGEERRIE bit controls if an interrupt has to be generated when an error occurs during an option byte change. This bit can be programmed only when LOCK bit is cleared to 0.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt is generated when an error occurs during an option byte change</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an interrupt is generated when and error occurs during an option byte change.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKSEL</name>
                <description>Bank selector bit
BKSEL can only be programmed when LOCK is cleared to 0. The bit selects physical bank, SWAP_BANK setting is ignored.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bank1 is selected for Bank erase / sector erase / interrupt enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bank2 is selected for BER / SER</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSCCR</name>
            <displayName>FLASH_NSCCR</displayName>
            <description>FLASH non-secure clear control register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CLR_EOP</name>
                <description>EOP flag clear bit
Setting this bit to 1 resets to 0 EOP flag in FLASH_NSSR register.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CLR_WRPERR</name>
                <description>WRPERR flag clear bit
Setting this bit to 1 resets to 0 WRPERR flag in FLASH_NSSR register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CLR_PGSERR</name>
                <description>PGSERR flag clear bit
Setting this bit to 1 resets to 0 PGSERR flag in FLASH_NSSR register.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CLR_STRBERR</name>
                <description>STRBERR flag clear bit
Setting this bit to 1 resets to 0 STRBERR flag in FLASH_NSSR register.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CLR_INCERR</name>
                <description>INCERR flag clear bit
Setting this bit to 1 resets to 0 INCERR flag in FLASH_NSSR register.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CLR_OPTCHANGEERR</name>
                <description>Clear the flag corresponding flag in FLASH_NSSR by writing this bit.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_PRIVCFGR</name>
            <displayName>FLASH_PRIVCFGR</displayName>
            <description>FLASH privilege configuration register </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NSPRIV</name>
                <description>privilege attribute for non secure registers</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>access to non secure registers is always granted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>access to non secure registers is denied in case of non privileged access.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_HDPEXTR</name>
            <displayName>FLASH_HDPEXTR</displayName>
            <description>FLASH HDP extension register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HDP1_EXT</name>
                <description>HDP area extension in 8 Kbytes sectors in Bank1. Extension is added after the HDP1_END sector.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HDP2_EXT</name>
                <description>HDP area extension in 8 Kbytes sectors in Bank2. Extension is added after the HDP2_END sector.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTSR_CUR</name>
            <displayName>FLASH_OPTSR_CUR</displayName>
            <description>FLASH option status register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>BOR_LEV</name>
                <description>Brownout level option status bit
These bits reflects the power level that generates a system reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BOR OFF, POR/PDR reset threshold level is applied</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BOR Level 1, the threshold level is low (around 2.1 V)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>BOR Level 2, the threshold level is medium (around 2.4 V)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>BOR Level 3, the threshold level is high (around 2.7 V)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BORH_EN</name>
                <description>Brownout high enable status bit</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_SW</name>
                <description>IWDG control mode option status bit</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>IWDG watchdog is controlled by hardware</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>IWDG watchdog is controlled by software</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDG_SW</name>
                <description>WWDG control mode option status bit</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WWDG watchdog is controlled by hardware</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>WWDG watchdog is controlled by software</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_SHDW</name>
                <description>Core domain Shutdown entry reset option status bit</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Shutdown mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Shutdown mode on core domain. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_STOP</name>
                <description>Core domain Stop entry reset option status bit</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Stop mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Stop mode on core domain.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_STDBY</name>
                <description>Core domain Standby entry reset option status bit</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Standby mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Standby mode on core domain. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRODUCT_STATE</name>
                <description>Life state code (based on Hamming 8,4). More information in .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>IO_VDD_HSLV</name>
                <description>High-speed IO at low VDD voltage status bit. This bit can be set only with VDD below 2.5 V.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High-speed IO at low VDD voltage feature disabled (VDD can exceed 2.5 V) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-speed IO at low VDD voltage feature enabled (VDD remains below 2.5 V) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO_VDDIO2_HSLV</name>
                <description>High-speed IO at low VDDIO2 voltage status bit. This bit can be set only with VDDIO2 below 2.5 V.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High-speed IO at low VDDIO2 voltage feature disabled (VDDIO2 can exceed 2.5 V) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-speed IO at low VDDIO2 voltage feature enabled (VDDIO2 remains below 2.5 V) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_STOP</name>
                <description>IWDG Stop mode freeze option status bit
When set the independent watchdog IWDG is in system Stop mode.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Independent watchdog frozen in system Stop mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Independent watchdog keep running in system Stop mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_STDBY</name>
                <description>IWDG Standby mode freeze option status bit
When set the independent watchdog IWDG is frozen in system Standby mode.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Independent watchdog frozen in Standby mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Independent watchdog keep running in Standby mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWAP_BANK</name>
                <description>Bank swapping option status bit
SWAP_BANK reflects whether Bank1 and Bank2 are swapped or not.
SWAP_BANK is loaded to SWAP_BANK of FLASH_OPTCR after a reset.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bank1 and Bank2 not swapped</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bank1 and Bank2 swapped</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTSR_PRG</name>
            <displayName>FLASH_OPTSR_PRG</displayName>
            <description>FLASH option status register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>BOR_LEV</name>
                <description>Brownout level option configuration bit
These bits reflects the power level that generates a system reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BOR OFF, POR/PDR reset threshold level is applied</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BOR Level 1, the threshold level is low (around 2.1 V)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>BOR Level 2, the threshold level is medium (around 2.4 V)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>BOR Level 3, the threshold level is high (around 2.7 V)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BORH_EN</name>
                <description>Brownout high enable configuration bit</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_SW</name>
                <description>IWDG control mode option configuration bit</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>IWDG watchdog is controlled by hardware</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>IWDG watchdog is controlled by software</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDG_SW</name>
                <description>WWDG control mode option configuration bit</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WWDG watchdog is controlled by hardware</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>WWDG watchdog is controlled by software</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_SHDW</name>
                <description>Core domain Shutdown entry reset option configuration bit</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Shutdown mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Shutdown mode on core domain. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_STOP</name>
                <description>Core domain Stop entry reset option configuration bit</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Stop mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Stop mode on core domain.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NRST_STDBY</name>
                <description>Core domain Standby entry reset option configuration bit</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a reset is generated when entering Standby mode on core domain</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no reset generated when entering Standby mode on core domain. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRODUCT_STATE</name>
                <description>Life state code (based on Hamming 8,4). More information in .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_VDD_HSLV</name>
                <description>High-speed IO at low VDD voltage configuration bit. This bit can be set only with VDD below 2.5 V.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High-speed IO at low VDD voltage feature disabled (VDD can exceed 2.5 V) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-speed IO at low VDD voltage feature enabled (VDD remains below 2.5 V) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO_VDDIO2_HSLV</name>
                <description>High-speed IO at low VDDIO2 voltage configuration bit. This bit can be set only with VDDIO2 below 2.5 V.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High-speed IO at low VDDIO2 voltage feature disabled (VDDIO2 can exceed 2.5 V) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-speed IO at low VDDIO2 voltage feature enabled (VDDIO2 remains below 2.5 V) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_STOP</name>
                <description>IWDG Stop mode freeze option configuration bit
When set the independent watchdog IWDG is in system Stop mode.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Independent watchdog frozen in system Stop mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Independent watchdog keep running in system Stop mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDG_STDBY</name>
                <description>IWDG Standby mode freeze option configuration bit
When set the independent watchdog IWDG is frozen in system Standby mode.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Independent watchdog frozen in Standby mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Independent watchdog keep running in Standby mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWAP_BANK</name>
                <description>Bank swapping option configuration bit
SWAP_BANK option bit is used to configure whether the Bank1 and Bank2 are swapped or not. This bit is loaded with the SWAP_BANK bit of FLASH_OPTSR_CUR register after a reset.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Bank1 and Bank2 not swapped</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Bank1 and Bank2 swapped</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTSR2_CUR</name>
            <displayName>FLASH_OPTSR2_CUR</displayName>
            <description>FLASH option status register 2 </description>
            <addressOffset>0x70</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>SRAM2_RST</name>
                <description>SRAM2 erase when system reset</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 erased when a system reset occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 not erased when a system reset occurs.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKPRAM_ECC</name>
                <description>Backup RAM ECC detection and correction disable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKPRAM ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKPRAM ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2_ECC</name>
                <description>SRAM2 ECC detection and correction disable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1_RST</name>
                <description>SRAM1 erase upon system reset</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 erased when a system reset occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 not erased when a system reset occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1_ECC</name>
                <description>SRAM1 ECC detection and correction disable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OPTSR2_PRG</name>
            <displayName>FLASH_OPTSR2_PRG</displayName>
            <description>FLASH option status register 2 </description>
            <addressOffset>0x74</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>SRAM2_RST</name>
                <description>SRAM2 erase when system reset</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 erased when a system reset occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 not erased when a system reset occurs.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKPRAM_ECC</name>
                <description>Backup RAM ECC detection and correction disable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKPRAM ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKPRAM ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2_ECC</name>
                <description>SRAM2 ECC detection and correction disable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1_RST</name>
                <description>SRAM1 erase upon system reset</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 erased when a system reset occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 not erased when a system reset occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1_ECC</name>
                <description>SRAM1 ECC detection and correction disable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 ECC check enabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 ECC check disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSBOOTR_CUR</name>
            <displayName>FLASH_NSBOOTR_CUR</displayName>
            <description>FLASH non-secure unique boot entry register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>NSBOOT_LOCK</name>
                <description>A field locking the values of SWAP_BANK, and NSBOOTADD settings.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0xC3</name>
                    <description>The SWAP_BANK and NSBOOTADD can still be modified following their individual rules.</description>
                    <value>0xC3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB4</name>
                    <description>The NSBOOTADD and SWAP_BANK are frozen.</description>
                    <value>0xB4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NSBOOTADD</name>
                <description>unique boot entry address
These bits reflect the UBE address</description>
                <bitOffset>8</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_NSBOOTR_PRG</name>
            <displayName>FLASH_NSBOOTR_PRG</displayName>
            <description>FLASH non-secure unique boot entry address </description>
            <addressOffset>0x84</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>NSBOOT_LOCK</name>
                <description>A field locking the values of SWAP_BANK, and NSBOOTADD settings.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0xC3</name>
                    <description>The SWAP_BANK and NSBOOTADD can still be modified following their individual rules.</description>
                    <value>0xC3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB4</name>
                    <description>The NSBOOTADD and SWAP_BANK are frozen. </description>
                    <value>0xB4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NSBOOTADD</name>
                <description>Unique boot entry address
These bits allow configuring the BOOT address</description>
                <bitOffset>8</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OTPBLR_CUR</name>
            <displayName>FLASH_OTPBLR_CUR</displayName>
            <description>FLASH non-secure OTP block lock </description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>LOCKBL</name>
                <description>OTP block lock
Block n corresponds to OTP 16-bit word 32 x n to 32 x n + 31.
LOCKBL[n] = 1 indicates that all OTP 16-bit words in OTP Block n are locked and attempt to program them results in WRPERR.
LOCKBL[n] = 0 indicates that all OTP 16-bit words in OTP Block n are not locked.
When one block is locked, it’s not possible to remove the write protection.
Also if not locked, it is not possible to erase OTP words.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_OTPBLR_PRG</name>
            <displayName>FLASH_OTPBLR_PRG</displayName>
            <description>FLASH non-secure OTP block lock </description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>LOCKBL</name>
                <description>OTP block lock
Block n corresponds to OTP 16-bit word 32 x n to 32 x n + 31.
LOCKBL[n] = 1 indicates that all OTP 16-bit words in OTP Block n are locked and attempt to program them results in WRPERR.
LOCKBL[n] = 0 indicates that all OTP 16-bit words in OTP Block n are not locked.
When one block is locked, it is not possible to remove the write protection.
LOCKBL bits can be set if the corresponding bit in FLASH_OTPBLR_CUR is cleared.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_PRIVBB1R</name>
            <displayName>FLASH_PRIVBB1R</displayName>
            <description>FLASH privilege register for bank 1 </description>
            <addressOffset>0xc0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIVBB1</name>
                <description>Privileged / unprivileged 8 Kbytes Flash Bank1 sector attribute (y = 0 to 7)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>sectors y in bank 1 is non privileged</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>sector y in bank 1 is privileged</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_WRPSGN1R_CUR</name>
            <displayName>FLASH_WRPSGN1R_CUR</displayName>
            <description>FLASH write sector protection for Bank1	</description>
            <addressOffset>0xe8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>WRPSG1</name>
                <description>Bank1 sector protection option status byte
Setting WRPSG1 bits to 0 write protects the corresponding sectors in bank 1 (0: write protected; 1: not write protected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_WRPSGN1R_PRG</name>
            <displayName>FLASH_WRPSGN1R_PRG</displayName>
            <description>FLASH write sector protection for Bank1	</description>
            <addressOffset>0xec</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>WRPSG1</name>
                <description>Bank1 sector protection option status byte
Setting WRPSG1 bits to 0 write protects the corresponding sectors in bank 1 (0: write protected; 1: not write protected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_HDP1R_CUR</name>
            <displayName>FLASH_HDP1R_CUR</displayName>
            <description>FLASH HDP Bank1 register </description>
            <addressOffset>0xf8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>HDP1_STRT</name>
                <description>HDPL barrier start set in number of 8 Kbytes sectors</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HDP1_END</name>
                <description>HDPL barrier end set in number of 8 Kbytes sectors</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_HDP1R_PRG</name>
            <displayName>FLASH_HDP1R_PRG</displayName>
            <description>FLASH HDP Bank1 register </description>
            <addressOffset>0xfc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>HDP1_STRT</name>
                <description>Bank 1 HDPL barrier start set in number of 8 Kbytes sectors</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HDP1_END</name>
                <description>Bank 1 HDPL barrier end set in number of 8 Kbytes sectors</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_ECCCORR</name>
            <displayName>FLASH_ECCCORR</displayName>
            <description>FLASH Flash ECC correction register </description>
            <addressOffset>0x100</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR_ECC</name>
                <description>ECC error address
When an ECC error occurs (for single correction) during a read operation, the ADDR_ECC contains the address that generated the error.
ADDR_ECC is reset when the flag error is reset.
The embedded Flash memory programs the address in this register only when no ECC error flags are set. This means that only the first address that generated an ECC error is saved.
The address in ADDR_ECC is relative to the Flash memory area where the error occurred (user Flash memory, system Flash memory, data area, read-only/OTP area).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BK_ECC</name>
                <description>ECC bank flag for corrected ECC error
It indicates which bank is concerned by ECC error</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SYSF_ECC</name>
                <description>ECC flag for corrected ECC error in system FLASH
It indicates if system Flash memory is concerned by ECC error.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OTP_ECC</name>
                <description>OTP ECC error bit
This bit is set to 1 when one single ECC correction occurred during the last successful read operation from the read-only/ OTP area. The address of the ECC error is available in ADDR_ECC bitfield.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ECCCIE</name>
                <description>ECC single correction error interrupt enable bit When ECCCIE bit is set to 1, an interrupt is generated when an ECC single correction error occurs during a read operation.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no interrupt generated when an ECC single correction error occurs </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>non-secure interrupt generated when an ECC single correction error occurs </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ECCC</name>
                <description>ECC correction set by hardware when single ECC error has been detected and corrected.
Cleared by writing 1.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_ECCDETR</name>
            <displayName>FLASH_ECCDETR</displayName>
            <description>FLASH ECC detection register </description>
            <addressOffset>0x104</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR_ECC</name>
                <description>ECC error address
When an ECC error occurs (double detection) during a read operation, the ADDR_ECC contains the address that generated the error.
ADDR_ECC is reset when the flag error is reset.
The embedded Flash memory programs the address in this register only when no ECC error flags are set. This means that only the first address that generated an double ECC error is saved.
The address in ADDR_ECC is relative to the Flash memory area where the error occurred (user Flash memory, system Flash memory, data area, read-only/OTP area).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BK_ECC</name>
                <description>ECC fail bank for double ECC Error
It indicates which bank is concerned by ECC error</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SYSF_ECC</name>
                <description>ECC fail for double ECC error in system Flash memory
It indicates if system Flash memory is concerned by ECC error.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OTP_ECC</name>
                <description>OTP ECC error bit
This bit is set to 1 when double ECC detection occurred during the last read operation from the read-only/ OTP area. The address of the ECC error is available in ADDR_ECC bit field.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ECCD</name>
                <description>ECC detection set by hardware when two ECC error has been detected.
When this bit is set, a NMI is generated.
Cleared by writing 1. Needs to be cleared in order to detect subsequent double ECC errors.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_ECCDR</name>
            <displayName>FLASH_ECCDR</displayName>
            <description>FLASH ECC data </description>
            <addressOffset>0x108</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_ECC</name>
                <description>ECC error data
When an double detection ECC error occurs on special areas with 6-bit ECC on 16-bit of data (data area, read-only/OTP area), the failing data is read to this register.
By checking if it is possible to determine whether the failure was on a real data, or due to access to uninitialized memory.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_WRPSGN2R_CUR</name>
            <displayName>FLASH_WRPSGN2R_CUR</displayName>
            <description>FLASH write sector protection for Bank2	</description>
            <addressOffset>0x1e8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>WRPSG2</name>
                <description>Bank2 sector protection option status byte
Setting WRPSG2 bits to 0 write protects the corresponding sectors in bank 2 (0: write protected; 1: not write protected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_WRPSGN2R_PRG</name>
            <displayName>FLASH_WRPSGN2R_PRG</displayName>
            <description>FLASH write sector protection for Bank2	</description>
            <addressOffset>0x1ec</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>WRPSG2</name>
                <description>Bank2 sector protection option status byte
Setting WRPSG2 bits to 0 write protects the corresponding sectors in bank 2 (0: write protected; 1: not write protected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_HDP2R_CUR</name>
            <displayName>FLASH_HDP2R_CUR</displayName>
            <description>FLASH HDP Bank2 register </description>
            <addressOffset>0x1f8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>HDP2_STRT</name>
                <description>Bank 2 HDPL barrier start set in number of 8 Kbytes sectors</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HDP2_END</name>
                <description>Bank 2 HDPL barrier end set in number of 8 Kbytes sectors</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_HDP2R_PRG</name>
            <displayName>FLASH_HDP2R_PRG</displayName>
            <description>FLASH HDP Bank2 register </description>
            <addressOffset>0x1fc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000000</resetMask>
            <fields>
              <field>
                <name>HDP2_STRT</name>
                <description>Bank 2 HDPL barrier start set in number of 8 Kbytes sectors</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HDP2_END</name>
                <description>Bank 2 HDPL barrier end set in number of 8 Kbytes sectors</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	
	<peripheral>
      <name>GPIOA</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
          <register>
            <name>GPIOA_MODER</name>
            <displayName>GPIOA_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xABFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OTYPER</name>
            <displayName>GPIOA_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_OSPEEDR</name>
            <displayName>GPIOA_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_PUPDR</name>
            <displayName>GPIOA_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x64000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_IDR</name>
            <displayName>GPIOA_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_ODR</name>
            <displayName>GPIOA_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BSRR</name>
            <displayName>GPIOA_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_LCKR</name>
            <displayName>GPIOA_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the LOCK.
After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRL</name>
            <displayName>GPIOA_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_AFRH</name>
            <displayName>GPIOA_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_BRR</name>
            <displayName>GPIOA_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOA_HSLVR</name>
            <displayName>GPIOA_HSLVR</displayName>
            <description>GPIO high-speed low-voltage register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HSLV0</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV1</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV2</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV3</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV4</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV5</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV6</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV7</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV8</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV9</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV10</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV11</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV12</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV13</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV14</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV15</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
      <name>GPIOB</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
        <registers>
          <register>
            <name>GPIOB_MODER</name>
            <displayName>GPIOB_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xABFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OTYPER</name>
            <displayName>GPIOB_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_OSPEEDR</name>
            <displayName>GPIOB_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_PUPDR</name>
            <displayName>GPIOB_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x64000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_IDR</name>
            <displayName>GPIOB_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_ODR</name>
            <displayName>GPIOB_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BSRR</name>
            <displayName>GPIOB_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_LCKR</name>
            <displayName>GPIOB_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the LOCK.
After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRL</name>
            <displayName>GPIOB_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_AFRH</name>
            <displayName>GPIOB_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_BRR</name>
            <displayName>GPIOB_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOB_HSLVR</name>
            <displayName>GPIOB_HSLVR</displayName>
            <description>GPIO high-speed low-voltage register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HSLV0</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV1</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV2</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV3</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV4</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV5</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV6</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV7</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV8</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV9</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV10</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV11</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV12</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV13</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV14</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV15</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
      <name>GPIOC</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42020800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
          <register>
            <name>GPIOC_MODER</name>
            <displayName>GPIOC_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xABFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OTYPER</name>
            <displayName>GPIOC_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_OSPEEDR</name>
            <displayName>GPIOC_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_PUPDR</name>
            <displayName>GPIOC_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x64000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_IDR</name>
            <displayName>GPIOC_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_ODR</name>
            <displayName>GPIOC_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BSRR</name>
            <displayName>GPIOC_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_LCKR</name>
            <displayName>GPIOC_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the LOCK.
After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_AFRL</name>
            <displayName>GPIOC_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_AFRH</name>
            <displayName>GPIOC_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_BRR</name>
            <displayName>GPIOC_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOC_HSLVR</name>
            <displayName>GPIOC_HSLVR</displayName>
            <description>GPIO high-speed low-voltage register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HSLV0</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV1</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV2</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV3</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV4</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV5</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV6</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV7</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV8</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV9</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV10</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV11</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV12</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV13</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV14</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV15</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral derivedFrom="GPIOC">
      <name>GPIOD</name>
      <baseAddress>0x42020C00</baseAddress>
    </peripheral>
    <peripheral>
      <name>GPIOH</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x42021C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
          <register>
            <name>GPIOH_MODER</name>
            <displayName>GPIOH_MODER</displayName>
            <description>GPIO port mode register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0xABFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MODE0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O mode.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Input mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General purpose output mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Alternate function mode</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Analog mode (reset state)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_OTYPER</name>
            <displayName>GPIOH_OTYPER</displayName>
            <description>GPIO port output type register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OT0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OT15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output type.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Output push-pull (reset state)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Output open-drain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_OSPEEDR</name>
            <displayName>GPIOH_OSPEEDR</displayName>
            <description>GPIO port output speed register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OSPEED0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OSPEED15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O output speed.
Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Low speed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Medium speed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>High speed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Very-high speed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_PUPDR</name>
            <displayName>GPIOH_PUPDR</displayName>
            <description>GPIO port pull-up/pull-down register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x64000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PUPD0</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD1</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD2</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD3</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD4</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD5</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD6</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD7</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD8</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD9</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD10</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD11</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD12</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD13</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD14</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PUPD15</name>
                <description>Port x configuration I/O pin y (y = 15 to 0)
These bits are written by software to configure the I/O pull-up or pull-down
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No pull-up, pull-down</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Pull-up</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Pull-down</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_IDR</name>
            <displayName>GPIOH_IDR</displayName>
            <description>GPIO port input data register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>ID0</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID1</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID2</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID3</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID4</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID5</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID6</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID7</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID8</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID9</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID10</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID11</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID12</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID13</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID14</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ID15</name>
                <description>Port x input data I/O pin y (y = 15 to 0)
These bits are read-only. They contain the input value of the corresponding I/O port.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_ODR</name>
            <displayName>GPIOH_ODR</displayName>
            <description>GPIO port output data register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OD0</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD1</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD2</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD3</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD4</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD5</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD6</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD7</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD8</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD9</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD10</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD11</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD12</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD13</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD14</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD15</name>
                <description>Port output data I/O pin y (y = 15 to 0)
These bits can be read and written by software.
Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_BSRR</name>
            <displayName>GPIOH_BSRR</displayName>
            <description>GPIO port bit set/reset register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BS0</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS1</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS2</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS3</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS4</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS5</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS6</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS7</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS8</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS9</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS10</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS11</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS12</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS13</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS14</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BS15</name>
                <description>Port x set I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Sets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR0</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset I/O pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: If both BSy and BRy are set, BSy has priority.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Resets the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_LCKR</name>
            <displayName>GPIOH_LCKR</displayName>
            <description>GPIO port configuration lock register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LCK0</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK1</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK2</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK3</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK4</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK5</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK6</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK7</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK8</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK9</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK10</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK11</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK12</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK13</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK14</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCK15</name>
                <description>Port x lock I/O pin y (y = 15 to 0)
These bits are read/write but can only be written when the LCKK bit is 0
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LCKK</name>
                <description>Lock key
This bit can be read any time. It can only be modified using the lock key write sequence.
- LOCK key write sequence:
WR LCKR[16] = 1 + LCKR[15:0]
WR LCKR[16] = 0 + LCKR[15:0]
WR LCKR[16] = 1 + LCKR[15:0]
- LOCK key read
RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)
Note: During the LOCK key write sequence, the value of LCK[15:0] must not change.
Any error in the lock sequence aborts the LOCK.
After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Port configuration lock key not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU reset or peripheral reset.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_AFRL</name>
            <displayName>GPIOH_AFRL</displayName>
            <description>GPIO alternate function low register</description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL0</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL1</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL2</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL3</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL4</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL5</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL6</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL7</name>
                <description>Alternate function selection for port x I/O pin y (y = 7 to 0)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_AFRH</name>
            <displayName>GPIOH_AFRH</displayName>
            <description>GPIO alternate function high register</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AFSEL8</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL9</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL10</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL11</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL12</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL13</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL14</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFSEL15</name>
                <description>Alternate function selection for port x I/O pin y (y = 15 to 8)
These bits are written by software to configure alternate function I/Os.
Note: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>AF2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AF3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>AF4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>AF5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>AF6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>AF7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>AF8</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>AF9</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>AF10</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>AF11</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>AF12</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>AF13</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>AF14</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>AF15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_BRR</name>
            <displayName>GPIOH_BRR</displayName>
            <description>GPIO port bit reset register</description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BR0</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR1</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR2</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR3</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR4</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR5</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR6</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR7</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR8</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR9</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR10</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR11</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR12</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR13</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR14</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BR15</name>
                <description>Port x reset IO pin y (y = 15 to 0)
These bits are write-only. A read to these bits returns the value 0x0000.
Note: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action on the corresponding ODy bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reset the corresponding ODy bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>GPIOH_HSLVR</name>
            <displayName>GPIOH_HSLVR</displayName>
            <description>GPIO high-speed low-voltage register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HSLV0</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV1</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV2</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV3</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV4</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV5</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV6</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV7</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV8</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV9</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV10</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV11</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV12</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV13</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV14</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSLV15</name>
                <description>Port x high-speed low-voltage configuration (y = 15 to 0)
These bits are written by software to optimize the I/O speed when the I/O supply is low.
Each bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.
Setting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.
Note: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.
The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I/O speed optimization disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I/O speed optimization enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>IWDG</name>
        <description>Independent watchdog</description>
        <groupName>IWDG</groupName>
        <baseAddress>0x40003000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>IWDG</name>
          <description>IWDG interrupt</description>
          <value>35</value>
        </interrupt>
        <registers>
          <register>
            <name>IWDG_KR</name>
            <displayName>IWDG_KR</displayName>
            <description>IWDG key register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>KEY</name>
                <description>Key value (write only, read 0x0000)
These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.
Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see )
Writing the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_PR</name>
            <displayName>IWDG_PR</displayName>
            <description>IWDG prescaler register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PR</name>
                <description>Prescaler divider
These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.
Others: divider / 1024
Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>divider / 4</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>divider / 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>divider / 16</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>divider / 32</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>divider / 64</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>divider / 128</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>divider / 256</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>divider / 512</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_RLR</name>
            <displayName>IWDG_RLR</displayName>
            <description>IWDG reload register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RL</name>
                <description>Watchdog counter reload value
These bits are write access protected see . They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the . The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.
The RVU bit in the  must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the status register (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_SR</name>
            <displayName>IWDG_SR</displayName>
            <description>IWDG status register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PVU</name>
                <description>Watchdog prescaler value update
This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The prescaler value can be updated only when PVU bit is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RVU</name>
                <description>Watchdog counter reload value update
This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The reload value can be updated only when RVU bit is reset.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WVU</name>
                <description>Watchdog counter window value update
This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The window value can be updated only when WVU bit is reset.
This bit is generated only if generic “window” = 1</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EWU</name>
                <description>Watchdog interrupt comparator value update
This bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).
The EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EWIF</name>
                <description>Watchdog early interrupt flag
This bit is set to ‘1’ by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to ‘1’.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_WINR</name>
            <displayName>IWDG_WINR</displayName>
            <description>IWDG window register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000FFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WIN</name>
                <description>Watchdog counter window value
These bits are write access protected, see , they contain the high limit of the window value to be compared with the downcounter.
To prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]+1 and greater than 1.
The WVU bit in the  must be reset to be able to change the reload value.
Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the (IWDG_SR) is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IWDG_EWCR</name>
            <displayName>IWDG_EWCR</displayName>
            <description>IWDG early wakeup interrupt register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWIT</name>
                <description>Watchdog counter window value
These bits are write access protected (see ). They are written by software to define at which position of the IWDCNT down-counter the early wakeup interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0] - 1.
EWIT[11:0] must be bigger than 1.
An interrupt is generated only if EWIE = 1.
The EWU bit in the  must be reset to be able to change the reload value.
Note: Reading this register returns the Early wakeup comparator value and the Interrupt enable bit from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the  is reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWIC</name>
                <description>Watchdog early interrupt acknowledge
The software must write a 1 into this bit in order to acknowledge the early wakeup interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EWIE</name>
                <description>Watchdog early interrupt enable
Set and reset by software.
The EWU bit in the  must be reset to be able to change the value of this bit.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The early interrupt interface is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The early interrupt interface is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
       </registers>
    </peripheral>
	<peripheral>
        <name>I2C1</name>
      <description>Inter-integrated circuit</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40005400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I2C1_EV</name>
        <description>I2C1 event interrupt</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>I2C1_ER</name>
        <description>I2C1 error interrupt</description>
        <value>52</value>
      </interrupt>
        <registers>
          <register>
            <name>I2C_CR1</name>
            <displayName>I2C_CR1</displayName>
            <description>I2C control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Peripheral enable
Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Peripheral disable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Peripheral enable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXIE</name>
                <description>TX Interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmit (TXIS) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit (TXIS) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXIE</name>
                <description>RX Interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive (RXNE) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive (RXNE) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRIE</name>
                <description>Address match Interrupt enable (slave only)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Address match (ADDR) interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address match (ADDR) interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACKIE</name>
                <description>Not acknowledge received Interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Not acknowledge (NACKF) received interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Not acknowledge (NACKF) received interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPIE</name>
                <description>Stop detection Interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Stop detection (STOPF) interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop detection (STOPF) interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transfer Complete interrupt enable
Note: Any of these events generate an interrupt:
Transfer Complete (TC)
Transfer Complete Reload (TCR)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transfer Complete interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transfer Complete interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRIE</name>
                <description>Error interrupts enable
Note: Any of these errors generate an interrupt:
Arbitration Loss (ARLO)
Bus Error detection (BERR)
Overrun/Underrun (OVR)
Timeout detection (TIMEOUT)
PEC error detection (PECERR)
Alert pin event detection (ALERT)</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Error detection interrupts disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Error detection interrupts enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DNF</name>
                <description>Digital noise filter
These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK
...
Note: If the analog filter is also enabled, the digital filter is added to the analog filter.
This filter can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Digital filter disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Digital filter enabled and filtering capability up to 1 tI2CCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>digital filter enabled and filtering capability up to15 tI2CCLK</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANFOFF</name>
                <description>Analog noise filter OFF
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Analog noise filter enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Analog noise filter disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>DMA transmission requests enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXDMAEN</name>
                <description>DMA reception requests enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBC</name>
                <description>Slave byte control
This bit is used to enable hardware byte control in slave mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave byte control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave byte control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NOSTRETCH</name>
                <description>Clock stretching disable
This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Clock stretching enabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Clock stretching disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUPEN</name>
                <description>Wakeup from Stop mode enable
Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
Note: WUPEN can be set only when DNF = ‘0000’</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Wakeup from Stop mode disable.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Wakeup from Stop mode enable.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GCEN</name>
                <description>General call enable</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>General call disabled. Address 0b00000000 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>General call enabled. Address 0b00000000 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBHEN</name>
                <description>SMBus host address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Host address disabled. Address 0b0001000x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Host address enabled. Address 0b0001000x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMBDEN</name>
                <description>SMBus device default address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Device default address disabled. Address 0b1100001x is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Device default address enabled. Address 0b1100001x is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ALERTEN</name>
                <description>SMBus alert enable
Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK). </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECEN</name>
                <description>PEC enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PEC calculation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC calculation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FMP</name>
                <description>Fast-mode Plus 20 mA drive enable</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>20 mA I/O drive disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>20 mA I/O drive enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDRACLR</name>
                <description>Address match flag (ADDR) automatic clear</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADDR flag is set by hardware and cleared by software by setting ADDRCF bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADDR flag remains cleared by hardware. This mode can be used in slave mode, to avoid the ADDR clock stretching if the I2C enables only one slave address. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPFACLR</name>
                <description>STOP detection flag (STOPF) automatic clear</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>STOPF flag is set by hardware and cleared by software by setting STOPCF bit.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>STOPF flag remains cleared by hardware. This mode can be used in NOSTRETCH slave mode, to avoid the overrun error if the STOPF flag is not cleared before next data transmission. This allows a slave data management by DMA only, without any interrupt from peripheral.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_CR2</name>
            <displayName>I2C_CR2</displayName>
            <description>I2C control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SADD</name>
                <description>Slave address (master mode)
In 7-bit addressing mode (ADD10 = 0):
SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.
In 10-bit addressing mode (ADD10 = 1):
SADD[9:0] should be written with the 10-bit slave address to be sent.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_WRN</name>
                <description>Transfer direction (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Master requests a write transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master requests a read transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD10</name>
                <description>10-bit addressing mode (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master operates in 7-bit addressing mode,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master operates in 10-bit addressing mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HEAD10R</name>
                <description>10-bit address header only read direction (master receiver mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START</name>
                <description>Start generation
This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.
If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.
Otherwise setting this bit generates a START condition once the bus is free.
Note: Writing ‘0’ to this bit has no effect.
The START bit can be set even if the bus is BUSY or I2C is in slave mode.
This bit has no effect when RELOAD is set.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Start generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Restart/Start generation:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>Stop generation (master mode)
The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.
In Master Mode:
Note: Writing ‘0’ to this bit has no effect.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Stop generation.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Stop generation after current byte transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACK</name>
                <description>NACK generation (slave mode)
The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.
Note: Writing ‘0’ to this bit has no effect.
This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.
When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.
When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an ACK is sent after current received byte.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a NACK is sent after current received byte.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NBYTES</name>
                <description>Number of bytes
The number of bytes to be transmitted/received is programmed there. This field is don’t care in slave mode with SBC=0.
Note: Changing these bits when the START bit is set is not allowed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD</name>
                <description>NBYTES reload mode
This bit is set and cleared by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTOEND</name>
                <description>Automatic end mode (master mode)
This bit is set and cleared by software.
Note: This bit has no effect in slave mode or when the RELOAD bit is set.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PECBYTE</name>
                <description>Packet error checking byte
This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.
Note: Writing ‘0’ to this bit has no effect.
This bit has no effect when RELOAD is set.
This bit has no effect is slave mode when SBC=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No PEC transfer.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PEC transmission/reception is requested</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR1</name>
            <displayName>I2C_OAR1</displayName>
            <description>I2C own address 1 register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA1</name>
                <description>Interface own slave address
7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.
10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.
Note: These bits can be written only when OA1EN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA1MODE</name>
                <description>Own Address 1 10-bit mode
Note: This bit can be written only when OA1EN=0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 is a 7-bit address.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 is a 10-bit address.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA1EN</name>
                <description>Own Address 1 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 1 disabled. The received slave address OA1 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 1 enabled. The received slave address OA1 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_OAR2</name>
            <displayName>I2C_OAR2</displayName>
            <description>I2C own address 2 register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OA2</name>
                <description>Interface address
7-bit addressing mode: 7-bit address
Note: These bits can be written only when OA2EN=0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OA2MSK</name>
                <description>Own Address 2 masks
Note: These bits can be written only when OA2EN=0.
As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No mask</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OA2[1] is masked and don’t care. Only OA2[7:2] are compared.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>OA2[2:1] are masked and don’t care. Only OA2[7:3] are compared.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>OA2[3:1] are masked and don’t care. Only OA2[7:4] are compared.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>OA2[4:1] are masked and don’t care. Only OA2[7:5] are compared.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>OA2[5:1] are masked and don’t care. Only OA2[7:6] are compared.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>OA2[6:1] are masked and don’t care. Only OA2[7] is compared.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>OA2[7:1] are masked and don’t care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OA2EN</name>
                <description>Own Address 2 enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Own address 2 disabled. The received slave address OA2 is NACKed.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Own address 2 enabled. The received slave address OA2 is ACKed.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMINGR</name>
            <displayName>I2C_TIMINGR</displayName>
            <description>I2C timing register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SCLL</name>
                <description>SCL low period (master mode)
This field is used to generate the SCL low period in master mode.
tSCLL = (SCLL+1) x tPRESC
Note: SCLL is also used to generate tBUF and tSU:STA timings.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLH</name>
                <description>SCL high period (master mode)
This field is used to generate the SCL high period in master mode.
tSCLH = (SCLH+1) x tPRESC
Note: SCLH is also used to generate tSU:STO and tHD:STA timing.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SDADEL</name>
                <description>Data hold time
This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL.
tSDADEL= SDADEL x tPRESC
Note: SDADEL is used to generate tHD:DAT timing.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLDEL</name>
                <description>Data setup time
This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL.
tSCLDEL = (SCLDEL+1) x tPRESC
Note: tSCLDEL is used to generate tSU:DAT timing.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESC</name>
                <description>Timing prescaler
This field is used to prescale i2c_ker_ck in order to generate the clock period tPRESC used for data setup and hold counters (refer to ) and for SCL high and low level counters (refer to ).
tPRESC = (PRESC+1) x tI2CCLK</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TIMEOUTR</name>
            <displayName>I2C_TIMEOUTR</displayName>
            <description>I2C timeout register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMEOUTA</name>
                <description>Bus Timeout A
This field is used to configure:
The SCL low timeout condition tTIMEOUT when TIDLE=0
tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK
The bus idle condition (both SCL and SDA high) when TIDLE=1
tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK
Note: These bits can be written only when TIMOUTEN=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIDLE</name>
                <description>Idle clock timeout detection
Note: This bit can be written only when TIMOUTEN=0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMEOUTA is used to detect SCL low timeout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMOUTEN</name>
                <description>Clock timeout enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SCL timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMEOUTB</name>
                <description>Bus timeout B
This field is used to configure the cumulative clock extension timeout:
In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected
In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected
tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK
Note: These bits can be written only when TEXTEN=0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TEXTEN</name>
                <description>Extended clock timeout enable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Extended clock timeout detection is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ISR</name>
            <displayName>I2C_ISR</displayName>
            <description>I2C interrupt and status register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty (transmitters)
This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.
This bit can be written to ‘1’ by software in order to flush the transmit data register I2C_TXDR.
Note: This bit is set by hardware when PE=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TXIS</name>
                <description>Transmit interrupt status (transmitters)
This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register.
This bit can be written to ‘1’ by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1).
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RXNE</name>
                <description>Receive data register not empty (receivers)
This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ADDR</name>
                <description>Address matched (slave mode)
This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>NACKF</name>
                <description>Not Acknowledge received flag
This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STOPF</name>
                <description>Stop detection flag
This flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:
either as a master, provided that the STOP condition is generated by the peripheral.
or as a slave, provided that the peripheral has been addressed previously during this transfer.
It is cleared by software by setting the STOPCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TC</name>
                <description>Transfer Complete (master mode)
This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TCR</name>
                <description>Transfer Complete Reload
This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.
Note: This bit is cleared by hardware when PE=0.
This flag is only for master mode, or for slave mode when the SBC bit is set.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BERR</name>
                <description>Bus error
This flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARLO</name>
                <description>Arbitration lost
This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OVR</name>
                <description>Overrun/Underrun (slave mode)
This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.
Note: This bit is cleared by hardware when PE=0.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>PECERR</name>
                <description>PEC Error in reception
This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Timeout or tLOW detection flag
This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ALERT</name>
                <description>SMBus alert
This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.
Note: This bit is cleared by hardware when PE=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Bus busy
This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE=0.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIR</name>
                <description>Transfer direction (Slave mode)
This flag is updated when an address match event occurs (ADDR=1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Write transfer, slave enters receiver mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Read transfer, slave enters transmitter mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDCODE</name>
                <description>Address match code (Slave mode)
These bits are updated with the received address when an address match event occurs (ADDR = 1).
In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_ICR</name>
            <displayName>I2C_ICR</displayName>
            <description>I2C interrupt clear register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDRCF</name>
                <description>Address matched flag clear
Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NACKCF</name>
                <description>Not Acknowledge flag clear
Writing 1 to this bit clears the NACKF flag in I2C_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>STOPCF</name>
                <description>STOP detection flag clear
Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>BERRCF</name>
                <description>Bus error flag clear
Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARLOCF</name>
                <description>Arbitration lost flag clear
Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>OVRCF</name>
                <description>Overrun/Underrun flag clear
Writing 1 to this bit clears the OVR flag in the I2C_ISR register.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>PECCF</name>
                <description>PEC Error flag clear
Writing 1 to this bit clears the PECERR flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TIMOUTCF</name>
                <description>Timeout detection flag clear
Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ALERTCF</name>
                <description>Alert flag clear
Writing 1 to this bit clears the ALERT flag in the I2C_ISR register.
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_PECR</name>
            <displayName>I2C_PECR</displayName>
            <description>I2C PEC register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PEC</name>
                <description>Packet error checking register
This field contains the internal PEC when PECEN=1.
The PEC is cleared by hardware when PE=0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_RXDR</name>
            <displayName>I2C_RXDR</displayName>
            <description>I2C receive data register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXDATA</name>
                <description>8-bit receive data
Data byte received from the I2C bus</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I2C_TXDR</name>
            <displayName>I2C_TXDR</displayName>
            <description>I2C transmit data register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXDATA</name>
                <description>8-bit transmit data
Data byte to be transmitted to the I2C bus
Note: These bits can be written only when TXE=1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="I2C1">
      <name>I2C2</name>
      <baseAddress>0x40005800</baseAddress>
	  <interrupt>
        <name>I2C2_EV</name>
        <description>I2C2 event interrupt</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>I2C2_ER</name>
        <description>I2C2 error interrupt</description>
        <value>54</value>
      </interrupt>
    </peripheral>
	<peripheral>
        <name>I3C</name>
        <description>Improved inter-integrated circuit</description>
		<groupName>I3C</groupName>
        <baseAddress>0x40005C00</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>I3C1_EV</name>
          <description>I3C1 event interrupt </description>
          <value>123</value>
        </interrupt>
		<interrupt>
          <name>I3C1_ER</name>
          <description>I3C1 error interrupt </description>
          <value>124</value>
        </interrupt>
        <registers>
          <register>
            <name>I3C_CR</name>
            <displayName>I3C_CR</displayName>
            <description>I3C message control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DCNT</name>
                <description>count of data to transfer during a read or write message, in bytes (whatever I3C is acting as controller/target)
Linear encoding up to 64 Kbytes -1
...</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data to transfer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 byte</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 bytes</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xFFFF</name>
                    <description>64 Kbytes - 1 byte</description>
                    <value>0xFFFF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNW</name>
                <description>read / non-write message (when I3C is acting as controller)
When I3C is acting as controller, this field is used if MTYPE[3:0]=0010 (private message) or MTYPE[3:0]=0011 (direct message) or MTYPE[3:0]=0100 (legacy I2C message), in order to emit the RnW bit on the I3C bus.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write message</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>read message</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD</name>
                <description>7-bit I3C dynamic / I2C static target address (when I3C is acting as controller)
When I3C is acting as controller, this field is used if MTYPE[3:0]=0010 (private message) or MTYPE[3:0]=0011 (direct message) or MTYPE[3:0]=0100 (legacy I2C message)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>7</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MTYPE</name>
                <description>message type (whatever I3C is acting as controller/target)
Bits[26:0] are ignored.
After M2 error detection on an I3C SDR message, this is needed for SCL “stuck at” recovery.
Bits[26:0] are ignored.
If I3C_CFGR.EXITPTRN=1, an HDR exit pattern is emitted on the bus to generate an escalation fault.
Bits[23:17] (ADD[6:0]) is the emitted 7-bit dynamic address.
Bit[16] (RNW) is the emitted RnW bit.
The transferred private message is:
{S / S+7’h7E+RnW=0+Sr / Sr+*} + 7-bit DynAddr + RnW + (8-bit Data + T)* + Sr/P.
After a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7’h7E+RnW=0) is inserted or not.
Sr+*: after a Sr (Repeated Start), the hardware automatically inserts (7’h7E+RnW=0) if needed, i.e. if it follows an I3C direct message without ending by a P (Stop).
Bits[23:17] (ADD[6:0]) is the emitted 7-bit dynamic address.
Bit[16] (RNW) is the emitted RnW bit.
The transferred direct message is:
Sr + 7-bit DynAddr + RnW + (8-bit Data + T)* + Sr/P
Bits[23:17] (ADD[6:0]) is the emitted 7-bit static address.
Bit[16] (RNW) is the emitted RnW bit.
The transferred legacy I2C message is:
{S / S+ 7’h7E+RnW=0 + Sr / Sr+*} + 7-bit StaAddr + RnW + (8-bit Data + T)* + Sr/P.
After a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7’h7E+RnW=0) is inserted or not.
Sr+*: after a Sr (Repeated Start), the hardware automatically inserts (7’h7E+RnW=0) if needed, i.e. if it follows an I3C direct message without ending by a P (Stop).
1xxx: reserved (when I3C is acting as I3C controller, used when target)
0xxx: reserved
{S +} 7’h02 addr + RnW=0
{S +} 7-bit I3C_DEVR0.DA[6:0] + RnW=0
after a bus available condition (the target first emits a START request), or once the controller drives a START.
{S +} 7-bit I3C_DEVR0.DA[6:0] + RnW=1 (+Ack/Nack from controller)
When acknowledged from controller, the next (optional, depending on I3C_BCR.BCR2) transmitted IBI payload data is defined by I3C_CR.DCNT[15:0] and must be consistently programmed vs the maximum IBI payload data size which is defined by I3C_IBIDR.IBIP[2:0].
Others: reserved</description>
                <bitOffset>27</bitOffset>
                <bitWidth>4</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>SCL output clock stops running until next control word is executed </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>header message</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>private message</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>direct message (2nd part of an I3C SDR direct CCC command)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>legacy I2C message</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>reserved (for this 1st alternate register description)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8_WHEN_I3C_IS_ACTING_AS_I3C_TARGET</name>
                    <description>hot-join request (W)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9_WHEN_I3C_IS_ACTING_AS_I3C_TARGET</name>
                    <description>controller-role request (W)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA_WHEN_I3C_IS_ACTING_AS_I3C_TARGET</name>
                    <description>IBI (in-band interrupt) request (R)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MEND</name>
                <description>message end type (when the I3C is acting as controller)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>this message from controller ends with a Repeated START (Sr)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>this message from controller ends with a STOP (P), being the last message of a frame</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>I3C_CR_ALTERNATE</name>
            <displayName>I3C_CR_ALTERNATE</displayName>
            <description>I3C message control register alternate</description>
		    <alternateRegister>I3C_CR</alternateRegister>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			  <field>
                <name>DCNT</name>
                <description>count of data to transfer during a read or write message, in bytes (when I3C is acting as controller)
Linear encoding up to 64 Kbytes -1.
...</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data to transfer (allowed for write message and only for GET CCC read commands. Mandated value when emitting ENTDAA)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 byte</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 bytes</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xFFFF</name>
                    <description>64 Kbytes - 1 byte</description>
                    <value>0xFFFF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCC</name>
                <description>8-bit CCC code (when I3C is acting as controller)
If Bit[23]=CCC[7]=1, this is the 1st part of an I3C SDR direct CCC command.
If Bit[23]=CCC[7]=0, this is an I3C SDR broadcast CCC command (including ENTDAA and ENTHDR0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MTYPE</name>
                <description>message type (when I3C is acting as controller)
Bits[23:16] (CCC[7:0]) is the emitted 8-bit CCC code
If Bit[23]=CCC[7]=1: this is the 1st part of an I3C SDR direct CCC command
The transferred direct CCC command message is:
{S / S+7’h7E +RnW=0 / Sr+*} + (direct CCC + T) + (8-bit Data + T)* + Sr
After a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7’h7E+RnW=0) is inserted or not.
Sr+*: after a Sr (Repeated Start), the hardware automatically inserts (7’h7E+R/W).
If Bit[23]=CCC[7]=0: this is an I3C SDR broadcast CCC command (including ENTDAA and ENTHDR0)
The transferred broadcast CCC command message is:
{S / S+7’h7E +RnW=0 / Sr+*} + (broadcast CCC + T) + (8-bit Data + T)* + Sr/P
After a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7’h7E+RnW=0) is inserted or not.
Sr+*: after a Sr (Repeated Start), the hardware automatically inserts (7’h7E+R/W).
others: reserved</description>
                <bitOffset>27</bitOffset>
                <bitWidth>4</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x6_WHEN_I3C_IS_ACTING_AS_I3C_CONTROLLER</name>
                    <description>CCC command</description>
                    <value>0x6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MEND</name>
                <description>message end type (when I3C is acting as controller)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>this message from the controller ends with a Repeated START (Sr)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the message from the controller ends with a STOP (P), being the last message of a frame</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
			</fields>
          </register>
          <register>
            <name>I3C_CFGR</name>
            <displayName>I3C_CFGR</displayName>
            <description>I3C configuration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>I3C enable (whatever I3C is acting as controller/target)
- Except registers, the peripheral is under reset (a.k.a. partial reset).
- Before clearing EN, when I3C is acting as a controller, all the possible target requests must be disabled using DISEC CCC.
- When I3C is acting as a target, software should not disable the I3C, unless a partial reset is needed.
In this state, some register fields can not be modified (like CRINIT, HKSDAEN for the I3C_CFGR)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRINIT</name>
                <description>initial controller/target role
This bit can be modified only when I3C_CFGR.EN = 0.
Once enabled by setting I3C_CFGR.EN = 1, I3C peripheral initially acts as an I3C target. I3C does not drive SCL line and does not enable SDA pull-up, until it eventually acquires the controller role.
Once enabled by setting I3C_CFGR.EN = 1, I3C peripheral initially acts as a controller. It has the I3C controller role, so drives SCL line and enables SDA pull-up, until it eventually offers the controller role to an I3C secondary controller.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>target role</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller role</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NOARBH</name>
                <description>no arbitrable header after a START (when I3C is acting as a controller)
This bit can be modified only when there is no on-going frame.
- The target address is emitted directly after a START in case of a legacy I2C message or an I3C SDR private read/write message.
- This is a more performing option (when is useless the emission of the 0x7E arbitrable header), but this is to be used only when the controller is sure that the addressed target device can not emit concurrently an IBI or a controller-role request (to insure no misinterpretation and no potential conflict between the address emitted by the controller in open-drain mode and the same address a target device can emit after a START, for IBI or MR).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>An arbitrable header (7’h7E + RnW=0) is emitted after a START and before a legacy I2C message or an I3C SDR private read/write message (default).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>No arbitrable header</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RSTPTRN</name>
                <description>HDR reset pattern enable (when I3C is acting as a controller)
This bit can be modified only when there is no on-going frame.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>standard STOP emitted at the end of a frame</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HDR reset pattern is inserted before the STOP of any emitted frame that includes a RSTACT CCC command</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXITPTRN</name>
                <description>HDR Exit Pattern enable (when I3C is acting as a controller)
This bit can be modified only when there is no on-going frame.
This is used to send only the header to test ownership of the bus when there is a suspicion of problem after controller-role hand-off (new controller didn’t assert its controller-role by accessing the previous one in less than Activity State time).
The HDR Exit Pattern is sent even if the message header {S/Sr + 0x7E addr + W } is ACKed.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HDR Exit Pattern is not sent after the message header (MTYPE[3:0]=0001)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HDR Exit Pattern is sent after the message header (MTYPE[3:0]=0001) to generate an escalation fault</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HKSDAEN</name>
                <description>High-keeper enable on SDA line (when I3C is acting as a controller)
This bit can be modified only when I3C_CFGR.EN=0.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>High-Keeper is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>High-Keeper is enabled, and the weak pull-up is effective on the T bit, instead of the open-drain class pull-up.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HJACK</name>
                <description>Hot Join request acknowledge (when I3C is acting as a controller)
After the NACK, the message continues as initially programmed (the hot-joining target is aware of the NACK and surely emits another hot-join request later on).
After the ACK, the message continues as initially programmed. The software is aware by the HJ interrupt (flag I3C_EVR.HJF is set) and initiates the ENTDAA sequence later on, potentially preventing others Hot Join requests with a Disable target events command (DISEC, with DISHJ=1).
Independently of the HJACK configuration, further Hot Join request(s) are NACKed until the Hot Join flag, HJF, is cleared. However, a NACKed target can be assigned a dynamic address by the ENTDAA sequence initiated later on by the first HJ request, preventing this target to emit an HJ request again.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Hot Join request is NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Hot Join request is ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXDMAEN</name>
                <description>RX-FIFO DMA request enable (whatever I3C is acting as controller/target)
- Software reads and pops a data byte/word from RX-FIFO i.e. reads I3C_RDR or I3C_RDWR register.
- A next data byte/word is to be read by the software either via polling on the flag I3C_EVR.RXFNEF=1 or via interrupt notification (enabled by I3C_IER.RXFNEIE=1).
- DMA reads and pops data byte(s)/word(s) from RX-FIFO i.e. reads I3C_RDR or I3C_RDWR register.
- A next data byte/word is automatically read by the programmed hardware (i.e. via the asserted RX-FIFO DMA request from the I3C and the programmed DMA channel).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for RX-FIFO</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for RX-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFLUSH</name>
                <description>RX-FIFO flush (whatever I3C is acting as controller/target)
This bit can only be written.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>flush RX-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXTHRES</name>
                <description>RX-FIFO threshold (whatever I3C is acting as controller/target)
This threshold defines, compared to the RX-FIFO level, when the I3C_EVR.RXFNEF flag is set (and consequently if RXDMAEN=1 when is asserted a DMA RX request).
RXFNEF is set when 1 byte is to be read in RX-FIFO (i.e. in I3C_RDR).
RXFNEF is set when 4 bytes are to be read in RX-FIFO (i.e. in I3C_RDWR).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1-byte threshold</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>4-byte threshold</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>TX-FIFO DMA request enable (whatever I3C is acting as controller/target)
- Software writes and pushes a data byte/word into TX-FIFO i.e. writes I3C_TDR or I3C_TDWR register, to be transmitted over the I3C bus.
- A next data byte/word is to be written by the software either via polling on the flag I3C_EVR.TXFNFF=1 or via interrupt notification (enabled by I3C_IER.TXFNFIE=1).
- DMA writes and pushes data byte(s)/word(s) into TX-FIFO i.e. writes I3C_TDR or I3C_TDWR register.
- A next data byte/word transfer is automatically pushed by the programmed hardware (i.e. via the asserted TX-FIFO DMA request from the I3C and the programmed DMA channel).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for TX-FIFO</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for TX-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFLUSH</name>
                <description>TX-FIFO flush (whatever I3C is acting as controller/target)
This bit can only be written.
When the I3C is acting as target, this bit can be used to flush the TX-FIFO on a private read if the controller has early ended the read data (i.e. driven low the T bit) and there is/are remaining data in the TX-FIFO (i.e. I3C_SR.ABT=1 and I3C_SR.XDCNT[15:0] &lt; I3C_TGTTDR.TGTTDCNT[15:0]).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>flush TX-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXTHRES</name>
                <description>TX-FIFO threshold (whatever I3C is acting as controller/target)
This threshold defines, compared to the TX-FIFO level, when the I3C_EVR.TXFNFF flag is set (and consequently if TXDMAEN=1 when is asserted a DMA TX request).
TXFNFF is set when 1 byte is to be written in TX-FIFO (i.e. in I3C_TDR).
TXFNFF is set when 4 bytes are to be written in TX-FIFO (i.e. in I3C_TDWR).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1-byte threshold</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>4-byte threshold</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SDMAEN</name>
                <description>S-FIFO DMA request enable (when I3C is acting as controller)
Condition: When RMODE=1 (FIFO is enabled for the status):
- Software reads and pops a status word from S-FIFO i.e. reads I3C_SR register after a completed frame (I3C_EVR.FCF=1) or an error (I3C_EVR.ERRF=1).
- A status word can be read by the software either via polling on these register flags or via interrupt notification (enabled by I3C_IER.FCIE=1 and I3C_IER.ERRIE=1).
- DMA reads and pops status word(s) from S-FIFO i.e. reads I3C_SR register.
- Status word(s) are automatically read by the programmed hardware (i.e. via the asserted S-FIFO DMA request from the I3C and the programmed DMA channel).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for S-FIFO</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for S-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SFLUSH</name>
                <description>S-FIFO flush (when I3C is acting as controller)
When I3C is acting as I3C controller, this bit can only be written (and is only used when I3C is acting as controller).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>flush S-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RMODE</name>
                <description>S-FIFO enable / status receive mode (when I3C is acting as controller)
When I3C is acting as I3C controller, this bit is used for the enabling the FIFO for the status (S-FIFO) vs the received status from the target on the I3C bus.
When I3C is acting as target, this bit must be cleared.
- Status register (i.e. I3C_SR) is used without FIFO mechanism.
- There is no SCL stretch if a new status register content is not read.
- Status register must be read before being lost/overwritten.
All message status must be read.
There is SCL stretch when there is no more space in the S-FIFO.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>S-FIFO is disabled, and the </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>S-FIFO is enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TMODE</name>
                <description>transmit mode (when I3C is acting as controller)
When I3C is acting as I3C controller, this bit is used for the C-FIFO and TX-FIFO management vs the emitted frame on the I3C bus.
A frame transfer starts as soon as first control word is present in C-FIFO.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>C-FIFO and TX-FIFO are not preloaded before starting to emit a frame transfer. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>C-FIFO and TX-FIFO are first preloaded (also TX-FIFO if needed (depending on the frame format) before starting to emit a frame transfer.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CDMAEN</name>
                <description>C-FIFO DMA request enable (when I3C is acting as controller)
When I3C is acting as controller:
- Software writes and pushes control word(s) into C-FIFO i.e. writes I3C_CR register, as needed for a given frame.
- A next control word transfer can be written by software either via polling on the flag I3C_EVR.CFNFF=1 or via interrupt notification (enabled by I3C_IER.CFNFIE=1).
- DMA writes and pushes control word(s) into C-FIFO i.e. writes I3C_CR register, as needed for a given frame.
- A next control word transfer is automatically written by the programmed hardware (i.e. via the asserted C-FIFO DMA request from the I3C and the programmed DMA channel).</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for C-FIFO</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for C-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFLUSH</name>
                <description>C-FIFO flush (when I3C is acting as controller)
This bit can only be written.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>flush C-FIFO</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSFSET</name>
                <description>frame transfer set (a.k.a. software trigger) (when I3C is acting as controller)
This bit can only be written.
When I3C is acting as I3C controller:
Note: If this bit is not set, the other alternative for the software to initiate a frame transfer is to directly write the first control word register (i.e. I3C_CR) while C-FIFO is empty (i.e. I3C_EVR.CFEF=1). Then, if the first written control word is not tagged as a message end (i.e I3C_CR.MEND=0), it causes the hardware to assert the flag I3C_EVR.CFNFF (C-FIFO not full and a next control word is needed).</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>setting this bit initiates a frame transfer by causing the hardware to assert the flag I3C_EVR.CFNFF (C-FIFO not full and a control word is needed)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_RDR</name>
            <displayName>I3C_RDR</displayName>
            <description>I3C receive data byte register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDB0</name>
                <description>8-bit received data on I3C bus.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_RDWR</name>
            <displayName>I3C_RDWR</displayName>
            <description>I3C receive data word register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDB0</name>
                <description>8-bit received data (earliest byte on I3C bus).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RDB1</name>
                <description>8-bit received data (next byte after RDB0 on I3C bus).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RDB2</name>
                <description>8-bit received data (next byte after RDB1 on I3C bus).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RDB3</name>
                <description>8-bit received data (latest byte on I3C bus).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TDR</name>
            <displayName>I3C_TDR</displayName>
            <description>I3C transmit data byte register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDB0</name>
                <description>8-bit data to transmit on I3C bus.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TDWR</name>
            <displayName>I3C_TDWR</displayName>
            <description>I3C transmit data word register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDB0</name>
                <description>8-bit transmit data (earliest byte on I3C bus)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TDB1</name>
                <description>8-bit transmit data (next byte after TDB0[7:0] on I3C bus).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TDB2</name>
                <description>8-bit transmit data (next byte after TDB1[7:0] on I3C bus).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TDB3</name>
                <description>8-bit transmit data (latest byte on I3C bus).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_IBIDR</name>
            <displayName>I3C_IBIDR</displayName>
            <description>I3C IBI payload data register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IBIDB0</name>
                <description>8-bit IBI payload data (earliest byte on I3C bus, i.e. MDB[7:0] mandatory data byte).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIDB1</name>
                <description>8-bit IBI payload data (next byte on I3C bus after IBIDB0[7:0]).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIDB2</name>
                <description>8-bit IBI payload data (next byte on I3C bus after IBIDB1[7:0]).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIDB3</name>
                <description>8-bit IBI payload data (latest byte on I3C bus).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TGTTDR</name>
            <displayName>I3C_TGTTDR</displayName>
            <description>I3C target transmit configuration register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TGTTDCNT</name>
                <description>transmit data counter, in bytes (when I3C is configured as target)
This field must be written by software in the same access when is asserted PRELOAD, in order to define the number of bytes to preload and to transmit.
This field is updated by hardware and reports, when read, the remaining number of bytes to be loaded into the TX-FIFO.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRELOAD</name>
                <description>preload of the TX-FIFO (when I3C is configured as target)
This bit must be written and asserted by software in the same access when is written and defined the number of bytes to preload into the TX-FIFO and to transmit.
This bit is cleared by hardware when all the data bytes to transmit are loaded into the TX-FIFO.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TX-FIFO preload</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TX-FIFO preload</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_SR</name>
            <displayName>I3C_SR</displayName>
            <description>I3C status register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>XDCNT</name>
                <description>data counter
- When the I3C is acting as controller: number of targets detected on the bus
- When the I3C is acting as target: number of transmitted bytes
- Whatever the I3C is acting as controller or target: number of data bytes read from or transmitted on the I3C bus during the MID[7:0] message</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ABT</name>
                <description>a private read message is completed/aborted prematurely by the target (when the I3C is acting as controller)
When the I3C is acting as controller, this bit indicates if the private read data which is transmitted by the target early terminates (i.e. the target drives T bit low earlier vs what does expect the controller in terms of programmed number of read data bytes i.e. I3C_CR.DCNT[15:0]).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no early completion/abort from the target</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>early completion/abort from the target</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>message direction
Whatever the I3C is acting as controller or target, this bit indicates the direction of the related message on the I3C bus
Note: ENTDAA CCC is considered as a write command.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>read</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MID</name>
                <description>message identifier/counter of a given frame (when the I3C is acting as controller)
When the I3C is acting as controller, this field identifies the control word message (i.e. I3C_CR) to which the I3C_SR status register refers.
First message of a frame is identified with MID[7:0]=0.
This field is incremented (by hardware) on the completion of a new message control word (i.e. I3C_CR) over I3C bus. This field is reset for every new frame start.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_SER</name>
            <displayName>I3C_SER</displayName>
            <description>I3C status error register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CODERR</name>
                <description>protocol error code/type
controller detected an illegally formatted CCC
controller detected that transmitted data on the bus is different from expected
controller detected a not acknowledged broadcast address (7’hE)
controller detected the new controller did not drive bus after controller-role hand-off
target detected an invalid broadcast address 7’hE+W
target detected a parity error on a CCC code via a parity check (vs T bit)
target detected a parity error on a write data via a parity check (vs T bit)
target detected a parity error on the assigned address during dynamic address arbitration via a parity check (vs PAR bit)
target detected a 7’hE+R missing after Sr during dynamic address arbitration
target detected an illegally formatted CCC
target detected that transmitted data on the bus is different from expected
others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CE0 error (transaction after sending CCC): </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CE1 error (monitoring error): </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CE2 error (no response to broadcast address): </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CE3 error (failed controller-role hand-off): </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>TE0 error (invalid broadcast address 7’hE+W): </description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>TE1 error (CCC code): </description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>TE2 error (write data): </description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>TE3 error (assigned address during dynamic address arbitration): </description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>TE4 error (7’hE+R missing after Sr during dynamic address arbitration): </description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>TE5 error (transaction after detecting CCC): </description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>TE6 error (monitoring error): </description>
                    <value>0xE</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PERR</name>
                <description>protocol error</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>whatever controller or target, hardware detected a protocol error, as detailed in CODERR[3:0]</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STALL</name>
                <description>SCL stall error (when the I3C is acting as target)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>target detected that SCL was stable for more than 125 �s during a I3C SDR read</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DOVR</name>
                <description>RX-FIFO overrun or TX-FIFO underrun
i) a TX-FIFO underrun: TX-FIFO is empty and a write data byte has to be transmitted
ii) a RX-FIFO overrun: RX-FIFO is full and a new data byte is received</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>whatever controller or target, hardware detected either:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COVR</name>
                <description>C-FIFO underrun or S-FIFO overrun (when the I3C is acting as controller)
i) a C-FIFO underrun: control FIFO is empty and a restart has to be emitted
ii) a S-FIFO overrun: S-FIFO is full and a new message ends</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller detected either:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ANACK</name>
                <description>address not acknowledged (when the I3C is configured as controller)
i) a legacy I2C read/write transfer
ii) a direct CCC write transfer
iii) the second trial of a direct CCC read transfer
iv) a private read/write transfer</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller detected that the static/dynamic address was not acknowledged by a target, either during:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DNACK</name>
                <description>data not acknowledged (when the I3C is acting as controller)
i) a legacy I2C write transfer
ii) the second trial when sending dynamic address during ENTDAA procedure</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller detected that a data byte is not acknowledged by a target, either during:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DERR</name>
                <description>data error (when the I3C is acting as controller)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no detected error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller detected a data error during the controller-role hand-off procedure (GETACCCR CCC, formerly known as GETACCMST) when the received target address or/and the parity bit do no match. Active controller keeps controller-role.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_RMR</name>
            <displayName>I3C_RMR</displayName>
            <description>I3C received message register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IBIRDCNT</name>
                <description>IBI received payload data count (when the I3C is configured as controller)
When the I3C is configured as controller, this field logs the number of data bytes effectively received in the I3C_IBIDR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RCODE</name>
                <description>received CCC code (when the I3C is configured as target)
When the I3C is configured as target, this field logs the received CCC code.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RADD</name>
                <description>received target address (when the I3C is configured as controller)
When the I3C is configured as controller, this field logs the received dynamic address from the target during acknowledged IBI or controller-role request.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_EVR</name>
            <displayName>I3C_EVR</displayName>
            <description>I3C event register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000003</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CFEF</name>
                <description>C-FIFO empty flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that the C-FIFO is empty when controller, and that the I3C_CR register contains no control word (i.e. none IBI/CR/HJ request) when target.
This flag is de-asserted by hardware to indicate that the C-FIFO is not empty when controller, and that the I3C_CR register contains one control word (i.e. a pending IBI/CR/HJ request) when target.
Note: When the I3C is acting as controller, if the C-FIFO and TX-FIFO preload is configured (i.e. I3C_CFGR.TMODE=1), the software must wait for TXFEF=1 and CFEF=1 before starting a new frame transfer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFEF</name>
                <description>TX-FIFO empty flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that the TX-FIFO is empty.
This flag is de-asserted by hardware to indicate that the TX-FIFO is not empty.
Note: When the I3C is acting as controller, if the C-FIFO and TX-FIFO preload is configured (i.e. I3C_CFGR.TMODE=1), the software must wait for TXFEF=1 and CFEF=1 before starting a new frame transfer.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CFNFF</name>
                <description>C-FIFO not full flag (when the I3C is acting as controller)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that a control word is to be written to the C-FIFO.
This flag is de-asserted by hardware to indicate that a control word is not to be written to the C-FIFO.
Note: The software must wait for CFNFF=1 (by polling or via the enabled interrupt) before writing to C-FIFO (i.e. writing to I3C_CR).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SFNEF</name>
                <description>S-FIFO not empty flag (when the I3C is acting as controller)
When the I3C is acting as controller, if the S-FIFO is enabled (i.e. I3C_CFGR.RMODE=1), this flag is asserted by hardware to indicate that a status word is to be read from the S-FIFO.
This flag is de-asserted by hardware to indicate that a status word is not to be read from the S-FIFO.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFNFF</name>
                <description>TX-FIFO not full flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that a data byte/word is to be written to the TX-FIFO.
This flag is de-asserted by hardware to indicate that a data byte/word is not to be written to the TX-FIFO.
Note: The software must wait for TXFNFF=1 (by polling or via the enabled interrupt) before writing to TX-FIFO (i.e. writing to I3C_TDR or I3C_TDWR depending on I3C_CFGR.TXTHRES).
Note: When the I3C is acting as target, if the software intends to use the TXFNFF flag for writing into I3C_TDR/I3C_TDWR, it must have configured and set the TX-FIFO preload (i.e. write I3C_TGTTDR.PRELOAD).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXFNEF</name>
                <description>RX-FIFO not empty flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that a data byte is to be read from the RX-FIFO.
This flag is de-asserted by hardware to indicate that a data byte is not to be read from the RX-FIFO.
Note: The software must wait for RXFNEF=1 (by polling or via the enabled interrupt) before reading from RX-FIFO (i.e. writing to I3C_RDR or I3C_RDWR depending on I3C_CFGR.RXTHRES).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXLASTF</name>
                <description>last written data byte/word flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that the last data byte/word (depending on I3C_CFGR.TXTHRES) of a message is to be written to the TX-FIFO.
This flag is de-asserted by hardware when the last data byte/word of a message is written.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXLASTF</name>
                <description>last read data byte/word flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that the last data byte/word (depending on I3C_CFGR.RXTHRES) of a message is to be read from the RX-FIFO.
This flag is de-asserted by hardware when the last data byte/word of a message is read.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FCF</name>
                <description>frame complete flag (whatever the I3C is acting as controller/target)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that a frame has been (normally) completed on the I3C bus, i.e when a stop is issued.
When the I3C is acting as target, this flag is asserted by hardware to indicate that a message addressed to/by this target has been (normally) completed on the I3C bus, i.e when a next stop or repeated start is then issued by the controller.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CFCF bit.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXTGTENDF</name>
                <description>target-initiated read end flag (when the I3C is acting as controller)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that the target has prematurely ended a read transfer.
Then, software should read I3C_SR to get more information on the prematurely read transfer.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CRXTGTENDF bit.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ERRF</name>
                <description>flag (whatever the I3C is acting as controller/target)
This flag is asserted by hardware to indicate that an error occurred.Then, software should read I3C_SER to get the error type.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CERRF bit.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>IBIF</name>
                <description>IBI flag (when the I3C is acting as controller)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that an IBI request has been received.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CIBIF bit.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>IBIENDF</name>
                <description>IBI end flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a IBI transfer has been received and completed (IBI acknowledged and IBI data bytes read by controller if any).
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CIBIENDF bit.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CRF</name>
                <description>controller-role request flag (when the I3C is acting as controller)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that a controller-role request has been acknowledged and completed (by hardware). The software should then issue a GETACCCR CCC (get accept controller role) for the controller-role hand-off procedure.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CCRF bit.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CRUPDF</name>
                <description>controller-role update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that it has now gained the controller role after the completed controller-role hand-off procedure.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CCRUPDF bit.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HJF</name>
                <description>hot-join flag (when the I3C is acting as controller)
When the I3C is acting as controller, this flag is asserted by hardware to indicate that an hot join request has been received.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CHJF bit.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WKPF</name>
                <description>wakeup/missed start flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a start has been detected (i.e. a SDA falling edge followed by a SCL falling edge) but on the next SCL falling edge, the I3C kernel clock is (still) gated. Thus an I3C bus transaction may have been lost by the target.
The corresponding interrupt may be used to wakeup the device from a low power mode (Sleep or Stop mode).
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CWKPF bit.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>GETF</name>
                <description>get flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that any direct CCC of get type (GET*** CCC) has been received.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CGETF bit.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STAF</name>
                <description>get status flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a direct GETSTATUS CCC (get status) has been received.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CSTAF bit.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DAUPDF</name>
                <description>dynamic address update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a dynamic address update has been received via any of the broadcast ENTDAA, RSTDAA and direct SETNEWDA CCC.
Then, software should read I3C_DEVR0.DA[6:0] to get the maximum write length value.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CDAUPDF bit.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MWLUPDF</name>
                <description>maximum write length update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a direct SETMWL CCC (set max write length) has been received.
Then, software should read I3C_MAXWLR.MWL[15:0] to get the maximum write length value.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CMWLUPDF bit.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MRLUPDF</name>
                <description>maximum read length update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a direct SETMRL CCC (set max read length) has been received.
Then, software should read I3C_MAXRLR.MRL[15:0] to get the maximum read length value.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CMRLUPDF bit.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RSTF</name>
                <description>reset pattern flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that a reset pattern has been detected (i.e. 14 SDA transitions while SCL is low, followed by repeated start, then stop).
Then, software should read I3C_DEVR0.RSTACT[1:0] and I3C_DEVR0.RSTVAL, to know what reset level is required.
If RSTVAL=1: when the RSTF is asserted (and/or the corresponding interrupt if enabled), I3C_DEVR0.RSTACT[1:0] dictates the reset action to be performed by the software if any.
If RSTVAL=0: when the RSTF is asserted (and/or the corresponding interrupt if enabled), the software should issue an I3C reset after a first detected reset pattern, and a system reset on the second one.
The corresponding interrupt may be used to wakeup the device from a low power mode (Sleep or Stop mode).
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CRSTF bit.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ASUPDF</name>
                <description>activity state update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that the direct or broadcast ENTASx CCC (with x=0...3) has been received.
Then, software should read I3C_DEVR0.AS[1:0].
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CASUPDF bit.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>INTUPDF</name>
                <description>interrupt/controller-role/hot-join update flag (when the I3C is acting as target)
When the I3C is acting as target, this flag is asserted by hardware to indicate that the direct or broadcast ENEC/DISEC CCC (enable/disable target events) has been received, where a target event is either an interrupt/IBI request, a controller-role request, or an hot-join request.
Then, software should read respectively I3C_DEVR0.IBIEN, I3C_DEVR0.CREN or I3C_DEVR0.HJEN.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CINTUPDF bit.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DEFF</name>
                <description>DEFTGTS flag (when the I3C is acting as target)
When the I3C is acting as target (and is typically controller capable), this flag is asserted by hardware to indicate that the broadcast DEFTGTS CCC (define list of targets) has been received.
Then, software may store the received data for when getting the controller role.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CDEFF bit.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>GRPF</name>
                <description>group addressing flag (when the I3C is acting as target)
When the I3C is acting as target (and is typically controller capable), this flag is asserted by hardware to indicate that the broadcast DEFGRPA CCC (define list of group addresses) has been received.
Then, software may store the received data for when getting the controller role.
This flag is cleared when software writes 1 into corresponding I3C_CEVR.CGRPF bit.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_IER</name>
            <displayName>I3C_IER</displayName>
            <description>I3C interrupt enable register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CFNFIE</name>
                <description>C-FIFO not full interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SFNEIE</name>
                <description>S-FIFO not empty interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFNFIE</name>
                <description>TX-FIFO not full interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNEIE</name>
                <description>RX-FIFO not empty interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FCIE</name>
                <description>frame complete interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXTGTENDIE</name>
                <description>target-initiated read end interrupt enable (when the I3C is acting as controller)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRIE</name>
                <description>error interrupt enable (whatever the I3C is acting as controller/target)</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIIE</name>
                <description>IBI request interrupt enable (when the I3C is acting as controller)</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIENDIE</name>
                <description>IBI end interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRIE</name>
                <description>controller-role request interrupt enable (when the I3C is acting as controller)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRUPDIE</name>
                <description>controller-role update interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HJIE</name>
                <description>hot-join interrupt enable (when the I3C is acting as controller)</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WKPIE</name>
                <description>wakeup interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GETIE</name>
                <description>GETxxx CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STAIE</name>
                <description>GETSTATUS CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAUPDIE</name>
                <description>ENTDAA/RSTDAA/SETNEWDA CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MWLUPDIE</name>
                <description>SETMWL CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MRLUPDIE</name>
                <description>SETMRL CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RSTIE</name>
                <description>reset pattern interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ASUPDIE</name>
                <description>ENTASx CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>INTUPDIE</name>
                <description>ENEC/DISEC CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEFIE</name>
                <description>DEFTGTS CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GRPIE</name>
                <description>DEFGRPA CCC interrupt enable (when the I3C is acting as target)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_CEVR</name>
            <displayName>I3C_CEVR</displayName>
            <description>I3C clear event register </description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CFCF</name>
                <description>clear frame complete flag (whatever the I3C is acting as controller/target)</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.FCF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRXTGTENDF</name>
                <description>clear target-initiated read end flag (when the I3C is acting as controller)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.RXTGTENDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CERRF</name>
                <description>clear error flag (whatever the I3C is acting as controller/target)</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.ERRF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CIBIF</name>
                <description>clear IBI request flag (when the I3C is acting as controller)</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.IBIF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CIBIENDF</name>
                <description>clear IBI end flag (when the I3C is acting as target)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.IBIENDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCRF</name>
                <description>clear controller-role request flag (when the I3C is acting as controller)</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.CRF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCRUPDF</name>
                <description>clear controller-role update flag (when the I3C is acting as target)</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.CRUPDF </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHJF</name>
                <description>clear hot-join flag (when the I3C is acting as controller)</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.HJF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CWKPF</name>
                <description>clear wakeup flag (when the I3C is acting as target)</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.WKPF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CGETF</name>
                <description>clear GETxxx CCC flag (when the I3C is acting as target)</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.GETF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSTAF</name>
                <description>clear GETSTATUS CCC flag (when the I3C is acting as target)</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.STAF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CDAUPDF</name>
                <description>clear ENTDAA/RSTDAA/SETNEWDA CCC flag (when the I3C is acting as target)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.DAUPDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMWLUPDF</name>
                <description>clear SETMWL CCC flag (when the I3C is acting as target)</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.MWLUPDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMRLUPDF</name>
                <description>clear SETMRL CCC flag (when the I3C is acting as target)</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.MRLUPDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRSTF</name>
                <description>clear reset pattern flag (when the I3C is acting as target)</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.RSTF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CASUPDF</name>
                <description>clear ENTASx CCC flag (when the I3C is acting as target)</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.ASUPDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CINTUPDF</name>
                <description>clear ENEC/DISEC CCC flag (when the I3C is acting as target)</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.CINTUPDF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CDEFF</name>
                <description>clear DEFTGTS CCC flag (when the I3C is acting as target)</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.DEFF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CGRPF</name>
                <description>clear DEFGRPA CCC flag (when the I3C is acting as target)</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clear I3C_EVR.GRPF</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DEVR0</name>
            <displayName>I3C_DEVR0</displayName>
            <description>I3C own device characteristics register </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAVAL</name>
                <description>dynamic address is valid (when the I3C is acting as target)
When the I3C is acting as controller, this field can be written by software, for validating its own dynamic address, for example before a controller-role hand-off.
When the I3C is acting as target, this field is asserted by hardware on the acknowledge of the broadcast ENTDAA CCC or the direct SETNEWDA CCC, and this field is cleared by hardware on the acknowledge of the broadcast RSTDAA CCC.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DA</name>
                <description>7-bit dynamic address
When the I3C is acting as controller, this field can be written by software, for defining its own dynamic address.
When the I3C is acting as target, this field is updated by hardware on the reception of either the broadcast ENTDAA CCC or the direct SETNEWDA CCC.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIEN</name>
                <description>IBI request enable (when the I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISINT=1 (i.e. cleared) and the reception of ENEC CCC with ENINT=1 (i.e. set).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>IBI request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>IBI request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CREN</name>
                <description>controller-role request enable (when the I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISCR=1 (i.e. cleared) and the reception of ENEC CCC with ENCR=1 (i.e. set).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>controller-role request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>controller-role request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HJEN</name>
                <description>hot-join request enable (when the I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISHJ=1 (i.e. cleared) and the reception of ENEC CCC with ENHJ=1 (i.e. set).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>hot-join request disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>hot-join request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AS</name>
                <description>activity state (when the I3C is acting as target)
This read field is updated by hardware on the reception of a ENTASx CCC (enter activity state, with x=0-3):</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>activity state 0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>activity state 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>activity state 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>activity state 3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RSTACT</name>
                <description>reset action/level on received reset pattern (when the I3C is acting as target)
This read field is used by hardware on the reception of a direct read RSTACT CCC in order to return the corresponding data byte on the I3C bus.
This read field is updated by hardware on the reception of a broadcast or direct write RSTACT CCC (target reset action).
Only the defining bytes 0x00, 0x01 and 0x02 are mapped, and RSTACT[1:0] = Defining Byte[1:0].
a) partially reset the I3C peripheral, by a write and clear of the enable bit of the i3C
configuration register (i.e. write I3C_CFGR.EN=0). This reset the I3C bus interface
and the I3C kernel sub-parts, without modifying the content of the I3C APB registers
(excepted the I3C_CFGR.EN bit).
b) reset fully the I3C peripheral including all its registers via a write and set to the I3C
reset control bit of the RCC (Reset and Clock Controller) register.
a system reset. This has the same impact as a pin reset (i.e. NRST=0) (refer to RCC functional description - Reset part):
– the software writes and set the AICR.SYSRESETREQ register control bit, when the
device is controlled by a CortexTM-M.
– the software writes and set the RCC_GRSTCSETR.SYSRST=1, when the device is
controlled by a CortexTM-A.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no reset action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>first level of reset: the application software should either:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>second level of reset: the application software should issue a warm reset, also known as</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>no reset action</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RSTVAL</name>
                <description>reset action is valid (when the I3C is acting as target)
This read bit is asserted by hardware to indicate that the RTSACT[1:0] field has been updated on the reception of a broadcast or direct write RSTACT CCC (target reset action) and is valid.
This field is cleared by hardware when the target receives a frame start.
If RSTVAL=1: when the RSTF is asserted (and/or the corresponding interrupt if enabled), I3C_DEVR0.RSTACT[1:0] dictates the reset action to be performed by the software if any.
If RSTVAL=0: when the RSTF is asserted (and/or the corresponding interrupt if enabled), the software should issue an I3C reset after a first detected reset pattern, and a system reset on the second one.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DEVR1</name>
            <displayName>I3C_DEVR1</displayName>
            <description>I3C device 1 characteristics register</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>assigned I3C dynamic address to target x (when the I3C is acting as controller)
When the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIACK</name>
                <description>IBI request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:
- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.
- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;
- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an IBI request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an IBI request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRACK</name>
                <description>controller-role request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:
After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.
- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a controller-role request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a controller-role request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIDEN</name>
                <description>IBI data enable (when the I3C is acting as controller)
When the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data byte follows the acknowledged IBI from target x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the mandatory data byte MDB[7:0] follows the acknowledged IBI from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3’b101).
If this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C transfer is not stopped and C-FIFO is not flushed </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C transfer is stopped and C-FIFO is flushed on a received IBI request from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS</name>
                <description>DA[6:0] write disabled (when the I3C is acting as controller)
When the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.
Then, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write to I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is disabled/locked </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DEVR2</name>
            <displayName>I3C_DEVR2</displayName>
            <description>I3C device 2 characteristics register</description>
            <addressOffset>0x68</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>assigned I3C dynamic address to target x (when the I3C is acting as controller)
When the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIACK</name>
                <description>IBI request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:
- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.
- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;
- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an IBI request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an IBI request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRACK</name>
                <description>controller-role request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:
After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.
- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a controller-role request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a controller-role request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIDEN</name>
                <description>IBI data enable (when the I3C is acting as controller)
When the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data byte follows the acknowledged IBI from target x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the mandatory data byte MDB[7:0] follows the acknowledged IBI from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3’b101).
If this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C transfer is not stopped and C-FIFO is not flushed </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C transfer is stopped and C-FIFO is flushed on a received IBI request from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS</name>
                <description>DA[6:0] write disabled (when the I3C is acting as controller)
When the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.
Then, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write to I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is disabled/locked </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DEVR3</name>
            <displayName>I3C_DEVR3</displayName>
            <description>I3C device 3 characteristics register</description>
            <addressOffset>0x6c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>assigned I3C dynamic address to target x (when the I3C is acting as controller)
When the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIACK</name>
                <description>IBI request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:
- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.
- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;
- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an IBI request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an IBI request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRACK</name>
                <description>controller-role request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:
After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.
- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a controller-role request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a controller-role request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIDEN</name>
                <description>IBI data enable (when the I3C is acting as controller)
When the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data byte follows the acknowledged IBI from target x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the mandatory data byte MDB[7:0] follows the acknowledged IBI from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3’b101).
If this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C transfer is not stopped and C-FIFO is not flushed </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C transfer is stopped and C-FIFO is flushed on a received IBI request from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS</name>
                <description>DA[6:0] write disabled (when the I3C is acting as controller)
When the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.
Then, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write to I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is disabled/locked </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DEVR4</name>
            <displayName>I3C_DEVR4</displayName>
            <description>I3C device 4 characteristics register</description>
            <addressOffset>0x70</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DA</name>
                <description>assigned I3C dynamic address to target x (when the I3C is acting as controller)
When the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIACK</name>
                <description>IBI request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:
- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.
- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;
- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>an IBI request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>an IBI request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRACK</name>
                <description>controller-role request acknowledge (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:
After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)
- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.
- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.
- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>a controller-role request from target x is to be NACKed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a controller-role request (with 7-bit dynamic address DA[6:0]) from target x is to be ACKed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBIDEN</name>
                <description>IBI data enable (when the I3C is acting as controller)
When the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.
Writing to this field has no impact when the read field I3C_DEVRx.DIS=1.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data byte follows the acknowledged IBI from target x</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the mandatory data byte MDB[7:0] follows the acknowledged IBI from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)
When the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3’b101).
If this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C transfer is not stopped and C-FIFO is not flushed </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C transfer is stopped and C-FIFO is flushed on a received IBI request from target x</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS</name>
                <description>DA[6:0] write disabled (when the I3C is acting as controller)
When the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.
Then, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>write to I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>write I3C_DEVRx.DA[7:0] and to I3C_DEVRx.IBIDEN is disabled/locked </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_MAXRLR</name>
            <displayName>I3C_MAXRLR</displayName>
            <description>I3C maximum read length register </description>
            <addressOffset>0x90</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MRL</name>
                <description>maximum data read length (when I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0 and updated by hardware on the reception of SETMRL command (with potentially also updated IBIP[2:0]).
Software is notified of a MRL update by the I3C_EVR.MRLUPF and the corresponding interrupt if enabled.
This field is used by hardware to return the value on the I3C bus when the target receives a GETMRL CCC.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIP</name>
                <description>IBI payload data size, in bytes (when I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0 to set the number of data bytes to be sent to the controller after an IBI request has been acknowledged.This field may be updated by hardware on the reception of SETMRL command (which potentially also updated IBIP[2:0]).
Software is notified of a MRL update by the I3C_EVR.MRLUPF and the corresponding interrupt if enabled.
others: same as 100</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>null payload data size (only allowed when IC3_BCR.BCR2=0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 byte (i.e. mandatory data byte MDB[7:0]</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 bytes (including first MDB[7:0])</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>3 bytes (including first MDB[7:0])</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>4 bytes (including first MDB[7:0])</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_MAXWLR</name>
            <displayName>I3C_MAXWLR</displayName>
            <description>I3C maximum write length register </description>
            <addressOffset>0x94</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MWL</name>
                <description>maximum data write length (when I3C is acting as target)
This field is initially written by software when I3C_CFGR.EN=0 and updated by hardware on the reception of SETMWL command.
Software is notified of a MWL update by the I3C_EVR.MWLUPF and the corresponding interrupt if enabled.
This field is used by hardware to return the value on the I3C bus when the target receives a GETMWL CCC.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TIMINGR0</name>
            <displayName>I3C_TIMINGR0</displayName>
            <description>I3C timing register 0 </description>
            <addressOffset>0xa0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SCLL_PP</name>
                <description>SCL low duration in I3C push-pull phases, in number of kernel clocks cycles:
tSCLL_PP = (SCLL_PP + 1) x tI3CCLK
SCLL_PP is used to generate tLOW (I3C) timing.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLH_I3C</name>
                <description>SCL high duration, used for I3C messages (both in push-pull and open-drain phases), in number of kernel clocks cycles:
tSCLH_I3C = (SCLH_I3C + 1) x tI3CCLK
SCLH_I3C is used to generate both tHIGH (I3C) and tHIGH_MIXED timings.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLL_OD</name>
                <description>SCL low duration in open-drain phases, used for legacy I2C commands and for I3C open-drain phases (address header phase following a START, not a Repeated START), in number of kernel clocks cycles:
tSCLL_OD = (SCLL_OD + 1) x tI3CCLK
SCLL_OD is used to generate both tLOW (I2C) and tLOW_OD timings (max. of the two).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SCLH_I2C</name>
                <description>SCL high duration, used for legacy I2C commands, in number of kernel clocks cycles:
tSCLH_I2C = (SCLH_I2C + 1) x tI3CCLK
SCLH_I2C is used to generate tHIGH (I2C) timing.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TIMINGR1</name>
            <displayName>I3C_TIMINGR1</displayName>
            <description>I3C timing register 1 </description>
            <addressOffset>0xa4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AVAL</name>
                <description>number of kernel clock cycles, that is used whatever I3C is acting as controller or target, to set the following MIPI I3C timings, like bus available condition time:
When the I3C is acting as target:
for bus available condition time: it must wait for (bus available condition) time to be elapsed after a stop and before issuing a start request for an IBI or a controller-role request (i.e. bus free condition is sustained for at least tAVAL). refer to MIPI timing tAVAL = 1 �s. This timing is defined by:
tAVAL = (AVAL[7:0] + 2) x tI3CCLK
for bus idle condition time: it must wait for (bus idle condition) time to be elapsed after that both SDA and SCL are continuously high and stable before issuing a hot-join event. Refer to MIPI v1.1 timing tIDLE = 200 �s . This timing is defined by:
tIDLE = (AVAL[7:0] + 2) x 200 x tI3CCLK
When the I3C is acting as controller, it can not stall the clock beyond a maximum stall time (i.e. stall the SCL clock low), as follows:
on first bit of assigned address during dynamic address assignment: it can not stall the clock beyond the MIPI timing tSTALLDAA = 15 ms. This timing is defined by:
tSTALLDAA = (AVAL[7:0] + 1) x 15000 x tI3CCLK
on ACK/NACK phase of I3C/I2C transfer, on parity bit of write data transfer, on transition bit of I3C read transfer: it can not stall the clock beyond the MIPI timing tSTALL = 100 �s. This timing is defined by:
tSTALL = (AVAL[7:0] + 1) x 100 x tI3CCLK
Whatever the I3C is acting as controller or as (controller-capable) target, during a controller-role hand-off procedure:
The new controller must wait for a time (refer to MIPI timing tNEWCRLock) before pulling SDA low (i.e. issuing a start). And the active controller must wait for the same time while monitoring new controller and before testing the new controller by pulling SDA low. This time to wait is dependent on the defined I3C_TIMINGR1.ANSCR[1:0], as follows:
If ASNCR[1:0]=00: tNEWCRLock = (AVAL[7:0] + 1)  x tI3CCLK
If ASNCR[1:0]=01: tNEWCRLock = (AVAL[7:0] + 1) x 100 x tI3CCLK
If ASNCR[1:0]=10: tNEWCRLock = (AVAL[7:0] + 1) x 2000 x tI3CCLK
If ASNCR[1:0]=11: tNEWCRLock = (AVAL[7:0] + 1) x 50000 x tI3CCLK</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ASNCR</name>
                <description>activity state of the new controller (when I3C is acting as - active- controller)
This field indicates the time to wait before being accessed as new target, refer to the other field AVAL[7:0].
This field can be modified only when the I3C is acting as controller.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FREE</name>
                <description>number of kernel clocks cycles that is used to set some MIPI timings like bus free condition time (when the I3C is acting as controller)
When the I3C is acting as controller:
for I3C start timing: it must wait for (bus free condition) time to be elapsed after a stop and before a start, refer to MIPI timings (I3C) tCAS and (I2C) tBUF. These timings are defined by:
tBUF= tCAS = [ (FREE[6:0]  + 1) x 2 - (0,5 + SDA_HD)] x tI3CCLK
Note: for pure I3C bus: tCASmin= 38,4 ns.
Note: for pure I3C bus: tCASmax=1�s, 100�s, 2ms, 50ms for respectively ENTAS0,1,2, and 3.
Note: for mixed bus with I2C fm+ device: tBUFmin = 0,5 �s.
Note: for mixed bus with I2C fm device: tBUFmin = 1,3 �s.
for I3C repeated start timing: it must wait for time to be elapsed after a repeated start (i.e. SDA is de-asserted) and before driving SCL low, refer to. MIPI timing tCASr. This timing is defined by:
tCASr = [ (FREE[6:0] + 1) x 2 - (0,5 + SDA_HD)] x tI3CCLK
for I3C stop timing: it must wait for time to be elapsed after that the SCL clock is driven high and before the stop condition (i.e. SDA is asserted). This timing is defined by:
tCBP = (FREE[6:0] + 1) x tI3CCLK
for I3C repeated start timing (T-bit when controller ends read with repeated start followed by stop): it must wait for time to be elapsed after that the SCL clock is driven high and before the repeated start condition (i.e. SDA is de-asserted). This timing is defined by:
tCBSr = (FREE[6:0] + 1) x tI3CCLK</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SDA_HD</name>
                <description>SDA hold time (when the I3C is acting as controller), in number of kernel clocks cycles (refer to MIPI timing SDA hold time in push-pull tHD_PP):</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SDA hold time = 0,5 x tI3CCLK</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SDA hold time = 1,5 x tI3CCLK</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_TIMINGR2</name>
            <displayName>I3C_TIMINGR2</displayName>
            <description>I3C timing register 2 </description>
            <addressOffset>0xa8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STALLT</name>
                <description>Controller clock stall on T-bit phase of Data enable
The SCL is stalled during STALL x tSCLL_PP in the T-bit phase (before 9th bit). This allows the target to prepare data to be sent.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STALLD</name>
                <description>controller clock stall on PAR phase of Data enable
The SCL is stalled during STALL x tSCLL_PP in the T-bit phase (before 9th bit). This allows the target to read received data.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STALLC</name>
                <description>controller clock stall on PAR phase of CCC enable
The SCL is stalled during STALL x tSCLL_PP in the T-bit phase of common command code (before 9th bit). This allows the target to decode the command.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STALLA</name>
                <description>controller clock stall enable on ACK phase
The SCL is stalled (during tSCLL_STALLas defined by STALL)  in the address ACK/NACK phase (before 9th bit). This allows the target to prepare data or the controller to respond to target interrupt.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no stall</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>stall enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STALL</name>
                <description>controller clock stall time, in number of kernel clock cycles
tSCLL_STALL = STALL x tI3CCLK</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_BCR</name>
            <displayName>I3C_BCR</displayName>
            <description>I3C bus characteristics register </description>
            <addressOffset>0xc0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BCR0</name>
                <description>max data speed limitation</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no limitation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>limitation, as described by I3C_GETMXDSR.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BCR2</name>
                <description>in-band interrupt (IBI) payload</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no data byte follows the accepted IBI</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>at least one mandatory data byte follows the accepted IBI (and at most 4 data bytes)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BCR6</name>
                <description>controller capable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C target (no controller capable)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C controller capable</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_DCR</name>
            <displayName>I3C_DCR</displayName>
            <description>I3C device characteristics register </description>
            <addressOffset>0xc4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DCR</name>
                <description>device characteristics ID
others: ID to describe the type of the I3C sensor/device
Note: The latest MIPI DCR ID assignments are available at: https://www.mipi.org/MIPI_I3C_device_characteristics_register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>generic device (for v1.0 devices)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_GETCAPR</name>
            <displayName>I3C_GETCAPR</displayName>
            <description>I3C get capability register </description>
            <addressOffset>0xc8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPEND</name>
                <description>IBI MDB support for pending read notification
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates the support (or not) of the pending read notification via the IBI MDB[7:0] value.
This bit is used to return the GETCAP3 byte in response to the GETCAPS CCC format 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>this I3C when acting as target sends an IBI request without a mandatory data byte value indicating a pending read notification</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>this I3C when acting as target sends an IBI request with a mandatory data byte value (i.e. a MDB[7:5]=101) indicating a pending read notification</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_CRCAPR</name>
            <displayName>I3C_CRCAPR</displayName>
            <description>I3C controller-role capability register </description>
            <addressOffset>0xcc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPDHOFF</name>
                <description>delayed controller-role hand-off
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates if this target I3C may need additional time to process a controller-role hand-off requested by the current controller.
This bit is used to return the CRCAP2 byte in response to the GETCAPS CCC format 2.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>this I3C does not needs additional time to process a controller-role hand-off</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>this I3C needs additional time to process a controller-role hand-off</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CAPGRP</name>
                <description>group management support (when acting as controller)
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates if the I3C is able to support group management when it acts as a controller (after controller-role hand-off) via emitted DEFGRPA, RSTGRPA, and SETGRPA CCC.
This bit is used to return the CRCAP1 byte in response to the GETCAPS CCC format 2.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>this I3C does not support group address capabilities</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>this I3C supports group address capabilities (when becoming controller)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_GETMXDSR</name>
            <displayName>I3C_GETMXDSR</displayName>
            <description>I3C get capability register </description>
            <addressOffset>0xd0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HOFFAS</name>
                <description>controller hand-off activity state
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates in which initial activity state the (other) current controller should expect the I3C bus after a controller-role hand-off to this controller-capable I3C, when returning the defining byte CRHDLY (0x91) to a GETMXDS CCC.
This 2-bit field is used to return the CRHDLY1 byte in response to the GETCAPS CCC format 3, in order to state which is the activity state of this I3C when becoming controller after a controller-role hand-off, and consequently the time the former controller should wait before testing this I3C to be confirmed its ownership.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>activity state 0 is the initial activity state of this I3C before and when becoming controller</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>activity state 1 is the initial activity state of this I3C when becoming controller</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>activity state 2 is the initial activity state of this I3C when becoming controller</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>activity state 3 is the initial activity state of this I3C when becoming controller</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FMT</name>
                <description>GETMXDS CCC format
This field is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates how is returned the GETMXDS format 1 (without MaxRdTurn) and format 2 (with MaxRdTurn).
This bit is used to return the 2-byte format 1 (MaxWr, MaxRd) or 5-byte format 2 (MaxWr, MaxRd, 3-byte MaxRdTurn) byte in response to the GETCAPS CCC.
- 3-byte MaxRdTurn is returned with MSB=0, middle byte=0 and LSB=RDTURN[7:0].
- Max read turnaround time is less than 256 �s.
- 3-byte MaxRdTurn is returned with MSB=0, middle byte=RDTURN[7:0] and LSB=0.
- Max read turnaround time is between 256 �s and 65535 �s
- 3-byte MaxRdTurn is returned with MSB=RDTURN[7:0], middle byte=0 and LSB=0.
- Max read turnaround time is between 65535 �s and 16 s.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>format 1 (2 bytes with MaxWr with no defining byte, MaxRd)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>format 2: (5 bytes with MaxWr with no defining byte, MaxRd, MaxRdTurn)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>format 2 (5 bytes with MaxWr with no defining byte, MaxRd, and middle byte of MaxRdTurn)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>format 2 (5 bytes with MaxWr with no defining byte, MaxRd, MSB of MaxRdTurn)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RDTURN</name>
                <description>programmed byte of the 3-byte MaxRdTurn (maximum read turnaround byte)
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and writes the value of the selected byte (via the FMT[1:0] field) of the 3-byte MaxRdTurn which is returned in response to the GETMXDS CCC format 2 to encode the maximum read turnaround time.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TSCO</name>
                <description>clock-to-data turnaround time (tSCO)
This bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and is used to specify the clock-to-data turnaround time tSCO (vs the value of 12 ns). This bit is used by the hardware in response to the GETMXDS CCC to return the encoded clock-to-data turnaround time via the returned MaxRd[5:3] bits.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tSCO &lt;= 12 ns</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tSCO &gt; 12 ns (and refer to the datasheet for more details)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>I3C_EPIDR</name>
            <displayName>I3C_EPIDR</displayName>
            <description>I3C extended provisioned ID register </description>
            <addressOffset>0xd4</addressOffset>
            <size>0x20</size>
            <resetValue>0x02080000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MIPIID</name>
                <description>4-bit MIPI Instance ID
This field is written by software to set and identify individually each instance of this I3C IP with a specific number on a single I3C bus.
This field represents the bits[15:12] of the 48-bit provisioned ID.
Note: The bits[11:0] of the provisioned ID may be 0.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IDTSEL</name>
                <description>provisioned ID type selector
This field is set as 0 i.e. vendor fixed value.
This field represents the bit[32] of the 48-bit provisioned ID.
Note: The bits[31:16] of the provisioned ID may be 0.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MIPIMID</name>
                <description>15-bit MIPI manufacturer ID
This read field is the 15-bit STMicroelectronics MIPI ID i.e. 0x0104.
This field represents the bits[47:33] of the 48-bit provisioned ID.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>LPTIM1</name>
        <description>Low power timer</description>
        <groupName>LPTIM</groupName>
        <baseAddress>0x44004400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>LPTIM1</name>
          <description>LPTIM1 global interrupt</description>
          <value>64</value>
        </interrupt>
        <registers>
         <register>
            <name>LPTIM_ISR_output</name>
            <displayName>LPTIM_ISR_output</displayName>
            <description>LPTIM1 interrupt and status register [alternate]</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1IF</name>
                <description>Compare 1 interrupt flag
If channel CC1 is configured as output:
The CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR1 register's value</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARRM</name>
                <description>Autoreload match
ARRM is set by hardware to inform application that LPTIM_CNT register’s value reached the LPTIM_ARR register’s value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTTRIG</name>
                <description>External trigger edge event
EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CMP1OK</name>
                <description>Compare register 1 update OK
CMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARROK</name>
                <description>Autoreload register update OK
ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>UP</name>
                <description>Counter direction change down to up
In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DOWN</name>
                <description>Counter direction change up to down
In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>UE</name>
                <description>LPTIM update event occurred
UE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REPOK</name>
                <description>Repetition register update OK
REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Compare 2 interrupt flag
If channel CC2 is configured as output:
The CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the
compare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No match</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The content of the counter LPTIM_CNT register value has matched the LPTIM_CCR2 register's value</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMP2OK</name>
                <description>Compare register 2 update OK
CMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIEROK</name>
                <description>Interrupt enable register update OK
DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>LPTIM_ISR_intput</name>
            <displayName>LPTIM_ISR_intput</displayName>
            <description>LPTIM1 interrupt and status register [alternate]</description>
            <alternateRegister>LPTIM_ISR_output</alternateRegister>
			<addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>CC1IF</name>
                <description>capture 1 interrupt flag
If channel CC1 is configured as input:
CC1IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR1 register. The corresponding interrupt or DMA request is generated if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in the LPTIM_CCR1 register. (An edge has been detected on IC1 which matches the selected polarity). The CC1IF flag is automatically cleared by hardware once the captured value is read (CPU or DMA).CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARRM</name>
                <description>Autoreload match
ARRM is set by hardware to inform application that LPTIM_CNT register’s value reached the LPTIM_ARR register’s value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXTTRIG</name>
                <description>External trigger edge event
EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ARROK</name>
                <description>Autoreload register update OK
ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>UP</name>
                <description>Counter direction change down to up
In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DOWN</name>
                <description>Counter direction change up to down
In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>UE</name>
                <description>LPTIM update event occurred
UE is set by hardware to inform application that an update event was generated. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REPOK</name>
                <description>Repetition register update OK
REPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Capture 2 interrupt flag
If channel CC2 is configured as input:
CC2IF is set by hardware to inform application that the current value of the counter is captured in LPTIM_CCR2 register. The corresponding interrupt or DMA request is generated if enabled. The CC2OF flag is set if the CC2IF flag was already high.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in the LPTIM_CCR2 register. (An edge has been detected on IC2 which matches the selected polarity). The CC2IF flag is automatically cleared by hardware once the captured value is read (CPU or DMA). The CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture 1 over-capture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC1OCF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No over-capture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in LPTIM_CCR1 register while CC1IF flag was already set. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OF</name>
                <description>Capture 2 over-capture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing 1 to the CC2OCF bit in the LPTIM_ICR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No over-capture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in LPTIM_CCR2 register while CC2IF flag was already set. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIEROK</name>
                <description>Interrupt enable register update OK
DIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
			</fields>
          </register>
          <register>
            <name>LPTIM_ICR_output</name>
            <displayName>LPTIM_ICR_output</displayName>
            <description>LPTIM1 interrupt clear register [alternate]</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1CF</name>
                <description>Capture/compare 1 clear flag
Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARRMCF</name>
                <description>Autoreload match clear flag
Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EXTTRIGCF</name>
                <description>External trigger valid edge clear flag
Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMP1OKCF</name>
                <description>Compare register 1 update OK clear flag
Writing 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARROKCF</name>
                <description>Autoreload register update OK clear flag
Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UPCF</name>
                <description>Direction change to UP clear flag
Writing 1 to this bit clear the UP flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DOWNCF</name>
                <description>Direction change to down clear flag
Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UECF</name>
                <description>Update event clear flag
Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>REPOKCF</name>
                <description>Repetition register update OK clear flag
Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC2CF</name>
                <description>Capture/compare 2 clear flag
Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMP2OKCF</name>
                <description>Compare register 2 update OK clear flag
Writing 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DIEROKCF</name>
                <description>Interrupt enable register update OK clear flag
Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>LPTIM_ICR_intput</name>
            <displayName>LPTIM_ICR_intput</displayName>
            <description>LPTIM interrupt clear register </description>
            <alternateRegister>LPTIM_ICR_output</alternateRegister>
			<addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>CC1CF</name>
                <description>Capture/compare 1 clear flag
Writing 1 to this bit clears the CC1IF flag in the LPTIM_ISR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARRMCF</name>
                <description>Autoreload match clear flag
Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EXTTRIGCF</name>
                <description>External trigger valid edge clear flag
Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ARROKCF</name>
                <description>Autoreload register update OK clear flag
Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UPCF</name>
                <description>Direction change to UP clear flag
Writing 1 to this bit clear the UP flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DOWNCF</name>
                <description>Direction change to down clear flag
Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register.
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UECF</name>
                <description>Update event clear flag
Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>REPOKCF</name>
                <description>Repetition register update OK clear flag
Writing 1 to this bit clears the REPOK flag in the LPTIM_ISR register.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC2CF</name>
                <description>Capture/compare 2 clear flag
Writing 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC1OCF</name>
                <description>Capture/compare 1 over-capture clear flag
Writing 1 to this bit clears the CC1OF flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC2OCF</name>
                <description>Capture/compare 2 over-capture clear flag
Writing 1 to this bit clears the CC2OF flag in the LPTIM_ISR register.
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DIEROKCF</name>
                <description>Interrupt enable register update OK clear flag
Writing 1 to this bit clears the DIEROK flag in the LPTIM_ISR register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
			</fields>
          </register>
          <register>
            <name>LPTIM_DIER_output</name>
            <displayName>LPTIM_DIER_output</displayName>
            <description>LPTIM1 interrupt enable register [alternate]</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1IE</name>
                <description>Capture/compare 1 interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture/compare 1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture/compare 1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARRMIE</name>
                <description>Autoreload match Interrupt Enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ARRM interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ARRM interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTTRIGIE</name>
                <description>External trigger valid edge Interrupt Enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EXTTRIG interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EXTTRIG interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMP1OKIE</name>
                <description>Compare register 1 update OK interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CMPOK register 1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CMPOK register 1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARROKIE</name>
                <description>Autoreload register update OK Interrupt Enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ARROK interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ARROK interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPIE</name>
                <description>Direction change to UP Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UP interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UP interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DOWNIE</name>
                <description>Direction change to down Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DOWN interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DOWN interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UEIE</name>
                <description>Update event interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update event interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update event interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REPOKIE</name>
                <description>Repetition register update OK interrupt Enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Repetition register update OK interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Repetition register update OK interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/compare 2 interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture/compare 2 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture/compare 2 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMP2OKIE</name>
                <description>Compare register 2 update OK interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CMPOK register 2 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CMPOK register 2 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UEDE</name>
                <description>Update event DMA request enable
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UE DMA request disabled. Writing '0' to the UEDE bit resets the associated ue_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UE DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>LPTIM_DIER_intput</name>
            <displayName>LPTIM_DIER_intput</displayName>
            <description>LPTIM interrupt enable register </description>
            <alternateRegister>LPTIM_DIER_output</alternateRegister>
			<addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>CC1IE</name>
                <description>Capture/compare 1 interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture/compare 1 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture/compare 1 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARRMIE</name>
                <description>Autoreload match Interrupt Enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ARRM interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ARRM interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXTTRIGIE</name>
                <description>External trigger valid edge Interrupt Enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EXTTRIG interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EXTTRIG interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARROKIE</name>
                <description>Autoreload register update OK Interrupt Enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ARROK interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ARROK interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPIE</name>
                <description>Direction change to UP Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UP interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UP interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DOWNIE</name>
                <description>Direction change to down Interrupt Enable
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DOWN interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DOWN interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UEIE</name>
                <description>Update event interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update event interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update event interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REPOKIE</name>
                <description>Repetition register update OK interrupt Enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Repetition register update OK interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Repetition register update OK interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/compare 2 interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture/compare 2 interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture/compare 2 interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OIE</name>
                <description>Capture/compare 1 over-capture interrupt enable
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 over-capture interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 over-capture interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OIE</name>
                <description>Capture/compare 2 over-capture interrupt enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 over-capture interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 over-capture interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/compare 1 DMA request enable
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled. Writing &#39;0&#39; to the CC1DE bit resets the associated ic1_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field> 
              <field>
                <name>UEDE</name>
                <description>Update event DMA request enable
Note: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UE DMA request disabled. Writing &#39;0&#39; to the UEDE bit resets the associated ue_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UE DMA request enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2DE</name>
                <description>Capture/compare 2 DMA request enable
Note: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to .</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 DMA request disabled. Writing &#39;0&#39; to the CC2DE bit resets the associated ic2_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 DMA request enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
			</fields>
          </register>
		  <register>
            <name>LPTIM_CFGR</name>
            <displayName>LPTIM_CFGR</displayName>
            <description>LPTIM configuration register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CKSEL</name>
                <description>Clock selector
The CKSEL bit selects which clock source the LPTIM uses:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM is clocked by an external clock source through the LPTIM external Input1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKPOL</name>
                <description>Clock Polarity
When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.
If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.
Refer to  for more details about Encoder mode sub-modes.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the rising edge is the active edge used for counting.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the falling edge is the active edge used for counting.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>not allowed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKFLT</name>
                <description>Configurable digital filter for external clock
The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>any external clock signal level change is considered as a valid transition</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRGFLT</name>
                <description>Configurable digital filter for trigger
The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>any trigger active level change is considered as a valid trigger</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRESC</name>
                <description>Clock prescaler
The PRESC bits configure the prescaler division factor. It can be one among the following division factors:</description>
                <bitOffset>9</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>/1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>/2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>/4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>/8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>/16</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>/32</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>/64</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>/128</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGSEL</name>
                <description>Trigger selector
The TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources:
See  for details.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>lptim_ext_trig0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>lptim_ext_trig1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>lptim_ext_trig2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>lptim_ext_trig3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>lptim_ext_trig4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>lptim_ext_trig5</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>lptim_ext_trig6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>lptim_ext_trig7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TRIGEN</name>
                <description>Trigger enable and polarity
The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>software trigger (counting start is initiated by software)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>rising edge is the active edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>falling edge is the active edge</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>both edges are active edges</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMOUT</name>
                <description>Timeout enable
The TIMOUT bit controls the Timeout feature</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>A trigger event arriving when the timer is already started is ignored</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A trigger event arriving when the timer is already started resets and restarts the LPTIM counter and the repetition counter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAVE</name>
                <description>Waveform shape
The WAVE bit controls the output shape</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Deactivate Set-once mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Activate the Set-once mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAVPOL</name>
                <description>Waveform shape polarity
The WAVPOL bit controls the output polarity
Note: If the LPTIM implements at least one capture/compare channel, this bit is reserved. Please refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The LPTIM output reflects the compare results between LPTIM_CNT and LPTIM_CCRx registers</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The LPTIM output reflects the inverse of the compare results between LPTIM_CNT and LPTIM_CCRx registers</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRELOAD</name>
                <description>Registers update mode
The PRELOAD bit controls the LPTIM_ARR, LPTIM_RCR and the LPTIM_CCRx registers update modality</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Registers are updated after each APB bus write access</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Registers are updated at the end of the current LPTIM period</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNTMODE</name>
                <description>counter mode enabled
The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the counter is incremented following each internal clock pulse</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the counter is incremented following each valid clock pulse on the LPTIM external Input1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENC</name>
                <description>Encoder mode enable
The ENC bit controls the Encoder mode
Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Encoder mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_CR</name>
            <displayName>LPTIM_CR</displayName>
            <description>LPTIM control register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>LPTIM enable
The ENABLE bit is set and cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM is disabled. Writing '0' to the ENABLE bit resets all the DMA request signals (input capture and update event DMA requests).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SNGSTRT</name>
                <description>LPTIM start in Single mode
This bit is set by software and cleared by hardware.
In case of software start (TRIGEN[1:0] = ‘00’), setting this bit starts the LPTIM in single pulse mode.
If the software start is disabled (TRIGEN[1:0] different than ‘00’), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM_ARR and LPTIM_CNT registers.
This bit can only be set when the LPTIM is enabled. It is automatically reset by hardware.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTSTRT</name>
                <description>Timer start in Continuous mode
This bit is set by software and cleared by hardware.
In case of software start (TRIGEN[1:0] = ‘00’), setting this bit starts the LPTIM in Continuous mode.
If the software start is disabled (TRIGEN[1:0] different than ‘00’), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
If this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode.
This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNTRST</name>
                <description>Counter reset
This bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).
This bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.
COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RSTARE</name>
                <description>Reset after read enable
This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register asynchronously resets LPTIM_CNT register content.
This bit can be set only when the LPTIM is enabled.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_CCR1</name>
            <displayName>LPTIM_CCR1</displayName>
            <description>LPTIM compare register 1 </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the capture/compare 1 register.
Depending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.
The capture/compare register 1 contains the value to be compared to the counter LPTIM_CNT and signaled on OC1 output.
If channel CC1 is configured as input:
CCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM_CCR1 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_ARR</name>
            <displayName>LPTIM_ARR</displayName>
            <description>LPTIM autoreload register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000001</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto reload value
ARR is the autoreload value for the LPTIM.
This value must be strictly greater than the CCRx[15:0] value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_CNT</name>
            <displayName>LPTIM_CNT</displayName>
            <description>LPTIM counter register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value
When the LPTIM is running with an asynchronous clock, reading the LPTIM_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_RCR</name>
            <displayName>LPTIM_RCR</displayName>
            <description>LPTIM repetition register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REP</name>
                <description>Repetition register value
REP is the repetition value for the LPTIM.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_CCMR1</name>
            <displayName>LPTIM_CCMR1</displayName>
            <description>LPTIM capture/compare mode register 1 </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1SEL</name>
                <description>Capture/compare 1 selection
This bitfield defines the direction of the channel input (capture) or output mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured in output PWM mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured in input capture mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1E</name>
                <description>Capture/compare 1 output enable.
This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM_CCR1) or not.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_CC1_AS_OUTPUT</name>
                    <description>Off - OC1 is not active. Writing '0' to the CC1E bit resets the ue_dma_req signal only if all the other LPTIM channels are disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC1_AS_OUTPUT</name>
                    <description>On - OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_CC1_AS_INPUT</name>
                    <description>Capture disabled. Writing '0' to the CC1E bit resets the associated ic1_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC1_AS_INPUT</name>
                    <description>Capture enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/compare 1 output polarity.
Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care.
This field is used to select the IC1 polarity for capture operations.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_CC1_AS_OUTPUT</name>
                    <description>OC1 active high, the LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CCRx registers</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC1_AS_OUTPUT</name>
                    <description>OC1 active low, the LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CCRx registers</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_CC1_AS_INPUT</name>
                    <description>rising edge, circuit is sensitive to IC1 rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC1_AS_INPUT</name>
                    <description>falling edge, circuit is sensitive to IC1 falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_CC1_AS_INPUT</name>
                    <description>reserved, do not use this configuration.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_CC1_AS_INPUT</name>
                    <description>both edges, circuit is sensitive to both IC1 rising and falling edges.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>any external input capture signal level change is considered as a valid transition</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2SEL</name>
                <description>Capture/compare 2 selection
This bitfield defines the direction of the channel, input (capture) or output mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured in output PWM mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured in input capture mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2E</name>
                <description>Capture/compare 2 output enable.
This bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM_CCR2) or not.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_CC2_AS_OUTPUT</name>
                    <description>Off - OC2 is not active. Writing '0' to the CC2E bit resets the ue_dma_req signal only if all the other LPTIM channels are disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC2_AS_OUTPUT</name>
                    <description>On - OC2 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_CC2_AS_INPUT</name>
                    <description>Capture disabled. Writing '0' to the CC2E bit resets the associated ic2_dma_req signal.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC2_AS_INPUT</name>
                    <description>Capture enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2P</name>
                <description>Capture/compare 2 output polarity.
Only bit2 is used to set polarity when output mode is enabled, bit3 is don't care.
This field is used to select the IC2 polarity for capture operations.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_CC2_AS_OUTPUT</name>
                    <description>OC2 active high</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC2_AS_OUTPUT</name>
                    <description>OC2 active low</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_CC2_AS_INPUT</name>
                    <description>rising edge, circuit is sensitive to IC2 rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_CC2_AS_INPUT</name>
                    <description>falling edge, circuit is sensitive to IC2 falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_CC2_AS_INPUT</name>
                    <description>reserved, do not use this configuration.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_CC2_AS_INPUT</name>
                    <description>both edges, circuit is sensitive to both IC2 rising and falling edges.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2PSC</name>
                <description>Input capture 2 prescaler
This bitfield defines the ratio of the prescaler acting on the CC2 input (IC2).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2F</name>
                <description>Input capture 2 filter
This bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>any external input capture signal level change is considered as a valid transition</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>external input capture signal level change must be stable for at least 2 clock periods before it is considered as valid transition.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>external input capture signal level change must be stable for at least 4 clock periods before it is considered as valid transition.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>external input capture signal level change must be stable for at least 8 clock periods before it is considered as valid transition.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LPTIM_CCR2</name>
            <displayName>LPTIM_CCR2</displayName>
            <description>LPTIM compare register 2 </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR2</name>
                <description>Capture/compare 2 value
If channel CC2 is configured as output:
CCR2 is the value to be loaded in the capture/compare 2 register.
Depending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.
The capture/compare register 2 contains the value to be compared to the counter LPTIM_CNT and signaled on OC2 output.
If channel CC2 is configured as input:
CCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM_CCR2 register is read-only and cannot be programmed.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral derivedFrom="LPTIM1">
      <name>LPTIM2</name>
      <baseAddress>0x40009400</baseAddress>
	  <interrupt>
        <name>LPTIM2</name>
        <description>LPTIM2 global interrupt</description>
        <value>70</value>
      </interrupt>
    </peripheral>
	<peripheral>
        <name>LPUART</name>
        <description>Universal synchronous asynchronous receiver transmitter</description>
        <groupName>LPUART</groupName>
        <baseAddress>0x44002400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>LPUART1</name>
          <description>LPUART1 global interrupt</description>
          <value>63</value>
        </interrupt>
        <registers>
          <register>
            <name>LPUART_CR1_enabled</name>
            <displayName>LPUART_CR1_enabled</displayName>
            <description>LPUART control register 1 [alternate] </description>			
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UE</name>
                <description>LPUART enable
When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPUART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>LPUART enable in low-power mode
When this bit is cleared, the LPUART cannot wake up the MCU from low-power mode.
When this bit is set, the LPUART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1’. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever IDLE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNEIE</name>
                <description>RXFIFO not empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated whenever ORE=1 or RXFNE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever TC=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFNFIE</name>
                <description>TXFIFO not full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated whenever TXFNF =1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever PE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and Active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable.
If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer .
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 Start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 Start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 Start bit, 7 Data bits, n Stop bit
This bit can only be written when the LPUART is disabled (UE=0).
Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFEIE</name>
                <description>TXFIFO empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated when TXFE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFFIE</name>
                <description>RXFIFO Full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated when RXFF=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>LPUART_CR1_disabled</name>
            <displayName>LPUART_CR1_disabled</displayName>
            <description>LPUART control register 1 [alternate] </description>
			<alternateRegister>LPUART_CR1_enabled</alternateRegister>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>UE</name>
                <description>LPUART enable
When this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPUART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>LPUART enable in low-power mode
When this bit is cleared, the LPUART cannot wake up the MCU from low-power mode.
When this bit is set, the LPUART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever IDLE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNEIE</name>
                <description>Receive data register not empty
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated whenever ORE=1 or RXNE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever TC=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXEIE</name>
                <description>Transmit data register empty
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated whenever TXE =1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated whenever PE=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and Active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated when the CMF bit is set in the LPUART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable.
If the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer .
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 Start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 Start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 Start bit, 7 Data bits, n Stop bit
This bit can only be written when the LPUART is disabled (UE=0).
Note: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
			</fields>
          </register>		  
          <register>
            <name>LPUART_CR2</name>
            <displayName>LPUART_CR2</displayName>
            <description>LPUART control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDM7</name>
                <description>7-bit Address Detection/4-bit Address Detection
This bit is for selection between 4-bit address detection or 7-bit address detection.
This bit can only be written when the LPUART is disabled (UE=0)
Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>4-bit address detection</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>7-bit address detection (in 8-bit data mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>STOP bits
These bits are used for programming the stop bits.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 stop bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 stop bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWAP</name>
                <description>Swap TX/RX pins
This bit is set and cleared by software.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX/RX pins are used as defined in standard pinout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXINV</name>
                <description>RX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the RX line.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RX pin signal works using the standard logic levels (VDD =1/idle, Gnd=0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RX pin signal values are inverted. ((VDD =0/mark, Gnd=1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXINV</name>
                <description>TX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the TX line.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX pin signal works using the standard logic levels (VDD =1/idle, Gnd=0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TX pin signal values are inverted. ((VDD =0/mark, Gnd=1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATAINV</name>
                <description>Binary data inversion
This bit is set and cleared by software.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSBFIRST</name>
                <description>Most significant bit first
This bit is set and cleared by software.
This bitfield can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data is transmitted/received with data bit 0 first, following the start bit. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data is transmitted/received with the MSB (bit 7/8) first, following the start bit. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD</name>
                <description>Address of the LPUART node
These bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode:
In Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.
In low-power mode: they are used for wake up from low-power mode on character match.
When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wakeup from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.
In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.
These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_CR3</name>
            <displayName>LPUART_CR3</displayName>
            <description>LPUART control register 3 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EIE</name>
                <description>Error interrupt enable
Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated when FE=1 or ORE=1 or NE=1 in the LPUART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HDSEL</name>
                <description>Half-duplex selection
Selection of Single-wire Half-duplex mode
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Half-duplex mode is not selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Half-duplex mode is selected </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAR</name>
                <description>DMA enable receiver
This bit is set/reset by software</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAT</name>
                <description>DMA enable transmitter
This bit is set/reset by software</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTSE</name>
                <description>RTS enable
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSE</name>
                <description>CTS enable
This bit can only be written when the LPUART is disabled (UE=0)</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIE</name>
                <description>CTS interrupt enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated whenever CTSIF=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRDIS</name>
                <description>Overrun Disable
This bit is used to disable the receive overrun detection.
the ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.
This bit can only be written when the LPUART is disabled (UE=0).
Note: This control bit enables checking the communication flow w/o reading the data.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Overrun Error Flag, ORE is set when received data is not read before receiving new data. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun functionality is disabled. If new data is received while the RXNE flag is still set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDRE</name>
                <description>DMA Disable on Reception Error
This bit can only be written when the LPUART is disabled (UE=0).
Note: The reception errors are: parity error, framing error or noise error.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE before clearing the error flag.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEM</name>
                <description>Driver enable mode
This bit enables the user to activate the external transceiver control, through the DE signal.
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE function is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE function is enabled. The DE signal is output on the RTS pin.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEP</name>
                <description>Driver enable polarity selection
This bit can only be written when the LPUART is disabled (UE=0).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE signal is active high. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE signal is active low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUS0</name>
                <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the LPUART is disabled (UE=0).
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WUF active on address match (as defined by ADD[7:0] and ADDM7)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>WUF active on start bit detection</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>WUF active on RXNE/RXFNE. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUS1</name>
                <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the LPUART is disabled (UE=0).
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WUF active on address match (as defined by ADD[7:0] and ADDM7)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>WUF active on start bit detection</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>WUF active on RXNE/RXFNE. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUFIE</name>
                <description>Wakeup from low-power mode interrupt enable
This bit is set and cleared by software.
Note: WUFIE must be set before entering in low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever WUF=1 in the LPUART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTIE</name>
                <description>TXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A LPUART interrupt is generated when TXFIFO reaches the threshold programmed in TXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTCFG</name>
                <description>Receive FIFO threshold configuration
Remaining combinations: Reserved.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO reaches 1/8 of its depth.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reaches 1/4 of its depth.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Receive FIFO reaches 1/2 of its depth.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Receive FIFO reaches 3/4 of its depth.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Receive FIFO reaches 7/8 of its depth.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Receive FIFO becomes full.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTIE</name>
                <description>RXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An LPUART interrupt is generated when Receive FIFO reaches the threshold programmed in RXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTCFG</name>
                <description>TXFIFO threshold configuration
Remaining combinations: Reserved.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO reaches 1/8 of its depth.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reaches 1/4 of its depth.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>TXFIFO reaches 1/2 of its depth.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>TXFIFO reaches 3/4 of its depth.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TXFIFO reaches 7/8 of its depth.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>TXFIFO becomes empty.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_BRR</name>
            <displayName>LPUART_BRR</displayName>
            <description>LPUART baud rate register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BRR</name>
                <description>LPUART baud rate division (LPUARTDIV)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_RQR</name>
            <displayName>LPUART_RQR</displayName>
            <description>LPUART request register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SBKRQ</name>
                <description>Send break request
Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.
Note: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MMRQ</name>
                <description>Mute mode request
Writing 1 to this bit puts the LPUART in Mute mode and resets the RWU flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RXFRQ</name>
                <description>Receive data flush request
Writing 1 to this bit clears the RXNE flag.
This enables discarding the received data without reading it, and avoid an overrun condition.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXFRQ</name>
                <description>Transmit data flush request
This bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).
Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_ISR_enabled</name>
            <displayName>LPUART_ISR_enabled</displayName>
            <description>LPUART interrupt and status register [alternate] </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x008000C0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.
An interrupt is generated if PEIE = 1 in the LPUART_CR1 register.
Note: This error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No parity error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE = 1 in the LPUART_CR1 register.
Note: This error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Framing error is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Framing error or break character is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NE</name>
                <description>Start bit noise detection flag
This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
This error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No noise is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.
An interrupt is generated if RXFNEIE=1 or EIE = 1 in the LPUART_CR1 register.
Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun error is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.
Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Idle line is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle line is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNE</name>
                <description>RXFIFO not empty
RXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty.
The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.
An interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data is not received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Received data is ready to be read.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:
When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set.
When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.
When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.
When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.
An interrupt is generated if TCIE=1 in the LPUART_CR1 register.
TC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFNF</name>
                <description>TXFIFO not full
TXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR.
The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).
An interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register.
Note: This bit is used during single buffer transmission.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data register is full/Transmit FIFO is full.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Data register/Transmit FIFO is not full.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.
An interrupt is generated if CTSIE=1 in the LPUART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No change occurred on the nCTS status line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A change occurred on the nCTS status line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>nCTS line set</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>nCTS line reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART is idle (no reception)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reception on going</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.
An interrupt is generated if CMIE=1in the LPUART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Character match detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Character match detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break character transmitted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break character transmitted</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.
Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver in Mute mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register.
An interrupt is generated if WUFIE=1 in the LPUART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.
It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.
It can be used to verify that the LPUART is ready for reception before entering low-power mode.
Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFE</name>
                <description>TXFIFO Empty
This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.
An interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO is not empty.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO is empty.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFF</name>
                <description>RXFIFO Full
This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the LPUART_RDR register.
An interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXFIFO is not Full.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXFIFO is Full.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFT</name>
                <description>RXFIFO threshold flag
This bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFT</name>
                <description>TXFIFO threshold flag
This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>LPUART_ISR_disabled</name>
            <displayName>LPUART_ISR_disabled</displayName>
            <description>LPUART interrupt and status register [alternate] </description>
			<alternateRegister>LPUART_ISR_enabled</alternateRegister>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x008000C0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			  <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.
An interrupt is generated if PEIE = 1 in the LPUART_CR1 register.
Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No parity error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE = 1 in the LPUART_CR1 register.
Note: In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Framing error is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Framing error or break character is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NE</name>
                <description>Start bit noise detection flag
This bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXNE/RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
In FIFO mode, this error is associated with the character in the LPUART_RDR.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No noise is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the LPUART_RDR register while RXNE=1 (RXFF = 1 in case FIFO mode is enabled). It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.
An interrupt is generated if RXNEIE=1 or EIE = 1 in the LPUART_CR1 register.
Note: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun error is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.
Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Idle line is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle line is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNE</name>
                <description>Read data register not empty
RXNE bit is set by hardware when the content of the LPUART_RDR shift register has been transferred to the LPUART_RDR register. It is cleared by a read to the LPUART_RDR register. The
RXNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.
The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.
An interrupt is generated if RXNEIE=1 in the LPUART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data is not received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Received data is ready to be read.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag is set when the transmission of a frame containing data is complete and when TXE is set.
An interrupt is generated if TCIE=1 in the USART_CR1 register.
TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty
TXE is set by hardware when the content of the LPUART_TDR register has been transferred into the shift register. It is cleared by a write to the LPUART_TDR register.
An interrupt is generated if the TXEIE bit =1 in the LPUART_CR1 register.
Note: This bit is used during single buffer transmission.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data register is full/Transmit FIFO is full.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Data register/Transmit FIFO is not full.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.
An interrupt is generated if CTSIE=1 in the LPUART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No change occurred on the nCTS status line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A change occurred on the nCTS status line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>nCTS line set</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>nCTS line reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART is idle (no reception)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reception on going</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.
An interrupt is generated if CMIE=1in the LPUART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Character match detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Character match detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break character transmitted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break character transmitted</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.
Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver in Mute mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register.
An interrupt is generated if WUFIE=1 in the LPUART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.
It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.
It can be used to verify that the LPUART is ready for reception before entering low-power mode.
Note: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
			</fields>
          </register>		  
          <register>
            <name>LPUART_ICR</name>
            <displayName>LPUART_ICR</displayName>
            <description>LPUART interrupt flag clear register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PECF</name>
                <description>Parity error clear flag
Writing 1 to this bit clears the PE flag in the LPUART_ISR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FECF</name>
                <description>Framing error clear flag
Writing 1 to this bit clears the FE flag in the LPUART_ISR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NECF</name>
                <description>Noise detected clear flag
Writing 1 to this bit clears the NE flag in the LPUART_ISR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ORECF</name>
                <description>Overrun error clear flag
Writing 1 to this bit clears the ORE flag in the LPUART_ISR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>IDLECF</name>
                <description>Idle line detected clear flag
Writing 1 to this bit clears the IDLE flag in the LPUART_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TCCF</name>
                <description>Transmission complete clear flag
Writing 1 to this bit clears the TC flag in the LPUART_ISR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTSCF</name>
                <description>CTS clear flag
Writing 1 to this bit clears the CTSIF flag in the LPUART_ISR register.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMCF</name>
                <description>Character match clear flag
Writing 1 to this bit clears the CMF flag in the LPUART_ISR register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WUCF</name>
                <description>Wakeup from low-power mode clear flag
Writing 1 to this bit clears the WUF flag in the USART_ISR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_RDR</name>
            <displayName>LPUART_RDR</displayName>
            <description>LPUART receive data register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDR</name>
                <description>Receive data value
Contains the received data character.
The RDR register provides the parallel interface between the input shift register and the internal bus (see ).
When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_TDR</name>
            <displayName>LPUART_TDR</displayName>
            <description>LPUART transmit data register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDR</name>
                <description>Transmit data value
Contains the data character to be transmitted.
The TDR register provides the parallel interface between the internal bus and the output shift register (see ).
When transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.
Note: This register must be written only when TXE/TXFNF=1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPUART_PRESC</name>
            <displayName>LPUART_PRESC</displayName>
            <description>LPUART prescaler register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Clock prescaler
The LPUART input clock can be divided by a prescaler:
Remaining combinations: Reserved.
Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>input clock not divided</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>input clock divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>input clock divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>input clock divided by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>input clock divided by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>input clock divided by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>input clock divided by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>input clock divided by 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>input clock divided by 32</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>input clock divided by 64</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>input clock divided by 128</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>input clock divided by 256</description>
                    <value>0xB</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>OPAMP1</name>
        <description>Operational amplifiers</description>
		<groupName>OPAMP</groupName>
        <baseAddress>0x40003400</baseAddress>
		<addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
          <register>
            <name>OPAMP1_CSR</name>
            <displayName>OPAMP1_CSR</displayName>
            <description>OPAMP1 control/status register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OPAEN</name>
                <description>Operational amplifier Enable
Note: If OPAMP1 is unconnected in a specific package, it must remain disabled (keep OPAMP1_CSR register default value).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>operational amplifier disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>operational amplifier enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FORCE_VP</name>
                <description>Force internal reference on VP (reserved for test)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal operating mode. Non-inverting input connected to inputs.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calibration verification mode: Non-inverting input connected to calibration reference voltage.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VP_SEL</name>
                <description>Non inverted input selection</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIO INP0 connected to OPAMP_VINP</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>dac_out1 connected to OPAMP_VINP</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>GPIO INP2 is connected to OPAMP_VINP</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VM_SEL</name>
                <description>Inverting input selection</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>INM0 connected to OPAMP_VINM input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>INM1 connected to OPAMP_VINM input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Feedback resistor is connected to OPAMP_VINM input (PGA mode), Inverting input selection is depends on the PGA_GAIN setting</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>opamp_out connected to OPAMP_VINM input (Follower mode)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPAHSM</name>
                <description>Operational amplifier high-speed mode
The operational amplifier must be disable to change this configuration.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>operational amplifier in normal mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>operational amplifier in high-speed mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CALON</name>
                <description>Calibration mode enabled</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Calibration mode (all switches opened by HW)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CALSEL</name>
                <description>Calibration selection
It is used to select the offset calibration bus used to generate the internal reference voltage when CALON = 1 or FORCE_VP= 1.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>0.033*VDDA applied on OPAMP inputs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>0.1*VDDA applied on OPAMP inputs (for PMOS calibration)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>0.5*VDDA applied on OPAMP inputs</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>0.9*VDDA applied on OPAMP inputs (for NMOS calibration)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PGA_GAIN</name>
                <description>Operational amplifier Programmable amplifier gain value</description>
                <bitOffset>14</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-inverting internal Gain 2, VREF- referenced</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Non-inverting internal Gain 4, VREF- referenced</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Non-inverting internal Gain 8, VREF- referenced</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Non-inverting internal Gain 16, VREF- referenced</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Non-inverting internal Gain 2 with filtering on INM0, VREF- referenced</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Non-inverting internal Gain 4 with filtering on INM0, VREF- referenced</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Non-inverting internal Gain 8 with filtering on INM0, VREF- referenced</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Non-inverting internal Gain 16 with filtering on INM0, VREF- referenced</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Inverting gain=-1/ Non-inverting gain =2 with INM0 node for input or bias</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Inverting gain=-3/ Non-inverting gain =4 with INM0 node for input or bias</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Inverting gain=-7/ Non-inverting gain =8 with INM0 node for input or bias</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Inverting gain=-15/ Non-inverting gain =16 with INM0 node for input or bias</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Inverting gain=-1/ Non-inverting gain =2 with INM0 node for input or bias, INM1 node for filtering</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Inverting gain=-3/ Non-inverting gain =4 with INM0 node for input or bias, INM1 node for filtering</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Inverting gain=-7/ Non-inverting gain =8 with INM0 node for input or bias, INM1 node for filtering</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Inverting gain=-15/ Non-inverting gain =16 with INM0 node for input or bias, INM1 node for filtering</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USERTRIM</name>
                <description>User trimming enable
This bit allows to switch from ‘factory’ AOP offset trimmed values to ‘user’ AOP offset trimmed values
This bit is active for both mode normal and high-power.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>‘factory’ trim code used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>‘user’ trim code used</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSTREF</name>
                <description>OPAMP calibration reference voltage output control (reserved for test)</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>INTVREF of OPAMP is not output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>INTVREF of OPAMP is output</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CALOUT</name>
                <description>Operational amplifier calibration output
OPAMP output status flag. During the calibration mode, OPAMP is used as comparator.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Non-inverting &lt; inverting</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Non-inverting &gt; inverting</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>OPAMP1_OTR</name>
            <displayName>OPAMP1_OTR</displayName>
            <description>OPAMP1 trimming register in normal mode </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>TRIMOFFSETN</name>
                <description>Trim for NMOS differential pairs</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIMOFFSETP</name>
                <description>Trim for PMOS differential pairs</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OPAMP1_HSOTR</name>
            <displayName>OPAMP1_HSOTR</displayName>
            <description>OPAMP1 trimming register in high-speed mode 	</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>TRIMHSOFFSETN</name>
                <description>High-speed mode trim for NMOS differential pairs</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIMHSOFFSETP</name>
                <description>High-speed mode trim for PMOS differential pairs</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>OPAMP_OR</name>
            <displayName>OPAMP_OR</displayName>
            <description>OPAMP option register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>
        </registers>
    </peripheral>	
    <peripheral>
        <name>RCC</name>
        <description>Reset and clock controller</description>
        <groupName>RCC</groupName>
		<baseAddress>0x44020C00</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>RCC</name>
          <description>RCC global interrupt</description>
          <value>9</value>
        </interrupt>
        <registers>
          <register>
            <name>RCC_CR</name>
            <displayName>RCC_CR</displayName>
            <description>RCC clock control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000023</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HSION</name>
                <description>HSI clock enable
Set and cleared by software.
Set by hardware to force the HSI to ON when the product leaves Stop mode, if STOPWUCK = 1 or STOPKERWUCK = 1.
Set by hardware to force the HSI to ON when the product leaves Standby mode or in case of a failure of the HSE which is used as the system clock source.
This bit cannot be cleared if the HSI is used directly (via SW mux) as system clock, or if the HSI is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI is OFF</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI is ON (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDY</name>
                <description>HSI clock ready flag
Set by hardware to indicate that the HSI oscillator is stable.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI clock is not ready (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI clock is ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIKERON</name>
                <description>HSI clock enable in Stop mode
Set and reset by software to force the HSI to ON, even in Stop mode, in order to be quickly available as kernel clock for peripherals. This bit has no effect on the value of HSION.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect on HSI (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI is forced to ON even in Stop mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIDIV</name>
                <description>HSI clock divider
Set and reset by software.
These bits allow selecting a division ratio in order to configure the wanted HSI clock frequency. The
HSIDIV cannot be changed if the HSI is selected as reference clock for at least one enabled PLL (PLLxON bit set to 1). In that case, the new HSIDIV value is ignored.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>division by 1, hsi(_ker)_ck = 64 MHz (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>division by 2, hsi(_ker)_ck = 32 MHz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>division by 4, hsi(_ker)_ck = 16 MHz</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>division by 8, hsi(_ker)_ck = 8 MHz</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIDIVF</name>
                <description>HSI divider flag
Set and reset by hardware.
As a write operation to HSIDIV has not an immediate effect on the frequency, this flag indicates the
current status of the HSI divider. HSIDIVF goes immediately to 0 when HSIDIV value is changed, and is set back to 1 when the output frequency matches the value programmed into HSIDIV.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>new division ratio not yet propagated to hsi(_ker)_ck (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>hsi(_ker)_ck clock frequency reflects the new HSIDIV value (default register value when the clock setting is completed).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSION</name>
                <description>CSI clock enable
Set and reset by software to enable/disable CSI clock for system and/or peripheral.
Set by hardware to force the CSI to ON when the system leaves Stop mode, if STOPWUCK = 1 or STOPKERWUCK = 1.
This bit cannot be cleared if the CSI is used directly (via SW mux) as system clock, or if the CSI is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSI is OFF (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI is ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSIRDY</name>
                <description>CSI clock ready flag
Set by hardware to indicate that the CSI oscillator is stable. This bit is activated only if the RC is enabled by CSION (it is not activated if the CSI is enabled by CSIKERON or by a peripheral request).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSI clock is not ready (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI clock is ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSIKERON</name>
                <description>CSI clock enable in Stop mode
Set and reset by software to force the CSI to ON, even in Stop mode, in order to be quickly available as kernel clock for some peripherals. This bit has no effect on the value of CSION.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no effect on CSI (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI is forced to ON even in Stop mode </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSI48ON</name>
                <description>HSI48 clock enable
Set by software and cleared by software or by the hardware when the system enters to Stop
or Standby mode.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI48 is OFF (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI48 is ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSI48RDY</name>
                <description>HSI48 clock ready flag
Set by hardware to indicate that the HSI48 oscillator is stable.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI48 clock is not ready (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI48 clock is ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEON</name>
                <description>HSE clock enable
Set and cleared by software.
Cleared by hardware to stop the HSE when entering Stop or Standby mode.
This bit cannot be cleared if the HSE is used directly (via SW mux) as system clock, or if the
HSE is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSE is OFF (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE is ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDY</name>
                <description>HSE clock ready flag
Set by hardware to indicate that the HSE oscillator is stable.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSE clock is not ready (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE clock is ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEBYP</name>
                <description>HSE clock bypass
Set and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit to be used by the device.
The HSEBYP bit can be written only if the HSE oscillator is disabled.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSE oscillator not bypassed (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE oscillator bypassed with an external clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSECSSON</name>
                <description>HSE clock security system enable
Set by software to enable clock security system on HSE.
This bit is “set only” (disabled by a system reset or when the system enters in Standby mode). When HSECSSON is set, the clock detector is enabled by hardware when the HSE is ready and disabled by hardware if an oscillator failure is detected.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSS on HSE OFF (clock detector OFF) (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSS on HSE ON (clock detector ON if the HSE oscillator is stable, OFF if not).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSEEXT</name>
                <description>external high speed clock type in Bypass mode
Set and reset by software to select the external clock type (analog or digital).
The external clock must be enabled with the HSEON bit to be used by the device. The HSEEXT bit can be written only if the HSE oscillator is disabled.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSE in analog mode (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE in digital mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1ON</name>
                <description>PLL1 enable
Set and cleared by software to enable PLL1.
Cleared by hardware when entering Stop or Standby mode. Note that the hardware prevents
writing this bit to 0, if the PLL1 output is used as the system clock.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL1 OFF (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL1 ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1RDY</name>
                <description>PLL1 clock ready flag
Set by hardware to indicate that the PLL1 is locked.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL1 unlocked (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL1 locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2ON</name>
                <description>PLL2 enable
Set and cleared by software to enable PLL2.
Cleared by hardware when entering Stop or Standby mode.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL2 OFF (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2 ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2RDY</name>
                <description>PLL2 clock ready flag
Set by hardware to indicate that the PLL is locked.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL2 unlocked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2 locked</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_HSICFGR</name>
            <displayName>RCC_HSICFGR</displayName>
            <description>RCC HSI calibration register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00400000</resetValue>
            <resetMask>0xFFFFF000</resetMask>
            <fields>
              <field>
                <name>HSICAL</name>
                <description>HSI clock calibration
Set by hardware by option byte loading during system reset nreset. Adjusted by software through trimming bits HSITRIM.
This field represents the sum of engineering option byte calibration value and HSITRIM bits value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>HSITRIM</name>
                <description>HSI clock trimming
Set by software to adjust calibration.
HSITRIM field is added to the engineering option bytes loaded during reset phase (FLASH_HSI_OPT) in order to form the calibration trimming value.
HSICAL = HSITRIM + FLASH_HSI_OPT.
After a change of HSITRIM it takes one system clock cycle before the new HSITRIM value is updated
Note: The reset value of the field is 0x40.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CRRCR</name>
            <displayName>RCC_CRRCR</displayName>
            <description>RCC clock recovery RC register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFF000</resetMask>
            <fields>
              <field>
                <name>HSI48CAL</name>
                <description>Internal RC 48 MHz clock calibration
Set by hardware by option-byte loading during system reset NRESET. Read-only.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CSICFGR</name>
            <displayName>RCC_CSICFGR</displayName>
            <description>RCC CSI calibration register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00200000</resetValue>
            <resetMask>0xFFFFF000</resetMask>
            <fields>
              <field>
                <name>CSICAL</name>
                <description>CSI clock calibration
Set by hardware by option byte loading during system reset NRESET. Adjusted by software through trimming bits CSITRIM.
This field represents the sum of engineering option byte calibration value and CSITRIM bits value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CSITRIM</name>
                <description>CSI clock trimming
Set by software to adjust calibration.
CSITRIM field is added to the engineering option bytes loaded during reset phase (FLASH_CSI_OPT) in order to form the calibration trimming value.
CSICAL = CSITRIM + FLASH_CSI_OPT.
Note: The reset value of the field is 0x20.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CFGR</name>
            <displayName>RCC_CFGR</displayName>
            <description>RCC clock configuration register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SW</name>
                <description>system clock and trace clock switch
Set and reset by software to select system clock and trace clock sources (sys_ck).
Set by hardware in order to:
-	force the selection of the HSI or CSI (depending on STOPWUCK selection) when leaving a system Stop mode
-	force the selection of the HSI in case of failure of the HSE when used directly or indirectly as system clock
others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI selected as system clock (hsi_ck) (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI selected as system clock (csi_ck)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE selected as system clock (hse_ck)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1 selected as system clock (pll1_p_ck for sys_ck)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWS</name>
                <description>system clock switch status
Set and reset by hardware to indicate which clock source is used as system clock. 000: HSI used as system clock (hsi_ck) (default after reset).
others: reserved</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI used as system clock (csi_ck) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE used as system clock (hse_ck) </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1 used as system clock (pll1_p_ck) </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPWUCK</name>
                <description>system clock selection after a wakeup from system Stop
Set and reset by software to select the system wakeup clock from system Stop.
The selected clock is also used as emergency clock for the clock security system (CSS) on HSE. 0: HSI selected as wakeup clock from system Stop (default after reset)
STOPWUCK must not be modified when CSS is enabled (by HSECSSON bit) and the system clock is HSE (SWS = 10) or a switch on HSE is requested (SW =10).</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI selected as wakeup clock from system Stop</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOPKERWUCK</name>
                <description>kernel clock selection after a wakeup from system Stop
Set and reset by software to select the kernel wakeup clock from system Stop.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI selected as wakeup clock from system Stop (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI selected as wakeup clock from system Stop</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCPRE</name>
                <description>HSE division factor for RTC clock
Set and cleared by software to divide the HSE to generate a clock for RTC.
Caution: The software must set these bits correctly to ensure that the clock supplied to the RTC is lower than 1 MHz. These bits must be configured if needed before selecting the RTC clock source.
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>no clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE/2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSE/3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>HSE/4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3E</name>
                    <description>HSE/62</description>
                    <value>0x3E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3F</name>
                    <description>HSE/63</description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMPRE</name>
                <description>timers clocks prescaler selection
This bit is set and reset by software to control the clock frequency of all the timers connected to APB1 and APB2 domains.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The timers kernel clock is equal to rcc_hclk1 if PPRE1 or PPRE2 corresponds to a division by 1 or 2, else it is equal to 2 x Frcc_pclk1 or 2 x Frcc_pclk2 (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The timers kernel clock is equal to 2 x Frcc_pclk1 or 2 x Frcc_pclk2 if PPRE1 or PPRE2 corresponds to a division by 1, 2 or 4, else it is equal to 4 x Frcc_pclk1 or 4 x Frcc_pclk2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO1PRE</name>
                <description>MCO1 prescaler
Set and cleared by software to configure the prescaler of the MCO1. Modification of this prescaler may generate glitches on MCO1. It is highly recommended to change this prescaler only after reset, before enabling the external oscillators and the PLLs.
...</description>
                <bitOffset>18</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prescaler disabled (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>division by 1 (bypass)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>division by 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>division by 3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>division by 4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>division by 15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO1SEL</name>
                <description>Microcontroller clock output 1
Set and cleared by software. Clock source selection may generate glitches on MCO1.
It is highly recommended to configure these bits only after reset, before enabling the external oscillators and the PLLs.
others: reserved</description>
                <bitOffset>22</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI clock selected (hsi_ck) (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE oscillator clock selected (lse_ck)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE clock selected (hse_ck) </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1 clock selected (pll1_q_ck) </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>HSI48 clock selected (hsi48_ck) </description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO2PRE</name>
                <description>MCO2 prescaler
Set and cleared by software to configure the prescaler of the MCO2. Modification of this prescaler may generate glitches on MCO2. It is highly recommended to change this prescaler only after reset, before enabling the external oscillators and the PLLs.
...</description>
                <bitOffset>25</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prescaler disabled (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>division by 1 (bypass)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>division by 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>division by 3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>division by 4</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>division by 15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCO2SEL</name>
                <description>microcontroller clock output 2
Set and cleared by software. Clock source selection may generate glitches on MCO2.
It is highly recommended to configure these bits only after reset, before enabling the external oscillators and the PLLs.
others: reserved</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>system clock selected (sys_ck) (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2 oscillator clock selected (pll2_p_ck)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>HSE clock selected (hse_ck) </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1 clock selected (pll1_p_ck) </description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CSI clock selected (csi_ck) </description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>LSI clock selected (lsi_ck) </description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CFGR2</name>
            <displayName>RCC_CFGR2</displayName>
            <description>RCC CPU domain clock configuration register 2 </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HPRE</name>
                <description>AHB prescaler
Set and reset by software to control the division factor of rcc_hclk. Changing
this division ratio has an impact on the frequency of all bus matrix clocks
0xxx: rcc_hclk = sys_ck (default after reset)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>rcc_hclk = sys_ck / 2</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>rcc_hclk = sys_ck / 4</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>rcc_hclk = sys_ck / 8</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>rcc_hclk = sys_ck / 16</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>rcc_hclk = sys_ck / 64</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>rcc_hclk = sys_ck / 128</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>rcc_hclk = sys_ck / 256</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>rcc_hclk = sys_ck / 512</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PPRE1</name>
                <description>APB low-speed prescaler (APB1)
Set and reset by software to control the division factor of rcc_pclk1.
The clock is divided by the new prescaler factor from 1 to 16 cycles of rcc_hclk after PPRE write.
0xx: rcc_pclk1 = rcc_hclk1 (default after reset)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>rcc_pclk1 = rcc_hclk1 / 2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>rcc_pclk1 = rcc_hclk1 / 4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>rcc_pclk1 = rcc_hclk1 / 8</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>rcc_pclk1 = rcc_hclk1 / 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PPRE2</name>
                <description>APB high-speed prescaler (APB2)
Set and reset by software to control APB high-speed clocks division factor.
The clocks are divided with the new prescaler factor from 1 to 16 APB cycles after PPRE2 write.
0xx: rcc_pclk2 = rcc_hclk1</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>rcc_pclk2 = rcc_hclk1 / 2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>rcc_pclk2 = rcc_hclk1 / 4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>rcc_pclk2 = rcc_hclk1 / 8</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>rcc_pclk2 = rcc_hclk1 / 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PPRE3</name>
                <description>APB low-speed prescaler (APB3)
Set and reset by software to control APB low-speed clocks division factor.
The clocks are divided with the new prescaler factor from 1 to 16 APB cycles after PPRE3 write.
0xx: rcc_pclk3 = rcc_hclk1</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>rcc_pclk3 = rcc_hclk1 / 2</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>rcc_pclk3 = rcc_hclk1 / 4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>rcc_pclk3 = rcc_hclk1 / 8</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>rcc_pclk3 = rcc_hclk1 / 16 </description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AHB1DIS</name>
                <description>AHB1 clock disable
This bit can be set in order to further reduce power consumption, when none of the AHB1
peripherals from RCC_AHB1ENR are used and when their clocks are disabled in
RCC_AHB1ENR. When this bit is set, all the AHB1 peripherals clocks from
RCC_AHB1ENR are off.
enable control bits</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AHB1 clock enabled, distributed to peripherals according to their dedicated clock</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AHB1 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AHB2DIS</name>
                <description>AHB2 clock disable
This bit can be set in order to further reduce power consumption, when none of the AHB2
peripherals from RCC_AHB2ENR are used and when their clocks are disabled in
RCC_AHB2ENR. When this bit is set, all the AHB2 peripherals clocks from
RCC_AHB2ENR are off.
enable control bits</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AHB2 clock enabled, distributed to peripherals according to their dedicated clock</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AHB2 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AHB4DIS</name>
                <description>AHB4 clock disable
This bit can be set in order to further reduce power consumption, when none of the AHB4
peripherals from RCC_AHB4ENR are used and when their clocks are disabled in
RCC_AHB4ENR. When this bit is set, all the AHB4 peripherals clocks from
RCC_AHB4ENR are off.
enable control bits</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AHB4 clock enabled, distributed to peripherals according to their dedicated clock</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AHB4 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>APB1DIS</name>
                <description>APB1 clock disable value
This bit can be set in order to further reduce power consumption, when none of the APB1
peripherals (except IWDG) are used and when their clocks are disabled in RCC_APB1ENR.
When this bit is set, all the APB1 peripherals clocks are off, except for IWDG.
control bits</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>APB1 clock enabled, distributed to peripherals according to their dedicated clock enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>APB1 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>APB2DIS</name>
                <description>APB2 clock disable value
This bit can be set in order to further reduce power consumption, when none of the APB2
peripherals are used and when their clocks are disabled in RCC_APB2ENR. When this bit is
set, all the APB2 peripherals clocks are off.
control bits</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>APB2 clock enabled, distributed to peripherals according to their dedicated clock enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>APB2 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>APB3DIS</name>
                <description>APB3 clock disable value.Set and cleared by software
This bit can be set in order to further reduce power consumption, when none of the APB3
peripherals are used and when their clocks are disabled in RCC_APB3ENR. When this bit is
set, all the APB3 peripherals clocks are off.
control bits</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>APB3 clock enabled, distributed to peripherals according to their dedicated clock enable</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>APB3 clock disabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL1CFGR</name>
            <displayName>RCC_PLL1CFGR</displayName>
            <description>RCC PLL clock source selection register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL1SRC</name>
                <description>DIVMx and PLLs clock source selection
Set and reset by software to select the PLL clock source. These bits can be written only when all PLLs are disabled.
In order to save power, when no PLL is used, the value of PLL1SRC must be set to '00'. 00: no clock send to DIVMx divider and PLLs (default after reset).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI selected as PLL clock (hsi_ck) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CSI selected as PLL clock (csi_ck)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSE selected as PLL clock (hse_ck)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1RGE</name>
                <description>PLL1 input frequency range
Set and reset by software to select the proper reference frequency range used for PLL1. This bit must be written before enabling the PLL1.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL1 input (ref1_ck) clock range frequency between 1 and 2 MHz (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL1 input (ref1_ck) clock range frequency between 2 and 4 MHz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1 input (ref1_ck) clock range frequency between 8 and 16 MHz</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1FRACEN</name>
                <description>PLL1 fractional latch enable
Set and reset by software to latch the content of FRACN1 into the sigma-delta modulator.
In order to latch the FRACN1 value into the sigma-delta modulator, PLL1FRACEN must be set to 0, then set to 1. The transition 0 to 1 transfers the content of FRACN1 into the modulator.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL1VCOSEL</name>
                <description>PLL1 VCO selection
Set and reset by software to select the proper VCO frequency range used for PLL1. This bit must be written before enabling the PLL1.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>wide VCO range 192 to 836 MHz (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium VCO range 150 to 420 MHz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIVM1</name>
                <description>prescaler for PLL1
Set and cleared by software to configure the prescaler of the PLL1.
The hardware does not allow any modification of this prescaler when PLL1 is enabled (PLL1ON = 1 or PLL1RDY = 1).
In order to save power when PLL1 is not used, the value of DIVM1 must be set to 0.
...
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prescaler disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>division by 1 (bypass)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>division by 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>division by 3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x20</name>
                    <description>division by 32 </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3F</name>
                    <description>division by 63</description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1PEN</name>
                <description>PLL1 DIVP divider output enable
Set and reset by software to enable the pll1_p_ck output of the PLL1.
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
In order to save power, when the pll1_p_ck output of the PLL1 is not used, the pll1_p_ck must be disabled.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_p_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_p_ck output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1QEN</name>
                <description>PLL1 DIVQ divider output enable
Set and reset by software to enable the pll1_q_ck output of the PLL1.
In order to save power, when the pll1_q_ck output of the PLL1 is not used, the pll1_q_ck must be disabled.
This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_q_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_q_ck output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1REN</name>
                <description>PLL1 DIVR divider output enable
Set and reset by software to enable the pll1_r_ck output of the PLL1.
To save power, DIVR1EN and DIVR1 bits must be set to 0 when the pll1_r_ck is not used. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_r_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_r_ck output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL2CFGR</name>
            <displayName>RCC_PLL2CFGR</displayName>
            <description>RCC PLL clock source selection register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL2SRC</name>
                <description>DIVMx and PLLs clock source selection
Set and reset by software to select the PLL clock source.
These bits can be written only when all PLLs are disabled.
In order to save power, when no PLL is used, the value of PLL2SRC must be set to '00'.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock send to DIVMx divider and PLLs (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI selected as PLL clock (hsi_ck) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CSI selected as PLL clock (csi_ck)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSE selected as PLL clock (hse_ck)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2RGE</name>
                <description>PLL2 input frequency range
Set and reset by software to select the proper reference frequency range used for PLL2. These bits must be written before enabling the PLL2.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL2 input (ref2_ck) clock range frequency between 1 and 2 MHz (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2 input (ref2_ck) clock range frequency between 2 and 4 MHz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>PLL2 input (ref2_ck) clock range frequency between 4 and 8 MHz </description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL2 input (ref2_ck) clock range frequency between 8 and 16 MHz</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2FRACEN</name>
                <description>PLL2 fractional latch enable
Set and reset by software to enable the pll2_p_ck output of the PLL2.
To save power, when the pll2_p_ck output of the PLL2 is not used, the pll2_p_ck must be disabled.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_p_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck output enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2VCOSEL</name>
                <description>PLL2 VCO selection
Set and reset by software to select the proper VCO frequency range used for PLL2.
This bit must be written before enabling the PLL2.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>wide VCO range 192 to 836 MHz (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium VCO range 150 to 420 MHz</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIVM2</name>
                <description>prescaler for PLL2
Set and cleared by software to configure the prescaler of the PLL2.
The hardware does not allow any modification of this prescaler when PLL2 is enabled (PLL2ON = 1 or PLL2RDY = 1).
In order to save power when PLL2 is not used, the value of DIVM2 must be set to 0.
...
...</description>
                <bitOffset>8</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>prescaler disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>division by 1 (bypass)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>division by 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>division by 3</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x20</name>
                    <description>division by 32 </description>
                    <value>0x20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3F</name>
                    <description>division by 63</description>
                    <value>0x3F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2PEN</name>
                <description>PLL2 DIVP divider output enable
Set and reset by software to enable the pll2_p_ck output of the PLL2.
To save power, when the pll2_p_ck output of the PLL2 is not used, the pll2_p_ck must be disabled.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_p_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck output enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2QEN</name>
                <description>PLL2 DIVQ divider output enable
Set and reset by software to enable the pll2_q_ck output of the PLL2.
To save power, when the pll2_q_ck output of the PLL2 is not used, the pll2_q_ck must be disabled.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_q_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2REN</name>
                <description>PLL2 DIVR divider output enable
Set and reset by software to enable the pll2_r_ck output of the PLL2.
To save power, DIVR2EN and DIVR2 bits must be set to 0 when the pll2_r_ck is not used.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_r_ck output disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL1DIVR</name>
            <displayName>RCC_PLL1DIVR</displayName>
            <description>RCC PLL1 dividers register </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x01010280</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL1N</name>
                <description>Multiplication factor for PLL1VCO
Set and reset by software to control the multiplication factor of the VCO.
These bits can be written only when the PLL is disabled (PLL1ON = 0 and PLL1RDY = 0).
...
...
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL1N = 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>PLL1N = 5</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PLL1N = 6</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x80</name>
                    <description>PLL1N = 129 (default after reset)</description>
                    <value>0x80</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1FF</name>
                    <description>PLL1N = 512</description>
                    <value>0x1FF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1P</name>
                <description>PLL1 DIVP division factor
Set and reset by software to control the frequency of the pll1_p_ck clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
Note that odd division factors are not allowed.
...</description>
                <bitOffset>9</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_p_ck = vco1_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_p_ck = vco1_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Not allowed</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll1_p_ck = vco1_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll1_p_ck = vco1_ck / 128 </description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1Q</name>
                <description>PLL1 DIVQ division factor
Set and reset by software to control the frequency of the pll1_q_ck clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
...</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_q_ck = vco1_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_q_ck = vco1_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll1_q_ck = vco1_ck / 3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll1_q_ck = vco1_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll1_q_ck = vco1_ck / 128</description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1R</name>
                <description>PLL1 DIVR division factor
Set and reset by software to control the frequency of the pll1_r_ck clock.
These bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).
...</description>
                <bitOffset>24</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_r_ck = Not allowed</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_r_ck = vco1_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll1_r_ck = vco1_ck / 3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll1_r_ck = vco1_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll1_r_ck = vco1_ck / 128</description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL1FRACR</name>
            <displayName>RCC_PLL1FRACR</displayName>
            <description>RCC PLL1 fractional divider register </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL1FRACN</name>
                <description>fractional part of the multiplication factor for PLL1 VCO
Set and reset by software to control the fractional part of the multiplication factor of the VCO. These bits can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO.
The software must set correctly these bits to insure that the VCO output frequency is between its valid frequency range, that is:
* 128 to 560 MHz if PLL1VCOSEL = 0
* 	150 to 420 MHz if PLL1VCOSEL = 1
VCO output frequency = Fref1_ck x (PLL1N + (PLL1FRACN / 213)), with
* 	PLL1N between 8 and 420
* 	PLL1FRACN can be between 0 and 213- 1
* 	The input frequency Fref1_ck must be between 1 and 16 MHz.
To change the PLL1FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows:
* 	Set the bit PLL1FRACEN to 0
* 	Write the new fractional value into PLL1FRACN
* 	Set the bit PLL1FRACEN to 1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>13</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL2DIVR</name>
            <displayName>RCC_PLL2DIVR</displayName>
            <description>RCC PLL1 dividers register </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x01010280</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL2N</name>
                <description>Multiplication factor for PLL2VCO
Set and reset by software to control the multiplication factor of the VCO.
These bits can be written only when the PLL is disabled (PLL2ON = 0 and PLL2RDY = 0).
...
...
Others: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PLL2N = 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>PLL2N = 5</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>PLL2N = 6</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x80</name>
                    <description>PLL2N = 129 (default after reset)</description>
                    <value>0x80</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1FF</name>
                    <description>PLL2N = 512</description>
                    <value>0x1FF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2P</name>
                <description>PLL2 DIVP division factor
Set and reset by software to control the frequency of the pll2_p_ck clock.
These bits can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0).
...</description>
                <bitOffset>9</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_p_ck = vco2_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck = vco2_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_p_ck = vco2_ck / 3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll2_p_ck = vco2_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll2_p_ck = vco2_ck / 128 </description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2Q</name>
                <description>PLL2 DIVQ division factor
Set and reset by software to control the frequency of the pll2_q_ck clock.
These bits can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0).
...</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_q_ck = vco2_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck = vco2_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_q_ck = vco2_ck / 3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll2_q_ck = vco2_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll2_q_ck = vco2_ck / 128</description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2R</name>
                <description>PLL2 DIVR division factor
Set and reset by software to control the frequency of the pll2_r_ck clock.
These bits can be written only when the PLL1 is disabled (PLL2ON = 0 and PLL2RDY = 0).
...</description>
                <bitOffset>24</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll2_r_ck = vco2_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck = vco2_ck / 2 (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_r_ck = vco2_ck / 3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>pll2_r_ck = vco2_ck / 4</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7F</name>
                    <description>pll2_r_ck = vco2_ck / 128</description>
                    <value>0x7F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_PLL2FRACR</name>
            <displayName>RCC_PLL2FRACR</displayName>
            <description>RCC PLL2 fractional divider register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL2FRACN</name>
                <description>fractional part of the multiplication factor for PLL2 VCO
Set and reset by software to control the fractional part of the multiplication factor of the VCO. These bits can be written at any time, allowing dynamic fine-tuning of the PLL2 VCO.
The software must set correctly these bits to insure that the VCO output frequency is between its valid frequency range, that is:
* 128 to 560 MHz if PLL2VCOSEL = 0
* 	150 to 420 MHz if PLL2VCOSEL = 1
VCO output frequency = Fref2_ck x (PLL2N + (PLL2FRACN / 213)), with
* 	PLL2N between 8 and 420
* 	PLL2FRACN can be between 0 and 213- 1
* 	The input frequency Fref2_ck must be between 1 and 16 MHz.
To change the PLL2FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows:
* 	Set the bit PLL2FRACEN to 0
* 	Write the new fractional value into PLL2FRACN
* 	Set the bit PLL2FRACEN to 1</description>
                <bitOffset>3</bitOffset>
                <bitWidth>13</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CIER</name>
            <displayName>RCC_CIER</displayName>
            <description>RCC clock source interrupt enable register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYIE</name>
                <description>LSI ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the LSI oscillator stabilization.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSI ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSI ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYIE</name>
                <description>LSE ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the LSE oscillator stabilization.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSE ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSIRDYIE</name>
                <description>CSI ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the CSI oscillator stabilization.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSI ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSI ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYIE</name>
                <description>HSI ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the HSI oscillator stabilization.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYIE</name>
                <description>HSE ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the HSE oscillator stabilization.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSE ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSE ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSI48RDYIE</name>
                <description>HSI48 ready interrupt enable
Set and reset by software to enable/disable interrupt caused by the HSI48 oscillator stabilization.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI48 ready interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI48 ready interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1RDYIE</name>
                <description>PLL1 ready interrupt enable
Set and reset by software to enable/disable interrupt caused by PLL1 lock.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL1 lock interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL1 lock interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2RDYIE</name>
                <description>PLL2 ready interrupt enable
Set and reset by software to enable/disable interrupt caused by PLL2 lock.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL2 lock interrupt disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2 lock interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CIFR</name>
            <displayName>RCC_CIFR</displayName>
            <description>RCC clock source interrupt flag register </description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYF</name>
                <description>LSI ready interrupt flag
Reset by software by writing LSIRDYC bit.
Set by hardware when the LSI clock becomes stable and LSIRDYIE is set.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the LSI (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the LSI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYF</name>
                <description>LSE ready interrupt flag
Reset by software by writing LSERDYC bit.
Set by hardware when the LSE clock becomes stable and LSERDYIE is set.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the LSE (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the LSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSIRDYF</name>
                <description>CSI ready interrupt flag
Reset by software by writing CSIRDYC bit.
Set by hardware when the CSI clock becomes stable and CSIRDYIE is set.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the CSI (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the CSI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYF</name>
                <description>HSI ready interrupt flag
Reset by software by writing HSIRDYC bit.
Set by hardware when the HSI clock becomes stable and HSIRDYIE is set.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the HSI (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the HSI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYF</name>
                <description>HSE ready interrupt flag
Reset by software by writing HSERDYC bit.
Set by hardware when the HSE clock becomes stable and HSERDYIE is set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the HSE (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the HSE</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSI48RDYF</name>
                <description>HSI48 ready interrupt flag
Reset by software by writing HSI48RDYC bit.
Set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by the HSI48 oscillator (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by the HSI48 oscillator</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1RDYF</name>
                <description>PLL1 ready interrupt flag
Reset by software by writing PLL1RDYC bit.
Set by hardware when the PLL1 locks and PLL1RDYIE is set.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by PLL1 lock (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by PLL1 lock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2RDYF</name>
                <description>PLL2 ready interrupt flag
Reset by software by writing PLL2RDYC bit.
Set by hardware when the PLL2 locks and PLL2RDYIE is set.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock ready interrupt caused by PLL2 lock (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock ready interrupt caused by PLL2 lock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSECSSF</name>
                <description>HSE clock security system interrupt flag
Reset by software by writing HSECSSC bit.
Set by hardware in case of HSE clock failure.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock security interrupt caused by HSE clock failure (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>clock security interrupt caused by HSE clock failure</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CICR</name>
            <displayName>RCC_CICR</displayName>
            <description>RCC clock source interrupt clear register </description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSIRDYC</name>
                <description>LSI ready interrupt clear
Set by software to clear LSIRDYF.
Reset by hardware when clear done.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSIRDYF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSIRDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDYC</name>
                <description>LSE ready interrupt clear
Set by software to clear LSERDYF.
Reset by hardware when clear done.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSERDYF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSERDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSIRDYC</name>
                <description>HSI ready interrupt clear
Set by software to clear CSIRDYF.
Reset by hardware when clear done.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSIRDYF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSIRDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSIRDYC</name>
                <description>HSI ready interrupt clear
Set by software to clear HSIRDYF.
Reset by hardware when clear done.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSIRDYF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSIRDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSERDYC</name>
                <description>HSE ready interrupt clear
Set by software to clear HSERDYF.
Reset by hardware when clear done.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSERDYF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSERDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSI48RDYC</name>
                <description>HSI48 ready interrupt clear
Set by software to clear HSI48RDYF.
Reset by hardware when clear done.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSI48RDYF no effect (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSI48RDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL1RDYC</name>
                <description>PLL1 ready interrupt clear
Set by software to clear PLL1RDYF.
Reset by hardware when clear done.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL1RDYF no effect (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL1RDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PLL2RDYC</name>
                <description>PLL2 ready interrupt clear
Set by software to clear PLL2RDYF.
Reset by hardware when clear done.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PLL2RDYF no effect (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PLL2RDYF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HSECSSC</name>
                <description>HSE clock security system interrupt clear
Set by software to clear HSECSSF.
Reset by hardware when clear done.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HSECSSF no effect (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HSECSSF cleared</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB1RSTR</name>
            <displayName>RCC_AHB1RSTR</displayName>
            <description>RCC AHB1 reset register </description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDMA1RST</name>
                <description>GPDMA1 block reset
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset GPDMA1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets GPDMA1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPDMA2RST</name>
                <description>GPDMA2 block reset
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset GPDMA2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets GPDMA2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCRST</name>
                <description>CRC block reset Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset CRC block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets CRC block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGRST</name>
                <description>RAMCFG block reset
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset RAMCFG block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets RAMCFG block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB2RSTR</name>
            <displayName>RCC_AHB2RSTR</displayName>
            <description>RCC AHB2 peripheral reset register </description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOARST</name>
                <description>GPIOA block reset
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the GPIOA block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the GPIOA block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBRST</name>
                <description>GPIOB block reset
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the GPIOB block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the GPIOB block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCRST</name>
                <description>GPIOC block reset
Set and reset by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the GPIOC block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the GPIOC block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODRST</name>
                <description>GPIOD block reset
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the GPIOD block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the GPIOD block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOHRST</name>
                <description>GPIOH block reset
Set and reset by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the GPIOH block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the GPIOH block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC1RST</name>
                <description>ADC1 block reset
Set and reset by software.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset ADC1 block (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets ADC1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAC12RST</name>
                <description>DAC block reset
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset DAC block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets DAC block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHRST</name>
                <description>HASH block reset
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset HASH block (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets HASH block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGRST</name>
                <description>RNG block reset
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset RNG block (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets RNG block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1LRSTR</name>
            <displayName>RCC_APB1LRSTR</displayName>
            <description>RCC APB1 peripheral low reset register </description>
            <addressOffset>0x74</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM2RST</name>
                <description>TIM2 block reset
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the TIM2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the TIM2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3RST</name>
                <description>TIM3 block reset
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the TIM3 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the TIM3 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM6RST</name>
                <description>TIM6 block reset
Set and reset by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the TIM6 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the TIM6 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM7RST</name>
                <description>TIM7 block reset
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the TIM7 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the TIM7 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPAMPRST</name>
                <description>OPAMP block reset
Set and reset by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the OPAMP block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the OPAMP block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI2RST</name>
                <description>SPI2 block reset
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the SPI2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the SPI2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3RST</name>
                <description>SPI3 block reset
Set and reset by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the SPI3 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the SPI3 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPRST</name>
                <description>COMP block reset
Set and reset by software.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the COMP block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the COMP block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2RST</name>
                <description>USART2 block reset
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the USART2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the USART2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART3RST</name>
                <description>USART3 block reset
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the USART3 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the USART3 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1RST</name>
                <description>I2C1 block reset
Set and reset by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the I2C1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the I2C1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C2RST</name>
                <description>I2C2 block reset
Set and reset by software.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the I2C2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the I2C2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C1RST</name>
                <description>I3C1 block reset
Set and reset by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the I3C1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the I3C1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRSRST</name>
                <description>CRS block reset
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the CRS block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the CRS block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1HRSTR</name>
            <displayName>RCC_APB1HRSTR</displayName>
            <description>RCC APB1 peripheral high reset register </description>
            <addressOffset>0x78</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTSRST</name>
                <description>DTS block reset
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the DTS block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the DTS block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2RST</name>
                <description>LPTIM2 block reset
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the LPTIM2 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the LPTIM2 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FDCAN1RST</name>
                <description>FDCAN1 block reset
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the FDCAN1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the FDCAN1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB2RSTR</name>
            <displayName>RCC_APB2RSTR</displayName>
            <description>RCC APB2 peripheral reset register </description>
            <addressOffset>0x7c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1RST</name>
                <description>TIM1 block reset
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the TIM1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the TIM1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1RST</name>
                <description>SPI1 block reset
Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the SPI1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the SPI1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1RST</name>
                <description>USART1 block reset
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the USART1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the USART1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USBFSRST</name>
                <description>USBFS block reset
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the USBFS block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the USBFS block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB3RSTR</name>
            <displayName>RCC_APB3RSTR</displayName>
            <description>RCC APB3 peripheral reset register </description>
            <addressOffset>0x80</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SBSRST</name>
                <description>SBS block reset
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the SBS block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the SBS block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1RST</name>
                <description>LPUART1 block reset
Set and reset by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the LPUART1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the LPUART1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C2RST</name>
                <description>I3C2RST block reset
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the I3C2RST block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the I3C2RST block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1RST</name>
                <description>LPTIM1 block reset
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the LPTIM1 block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the LPTIM1 block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VREFRST</name>
                <description>VREF block reset
Set and reset by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>does not reset the VREF block (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the VREF block</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB1ENR</name>
            <displayName>RCC_AHB1ENR</displayName>
            <description>RCC AHB1 peripherals clock register </description>
            <addressOffset>0x88</addressOffset>
            <size>0x20</size>
            <resetValue>0xD0000100</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDMA1EN</name>
                <description>GPDMA1 clock enable
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPDMA2EN</name>
                <description>GPDMA2 clock enable
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLITFEN</name>
                <description>Flash interface clock enable
Set and reset by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FLASH interface clock disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FLASH interface clock enabled (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCEN</name>
                <description>CRC clock enable
Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGEN</name>
                <description>RAMCFG clock enable
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RAMCFG peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RAMCFG peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKPRAMEN</name>
                <description>BKPRAM clock enable
Set and reset by software</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKPRAM peripheral clock disabled (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKPRAM peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1EN</name>
                <description>SRAM1 clock enable
Set and reset by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 clock disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 clock enabled (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB2ENR</name>
            <displayName>RCC_AHB2ENR</displayName>
            <description>RCC AHB2 peripheral clock register </description>
            <addressOffset>0x8c</addressOffset>
            <size>0x20</size>
            <resetValue>0xC0000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOAEN</name>
                <description>GPIOA clock enable
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOA peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOA peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBEN</name>
                <description>GPIOB clock enable
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOB peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOB peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCEN</name>
                <description>GPIOC clock enable
Set and reset by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOC peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOC peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODEN</name>
                <description>GPIOD clock enable
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOD peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOD peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOHEN</name>
                <description>GPIOH clock enable
Set and reset by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOH peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOH peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC1EN</name>
                <description>ADC1 peripherals clock enabled
Set and reset by software.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC1 peripherals clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC1 peripherals clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAC12EN</name>
                <description>DAC clock enable
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHEN</name>
                <description>HASH clock enable
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HASH peripheral clock disabled (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HASH peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGEN</name>
                <description>RNG clock enable
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RNG peripheral clock disabled (default after reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RNG peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2EN</name>
                <description>SRAM2 clock enable
Set and reset by software.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 clock disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 clock enabled (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1LENR</name>
            <displayName>RCC_APB1LENR</displayName>
            <description>RCC APB1 peripheral clock register </description>
            <addressOffset>0x9c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM2EN</name>
                <description>TIM2 clock enable
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3EN</name>
                <description>TIM3 clock enable
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM3 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM3 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM6EN</name>
                <description>TIM6 clock enable
Set and reset by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM6 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM6 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM7EN</name>
                <description>TIM7 clock enable
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM7 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM7 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGEN</name>
                <description>WWDG clock enable
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WWDG peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>WWDG peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPAMPEN</name>
                <description>OPAMP clock enable
Set and reset by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OPAMP peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OPAMP peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI2EN</name>
                <description>SPI2 clock enable
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3EN</name>
                <description>SPI3 clock enable
Set and reset by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI3 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI3 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPEN</name>
                <description>COMP clock enable
Set and reset by software.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COMP peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COMP peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2EN</name>
                <description>USART2 clock enable
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART3EN</name>
                <description>USART3 clock enable
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART3 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART3 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1EN</name>
                <description>I2C1 clock enable
Set and reset by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2C1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2C1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C2EN</name>
                <description>I2C2 clock enable
Set and reset by software.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2C2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2C2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C1EN</name>
                <description>I3C1 clock enable
Set and reset by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRSEN</name>
                <description>CRS clock enable
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRS peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRS peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1HENR</name>
            <displayName>RCC_APB1HENR</displayName>
            <description>RCC APB1 peripheral clock register </description>
            <addressOffset>0xa0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTSEN</name>
                <description>DTS clock enable
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DTS peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DTS peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2EN</name>
                <description>LPTIM2 clock enable
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM2 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM2 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FDCAN1EN</name>
                <description>FDCAN1 peripheral clock enable
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FDCAN1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FDCAN1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB2ENR</name>
            <displayName>RCC_APB2ENR</displayName>
            <description>RCC APB2 peripheral clock register </description>
            <addressOffset>0xa4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1EN</name>
                <description>TIM1 clock enable
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1EN</name>
                <description>SPI1 clock enable
Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1EN</name>
                <description>USART1 clock enable
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USBFSEN</name>
                <description>USBFS clock enable
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USBFS peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USBFS peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB3ENR</name>
            <displayName>RCC_APB3ENR</displayName>
            <description>RCC APB3 peripheral clock register </description>
            <addressOffset>0xa8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SBSEN</name>
                <description>SBS clock enable
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SBS peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SBS peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1EN</name>
                <description>LPUART1 clock enable
Set and reset by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPUART1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C2EN</name>
                <description>I3C2EN clock enable
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C2EN peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C2EN peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1EN</name>
                <description>LPTIM1 clock enable
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM1 peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM1 peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VREFEN</name>
                <description>VREF clock enable
Set and reset by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VREF peripheral clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VREF peripheral clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCAPBEN</name>
                <description>RTC APB interface clock enable
Set and reset by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTC APB interface clock disabled (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTC APB interface clock enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB1LPENR</name>
            <displayName>RCC_AHB1LPENR</displayName>
            <description>RCC AHB1 sleep clock register </description>
            <addressOffset>0xb0</addressOffset>
            <size>0x20</size>
            <resetValue>0xF13AD103</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPDMA1LPEN</name>
                <description>GPDMA1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPDMA2LPEN</name>
                <description>GPDMA2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPDMA2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPDMA2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLITFLPEN</name>
                <description>Flash interface (FLITF) clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FLITF peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FLITF peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCLPEN</name>
                <description>CRC clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RAMCFGLPEN</name>
                <description>RAMCFG clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RAMCFG peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RAMCFG peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BKPRAMLPEN</name>
                <description>BKPRAM clock enable during sleep mode
Set and reset by software</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>BKPRAM peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BKPRAM peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ICACHELPEN</name>
                <description>ICACHE clock enable during sleep mode
Set and reset by software</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ICACHE peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ICACHE peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM1LPEN</name>
                <description>SRAM1 clock enable during sleep mode
Set and reset by software</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM1 peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_AHB2LPENR</name>
            <displayName>RCC_AHB2LPENR</displayName>
            <description>RCC AHB2 sleep clock register </description>
            <addressOffset>0xb4</addressOffset>
            <size>0x20</size>
            <resetValue>0xC01F1DFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPIOALPEN</name>
                <description>GPIOA clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOA peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOA peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOBLPEN</name>
                <description>GPIOB clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOB peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOB peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOCLPEN</name>
                <description>GPIOC clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOC peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOC peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIODLPEN</name>
                <description>GPIOD clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOD peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOD peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GPIOHLPEN</name>
                <description>GPIOH clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>GPIOH peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>GPIOH peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADC1LPEN</name>
                <description>ADC1 peripherals clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ADC1 peripherals clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ADC1 peripherals clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DAC12LPEN</name>
                <description>DAC clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DAC peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DAC peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HASHLPEN</name>
                <description>HASH clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>HASH peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>HASH peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGLPEN</name>
                <description>RNG clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RNG peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RNG peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SRAM2LPEN</name>
                <description>SRAM2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SRAM2 peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SRAM2 peripheral clock enabled during sleep mode (default after reset) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1LLPENR</name>
            <displayName>RCC_APB1LLPENR</displayName>
            <description>RCC APB1 sleep clock register </description>
            <addressOffset>0xc4</addressOffset>
            <size>0x20</size>
            <resetValue>0xDFFEC9FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM2LPEN</name>
                <description>TIM2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM3LPEN</name>
                <description>TIM3 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM3 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM3 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM6LPEN</name>
                <description>TIM6 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM6 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM6 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIM7LPEN</name>
                <description>TIM7 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM7 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM7 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGLPEN</name>
                <description>WWDG clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WWDG peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>WWDG peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPAMPLPEN</name>
                <description>OPAMP clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OPAMP peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OPAMP peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI2LPEN</name>
                <description>SPI2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3LPEN</name>
                <description>SPI3 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI3 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI3 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMPLPEN</name>
                <description>COMP clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>COMP peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>COMP peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2LPEN</name>
                <description>USART2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART3LPEN</name>
                <description>USART3 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART3 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART3 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1LPEN</name>
                <description>I2C1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2C1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2C1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C2LPEN</name>
                <description>I2C2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2C2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2C2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C1LPEN</name>
                <description>I3C1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRSLPEN</name>
                <description>CRS clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRS peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRS peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB1HLPENR</name>
            <displayName>RCC_APB1HLPENR</displayName>
            <description>RCC APB1 sleep clock register </description>
            <addressOffset>0xc8</addressOffset>
            <size>0x20</size>
            <resetValue>0x4080022B</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DTSLPEN</name>
                <description>DTS clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DTS peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DTS peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2LPEN</name>
                <description>LPTIM2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM2 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FDCAN1LPEN</name>
                <description>FDCAN1 peripheral clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FDCAN1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FDCAN1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB2LPENR</name>
            <displayName>RCC_APB2LPENR</displayName>
            <description>RCC APB2 sleep clock register </description>
            <addressOffset>0xcc</addressOffset>
            <size>0x20</size>
            <resetValue>0x017F7800</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIM1LPEN</name>
                <description>TIM1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIM1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIM1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI1LPEN</name>
                <description>SPI1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART1LPEN</name>
                <description>USART1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USBFSLPEN</name>
                <description>USBFS clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USBFS peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USBFS peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_APB3LPENR</name>
            <displayName>RCC_APB3LPENR</displayName>
            <description>RCC APB3 sleep clock register </description>
            <addressOffset>0xd0</addressOffset>
            <size>0x20</size>
            <resetValue>0x0030FA42</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SBSLPEN</name>
                <description>SBS clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SBS peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SBS peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1LPEN</name>
                <description>LPUART1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPUART1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPUART1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C2LPEN</name>
                <description>I3C2 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I3C2 peripheral clock disabled during sleep mode </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I3C2 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM1LPEN</name>
                <description>LPTIM1 clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPTIM1 peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LPTIM1 peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VREFLPEN</name>
                <description>VREF clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>VREF peripheral clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>VREF peripheral clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCAPBLPEN</name>
                <description>RTC APB interface clock enable during sleep mode
Set and reset by software.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTC APB interface clock disabled during sleep mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTC APB interface clock enabled during sleep mode (default after reset)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR1</name>
            <displayName>RCC_CCIPR1</displayName>
            <description>RCC kernel clock configuration register </description>
            <addressOffset>0xd8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>USART1SEL</name>
                <description>USART1 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk2 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>lse_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART2SEL</name>
                <description>USART2 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk1 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>lse_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USART3SEL</name>
                <description>USART3 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk1 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>lse_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIMICSEL</name>
                <description>TIM2, TIM3 and LPTIM2 input capture source selection
Set and reset by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No internal clock available for timers input capture (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>hsi_ker_ck/1024, hsi_ker_ck/8 and csi_ker_ck/128 selected for timers input capture</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR2</name>
            <displayName>RCC_CCIPR2</displayName>
            <description>RCC kernel clock configuration register </description>
            <addressOffset>0xdc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LPTIM1SEL</name>
                <description>LPTIM1 kernel clock source selection
others: reserved, the kernel clock is disabled</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk3 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>lse_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>lsi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>per_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPTIM2SEL</name>
                <description>LPTIM2 kernel clock source selection
others: reserved, the kernel clock is disabled</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk1 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>lse_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>lsi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>per_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR3</name>
            <displayName>RCC_CCIPR3</displayName>
            <description>RCC kernel clock configuration register </description>
            <addressOffset>0xe0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPI1SEL</name>
                <description>SPI1 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_q_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AUDIOCLK selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>per_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI2SEL</name>
                <description>SPI2 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_q_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AUDIOCLK selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>per_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPI3SEL</name>
                <description>SPI3 kernel clock source selection
Set and reset by software.
others: reserved, the kernel clock is disabled</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>pll1_q_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_p_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>AUDIOCLK selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>per_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPUART1SEL</name>
                <description>LPUART1 kernel clock source selection
others: reserved, the kernel clock is disabled</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk3 s elected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>lse_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR4</name>
            <displayName>RCC_CCIPR4</displayName>
            <description>RCC kernel clock configuration register </description>
            <addressOffset>0xe4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYSTICKSEL</name>
                <description>SYSTICK clock source selection
Note: rcc_hclk frequency must be four times higher than
lsi_ker_ck/lse_ck (period (LSI/LSE) ≥ 4 * period (HCLK).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_hclk/8 selected as clock source (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>lsi_ker_ck[1] selected as clock source</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>lse_ck[1] selected as clock source</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>reserved, the kernel clock is disabled</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>USBFSSEL</name>
                <description>USBFS kernel clock source selection</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock is selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hsi48_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C1SEL</name>
                <description>I2C1 kernel clock source selection</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk1 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2C2SEL</name>
                <description>I2C2 kernel clock source selection</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk1 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>csi_ker_ck selected as kernel clock </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C1SEL</name>
                <description>I3C1 kernel clock source selection</description>
                <bitOffset>24</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk3 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>no clock selected</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I3C2SEL</name>
                <description>I3C2 kernel clock source selection</description>
                <bitOffset>26</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_pclk3 selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll2_r_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>no clock selected</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_CCIPR5</name>
            <displayName>RCC_CCIPR5</displayName>
            <description>RCC kernel clock configuration register </description>
            <addressOffset>0xe8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADCDACSEL</name>
                <description>ADC and DAC kernel clock source selection
others: reserved, the kernel clock is disabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rcc_hclk selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>sys_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_r_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>hse_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>hsi_ker_ck selected as kernel clock</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DACSEL</name>
                <description>DAC hold clock</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>dac_hold_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>dac_hold_ck selected as kernel clock </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RNGSEL</name>
                <description>RNG kernel clock source selection</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>hsi48_ker_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>lse_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>lsi_ker_ck selected as kernel clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FDCAN1SEL</name>
                <description>FDCAN1 kernel clock source selection</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>hse_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>pll1_q_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>pll2_q_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>reserved, the kernel clock is disabled</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKPERSEL</name>
                <description>per_ck clock source selection</description>
                <bitOffset>30</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>hsi_ker_ck selected as kernel clock (default after reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>csi_ker_ck selected as kernel clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>hse_ck selected as kernel clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>reserved, the per_ck clock is disabled</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_BDCR</name>
            <displayName>RCC_BDCR</displayName>
            <description>RCC Backup domain control register </description>
            <addressOffset>0xf0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LSEON</name>
                <description>LSE oscillator enabled
Set and reset by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSE oscillator OFF (default after Backup domain reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE oscillator ON </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSERDY</name>
                <description>LSE oscillator ready
Set and reset by hardware to indicate when the LSE is stable.
This bit needs 6 cycles of lse_ck clock to fall down after LSEON has been set to 0.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSE oscillator not ready (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE oscillator ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSEBYP</name>
                <description>LSE oscillator bypass
Set and reset by software to bypass oscillator in debug mode. This bit must not be written when the LSE is enabled (by LSEON) or ready (LSERDY = 1)</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSE oscillator not bypassed (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE oscillator bypassed</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSEDRV</name>
                <description>LSE oscillator driving capability
Set by software to select the driving capability of the LSE oscillator.
These bit can be written only if LSE oscillator is disabled (LSEON = 0 and LSERDY = 0).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>lowest drive (default after Backup domain reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>medium-low drive</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>medium-high drive</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>highest drive</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSON</name>
                <description>LSE clock security system enable
Set by software to enable the clock security system on 32 kHz oscillator.
LSECSSON must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware) and after RTCSEL is selected.
Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD = 1). In that case the software must disable LSECSSON.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CSS on 32 kHz oscillator OFF (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CSS on 32 kHz oscillator ON</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSECSSD</name>
                <description>LSE clock security system failure detection
Set by hardware to indicate when a failure has been detected by the clock security system on the external 32 kHz oscillator.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no failure detected on 32 kHz oscillator (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>failure detected on 32 kHz oscillator</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSEEXT</name>
                <description>low-speed external clock type in bypass mode
Set and reset by software to select the external clock type (analog or digital).
The external clock must be enabled with the LSEON bit, to be used by the device.
The LSEEXT bit can be written only if the LSE oscillator is disabled.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSE in analog mode (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE in digital mode (do not use if RTC is active).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCSEL</name>
                <description>RTC clock source selection
Set by software to select the clock source for the RTC.
These bits can be written only one time (except in case of failure detection on LSE).
These bits must be written before LSECSSON is enabled.
The VSWRST bit can be used to reset them, then it can be written one time again.
If HSE is selected as RTC clock, this clock is lost when the system is in Stop mode or in case of a pin reset (NRST).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no clock (default after Backup domain reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE selected as RTC clock</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LSI selected as RTC clock</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>HSE divided by RTCPRE value selected as RTC clock</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTCEN</name>
                <description>RTC clock enable
Set and reset by software.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>rtc_ck disabled (default after Backup domain reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>rtc_ck enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VSWRST</name>
                <description>VSwitch domain software reset
Set and reset by software.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>reset not activated (default after Backup domain reset)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the entire VSW domain</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSCOEN</name>
                <description>Low-speed clock output (LSCO) enable
Set and cleared by software.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSCO output disabled </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSCO output enabled </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSCOSEL</name>
                <description>Low-speed clock output selection
Set and cleared by software.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSI clock selected </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSE clock selected </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSION</name>
                <description>LSI oscillator enable
Set and cleared by software.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSI oscillator off </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSI oscillator on</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSIRDY</name>
                <description>LSI oscillator ready
Set and cleared by hardware to indicate when the LSI oscillator is stable.
After the LSION bit is cleared, LSIRDY goes low after three internal low-speed oscillator clock cycles.
This bit is set when the LSI is used by IWDG or RTC, even if LSION = 0.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LSI oscillator not ready</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSI oscillator ready</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RCC_RSR</name>
            <displayName>RCC_RSR</displayName>
            <description>RCC reset status register </description>
            <addressOffset>0xf4</addressOffset>
            <size>0x20</size>
            <resetValue>0x0C000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RMVF</name>
                <description>remove reset flag
Set and reset by software to reset the value of the reset flags.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>reset of the reset flags not activated (default after power-on reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>resets the value of the reset flags</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PINRSTF</name>
                <description>pin reset flag (NRST)
Reset by software by writing the RMVF bit.
Set by hardware when a reset from pin occurs.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no reset from pin occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>reset from pin occurred (default after power-on reset) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BORRSTF</name>
                <description>BOR reset flag
Reset by software by writing the RMVF bit.
Set by hardware when a BOR reset occurs (pwr_bor_rst).</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no BOR reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BOR reset occurred (default after power-on reset) </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SFTRSTF</name>
                <description>system reset from CPU reset flag
Reset by software by writing the RMVF bit.
Set by hardware when the system reset is due to CPU.The CPU can generate a system reset by writing SYSRESETREQ bit of AIRCR register of the core M33.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no CPU software reset occurred (default after power-on reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>a system reset has been generated by the CPU</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IWDGRSTF</name>
                <description>independent watchdog reset flag
Reset by software by writing the RMVF bit.
Set by hardware when an independent watchdog reset occurs.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no independent watchdog reset occurred (default after power-on reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>independent watchdog reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WWDGRSTF</name>
                <description>window watchdog reset flag
Reset by software by writing the RMVF bit.
Set by hardware when a window watchdog reset occurs.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no window watchdog reset occurred from WWDG (default after power-on reset) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>window watchdog reset occurred from WWDG</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LPWRRSTF</name>
                <description>Low-power reset flag
Set by hardware when a reset occurs due to Stop or Standby mode entry, whereas the corresponding nRST_STOP, nRST_STBY option bit is cleared.
Cleared by writing to the RMVF bit.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No illegal low-power mode reset occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Illegal low-power mode reset occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>SPI1</name>
        <description>Serial peripheral interface</description>
        <groupName>SPI</groupName>
        <baseAddress>0x40013000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>SPI1</name>
          <description>SPI1 global interrupt</description>
          <value>55</value>
        </interrupt>
        <registers>
          <register>
            <name>SPI_CR1</name>
            <displayName>SPI_CR1</displayName>
            <description>SPI/I2S control register 1 </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SPE</name>
                <description>serial peripheral enable
This bit is set by and cleared by software.
When SPE=1, SPI data transfer is enabled, SPI_CFG1 and SPI_CFG2 configuration registers, CRCPOLY, UDRDR, IOLOCK bit in the SPI_CR1 register are write protected. They can be changed only when SPE=0.
When SPE=0 any SPI operation is stopped and disabled, all the pending requests of the events with enabled interrupt are blocked except the MODF interrupt request (but their pending still propagates the request of the spi_plck clock), the SS output is deactivated at master, the RDY signal keeps not ready status at slave, the internal state machine is reseted, all the FIFOs content is flushed, CRC calculation initialized, receive data register is read zero.
SPE is cleared and cannot be set when MODF error flag is active.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Serial peripheral disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Serial peripheral enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MASRX</name>
                <description>master automatic suspension in Receive mode
This bit is set and cleared by software to control continuous SPI transfer in master receiver mode and automatic management in order to avoid overrun condition.
When SPI communication is suspended by hardware automatically, it could happen that few bits of next frame are already clocked out due to internal synchronization delay.
This is why, the automatic suspension is not quite reliable when size of data drops below 8 bits. In this case, a safe suspension can be achieved by combination with delay inserted between data frames applied when MIDI parameter keeps a non zero value; sum of data size and the interleaved SPI cycles should always produce interval at length of 8 SPI clock periods at minimum. After software clearing of the SUSP bit, the communication resumes and continues by subsequent bits transaction without any next constraint. Prior the SUSP bit is cleared, the user must release the RxFIFO space as much as possible by reading out all the data packets available at RxFIFO based on the RXP flag indication to prevent any subsequent suspension.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI flow/clock generation is continuous, regardless of overrun condition. (data are lost)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI flow is suspended temporary on RxFIFO full condition, before reaching overrun condition. The SUSP flag is set when the SPI communication is suspended. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSTART</name>
                <description>master transfer start
This bit can be set by software if SPI is enabled only to start an SPI or I2S/PCM communication. In SPI mode, it is cleared by hardware when end of transfer (EOT) flag is set or when a transaction suspend request is accepted. In I2S/PCM mode, it is also cleared by hardware as described in the .
In SPI mode, the bit is taken into account at master mode only. If transmission is enabled, communication starts or continues only if any data is available in the transmission FIFO.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>master transfer is at idle</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>master transfer is on-going or temporary suspended by automatic suspend</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSUSP</name>
                <description>master SUSPend request
This bit reads as zero.
In Master mode, when this bit is set by software, the CSTART bit is reset at the end of the current frame and communication is suspended. The user has to check SUSP flag to check end of the frame transaction.
The Master mode communication must be suspended (using this bit or keeping TXDR empty) before going to Low-power mode. Can be used in SPI or I2S mode.
After software suspension, SUSP flag has to be cleared and SPI disabled and re-enabled before the next transaction starts.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>HDDIR</name>
                <description>Rx/Tx direction at Half-duplex mode
In Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data transfer. This bit is ignored in Full-Duplex or any Simplex configuration.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI is Receiver</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI is transmitter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSI</name>
                <description>internal SS signal input level
This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the peripheral SS input internally and the I/O value of the SS pin is ignored.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC33_17</name>
                <description>32-bit CRC polynomial configuration</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full size (33-bit or 17-bit) CRC polynomial is not used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Full size (33-bit or 17-bit) CRC polynomial is used</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RCRCINI</name>
                <description>CRC calculation initialization pattern control for receiver</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>All zero pattern is applied</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>All ones pattern is applied</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCRCINI</name>
                <description>CRC calculation initialization pattern control for transmitter</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>all zero pattern is applied</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>all ones pattern is applied</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IOLOCK</name>
                <description>locking the AF configuration of associated IOs
This bit is set by software and cleared by hardware whenever the SPE bit is changed from 1 to 0.
When this bit is set, SPI_CFG2 register content cannot be modified. This bit can be set when SPI is disabled only else it is write protected. It is cleared and cannot be set when MODF bit is set.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>AF configuration is not locked</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>AF configuration is locked </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CR2</name>
            <displayName>SPI_CR2</displayName>
            <description>SPI/I2S control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSIZE</name>
                <description>number of data at current transfer
When these bits are changed by software, the SPI has to be disabled.
Endless transaction is initialized when CSTART is set while zero value is stored at TSIZE. TSIZE cannot be set to 0xFFFF respective 0x3FFF value when CRC is enabled.
Note: TSIZE[15:10] bits are reserved at limited feature set instances and must be kept at reset value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CFG1</name>
            <displayName>SPI_CFG1</displayName>
            <description>SPI/I2S configuration register 1 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00070007</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSIZE</name>
                <description>number of bits in at single SPI data frame
.....
Note: Maximum data size can be limited up to 16-bits at some instances. At instances with limited set of features, DSIZE2:0] bits are reserved and must be kept at reset state. DSIZE[4:3] bits then control next settings of data size:
00xxx: 8-bits
01xxx: 16-bits
10xxx: 24-bits
11xxx: 32-bits.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>not used</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>not used</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>not used</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4-bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5-bits</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6-bits</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7-bits</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8-bits</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1D</name>
                    <description>30-bits</description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1E</name>
                    <description>31-bits</description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>32-bits</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FTHLV</name>
                <description>FIFO threshold level
Defines number of data frames at single data packet. Size of the packet should not exceed 1/2 of FIFO space.
SPI interface is more efficient if configured packet sizes are aligned with data register access parallelism:
If SPI data register is accessed as a 16-bit register and DSIZE ≤ 8 bit, better to select FTHLV = 2, 4, 6.
If SPI data register is accessed as a 32-bit register and DSIZE&gt; 8 bit, better to select FTHLV = 2, 4, 6, while if DSIZE ≤ 8bit, better to select FTHLV = 4, 8, 12.
Note: FTHLV[3:2] bits are reserved at instances with limited set of features</description>
                <bitOffset>5</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1-data</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2-data</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3-data</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4-data</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5-data</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6-data</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7-data</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8-data</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>9-data</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>10-data</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>11-data</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>12-data</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>13-data</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>14-data</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>15-data</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>16-data</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDRCFG</name>
                <description>behavior of slave transmitter at underrun condition
For more details see underrun condition.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>slave sends a constant pattern defined by the user at the SPI_UDRDR register</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave repeats lastly received data from master. When slave is configured at transmit only mode (COMM[1:0]=01), all zeros pattern is repeated. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXDMAEN</name>
                <description>Rx DMA stream enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Rx-DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Rx-DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXDMAEN</name>
                <description>Tx DMA stream enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Tx DMA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Tx DMA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCSIZE</name>
                <description>length of CRC frame to be transacted and compared
Most significant bits are taken into account from polynomial calculation when CRC result is transacted or compared. The length of the polynomial is not affected by this setting.
.....
The value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size corresponds to DSIZE maximum at the instance.
Note: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances where data size is limited to 16-bit.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>4-bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>5-bits</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>6-bits</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>7-bits</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>8-bits</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1D</name>
                    <description>30-bits</description>
                    <value>0x1D</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1E</name>
                    <description>31-bits</description>
                    <value>0x1E</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1F</name>
                    <description>32-bits</description>
                    <value>0x1F</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCEN</name>
                <description>hardware CRC computation enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC calculation disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC calculation enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MBR</name>
                <description>master baud rate prescaler setting
Note: MBR setting is considered at slave working at TI mode, too (see mode).</description>
                <bitOffset>28</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI master clock/2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI master clock/4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>SPI master clock/8</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>SPI master clock/16</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>SPI master clock/32</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>SPI master clock/64</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>SPI master clock/128</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>SPI master clock/256</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BPASS</name>
                <description>bypass of the prescaler at master baud rate clock generator</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>bypass is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>bypass is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CFG2</name>
            <displayName>SPI_CFG2</displayName>
            <description>SPI/I2S configuration register 2 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MSSI</name>
                <description>Master SS Idleness
Specifies an extra delay, expressed in number of SPI clock cycle periods, inserted additionally between active edge of SS opening a session and the beginning of the first data frame of the session in Master mode when SSOE is enabled.
...
Note: This feature is not supported in TI mode.
To include the delay, the SPI must be disabled and re-enabled between sessions.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no extra delay</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 clock cycle period delay added</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>15 clock cycle periods delay added</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MIDI</name>
                <description>master Inter-Data Idleness
Specifies minimum time delay (expressed in SPI clock cycles periods) inserted between two consecutive data frames in Master mode.
...
Note: This feature is not supported in TI mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no delay</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 clock cycle period delay</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>15 clock cycle periods delay</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RDIOM</name>
                <description>RDY signal input/output management
Note: When DSIZE at the SPI_CFG1 register is configured shorter than 8-bit, the RDIOM bit has to be kept at zero.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RDY signal is defined internally fixed as permanently active (RDIOP setting has no effect)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RDY signal is overtaken from alternate function input (at master case) or output (at slave case) of the dedicated pin (RDIOP setting takes effect)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RDIOP</name>
                <description>RDY signal input/output polarity</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>high level of the signal means the slave is ready for communication</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>low level of the signal means the slave is ready for communication</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IOSWP</name>
                <description>swap functionality of MISO and MOSI pins
When this bit is set, the function of MISO and MOSI pins alternate functions are inverted.
Original MISO pin becomes MOSI and original MOSI pin becomes MISO.
Note: This bit can be also used in PCM and I2S modes to swap SDO and SDI pins.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no swap</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MOSI and MISO are swapped</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COMM</name>
                <description>SPI Communication Mode</description>
                <bitOffset>17</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>full-duplex</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>simplex transmitter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>simplex receiver</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>half-duplex</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SP</name>
                <description>serial protocol
others: reserved, must not be used</description>
                <bitOffset>19</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI Motorola</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI TI</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MASTER</name>
                <description>SPI Master</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI Slave</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI Master</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LSBFRST</name>
                <description>data frame format
Note: This bit can be also used in PCM and I2S modes.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>MSB transmitted first</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LSB transmitted first</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPHA</name>
                <description>clock phase</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the first clock transition is the first data capture edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the second clock transition is the first data capture edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPOL</name>
                <description>clock polarity</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SCK signal is at 0 when idle</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SCK signal is at 1 when idle</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSM</name>
                <description>software management of SS signal input
When master uses hardware SS output (SSM=0 and SSOE=1) the SS signal input is forced to not active state internally to prevent master mode fault error.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SS input value is determined by the SS PAD</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SS input value is determined by the SSI bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSIOP</name>
                <description>SS input/output polarity</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>low level is active for SS signal</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>high level is active for SS signal</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSOE</name>
                <description>SS output enable
This bit is taken into account in Master mode only</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SS output is disabled and the SPI can work in multi-master configuration</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SS output is enabled. The SPI cannot work in a multi-master environment. It forces the SS pin at inactive level after the transfer is completed or SPI is disabled with respect to SSOM, MIDI, MSSI, SSIOP bits setting</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SSOM</name>
                <description>SS output management in Master mode
This bit is taken into account in Master mode when SSOE is enabled. It allows the SS output to be configured between two consecutive data transfers.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SS is kept at active level till data transfer is completed, it becomes inactive with EOT flag</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI data frames are interleaved with SS non active pulses when MIDI[3:0]&gt;1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AFCNTR</name>
                <description>alternate function GPIOs control
This bit is taken into account when SPE=0 only
When SPI has to be disabled temporary for a specific configuration reason (e.g. CRC reset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated outputs configured at alternate function mode by keeping them forced at state corresponding the current SPI configuration.
Note: This bit can be also used in PCM and I2S modes.
Note: The bit AFCNTR must not be set to 1, when the block is in slave mode.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The peripheral takes no control of GPIOs while it is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The peripheral keeps always control of all associated GPIOs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_IER</name>
            <displayName>SPI_IER</displayName>
            <description>SPI/I2S interrupt enable register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXPIE</name>
                <description>RXP interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXP interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXP interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXPIE</name>
                <description>TXP interrupt enable
TXPIE is set by software and cleared by TXTF flag set event.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXP interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXP interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DXPIE</name>
                <description>DXP interrupt enabled
DXPIE is set by software and cleared by TXTF flag set event.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DXP interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DXP interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOTIE</name>
                <description>EOT, SUSP and TXC interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>EOT/SUSP/TXC interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>EOT/SUSP/TXC interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXTFIE</name>
                <description>TXTFIE interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXTF interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXTF interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDRIE</name>
                <description>UDR interrupt enable</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UDR interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UDR interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRIE</name>
                <description>OVR interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OVR interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OVR interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCEIE</name>
                <description>CRC error interrupt enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CRC interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIFREIE</name>
                <description>TIFRE interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIFRE interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIFRE interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODFIE</name>
                <description>mode Fault interrupt enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>MODF interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MODF interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_SR</name>
            <displayName>SPI_SR</displayName>
            <description>SPI/I2S status register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00001002</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXP</name>
                <description>Rx-Packet available
In I2S mode, it must be interpreted as follow: RxFIFO level is lower than FTHLV
In I2S mode, it must be interpreted as follow: RxFIFO level is higher or equal to FTHLV
RXP flag is changed by hardware. It monitors number of overall data currently available at RxFIFO if SPI is enabled. It has to be checked once a data packet is completely read out from RxFIFO.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>In SPI mode, it must be interpreted as follow: RxFIFO is empty or a not complete data packet is received </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>In SPI mode, it must be interpreted as follow: RxFIFO contains at least 1 data packet </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXP</name>
                <description>Tx-Packet space available
In I2S mode, it must be interpreted as follow: there is less than FTHLV free locations in the TxFIFO
In I2S mode, it must be interpreted as follow: there is FTHLV or more than FTHLV free locations in the TxFIFO
TXP flag is changed by hardware. It monitors overall space currently available at TxFIFO no matter if SPI is enabled or not. It has to be checked once a complete data packet is stored at TxFIFO.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>In SPI mode, it must be interpreted as follow: there is not enough space to locate next data packet at TxFIFO </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>In SPI mode, it must be interpreted as follow: TxFIFO has enough free location to host 1 data packet </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DXP</name>
                <description>duplex packet
DXP flag is set whenever both TXP and RXP flags are set regardless SPI mode.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TxFIFO is Full and/or RxFIFO is Empty</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>both TxFIFO has space for write and RxFIFO contains for read a single packet at least</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOT</name>
                <description>end of transfer
EOT is set by hardware as soon as a full transfer is complete, that is when SPI is re-enabled or when TSIZE number of data have been transmitted and/or received on the SPI. EOT is cleared when SPI is re-enabled or by writing 1 to EOTC bit of SPI_IFCR optionally.
EOT flag triggers an interrupt if EOTIE bit is set.
If DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to download the last packets contained into RxFIFO in one-shot.
In master, EOT event terminates the data transaction and handles SS output optionally. When CRC is applied, the EOT event is extended over the CRC frame transaction.
To restart the internal state machine properly, SPI is strongly suggested to be disabled and re-enabled before next transaction starts despite its setting is not changed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>transfer is on-going or not started</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>transfer complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXTF</name>
                <description>transmission transfer filled
TXTF is set by hardware as soon as all of the data packets in a transfer have been submitted for transmission by application software or DMA, that is when TSIZE number of data have been pushed into the TxFIFO.
This bit is cleared by software write 1 to TXTFC bit of SPI_IFCR exclusively.
TXTF flag triggers an interrupt if TXTFIE bit is set.
TXTF setting clears the TXPIE and DXPIE masks so to off-load application software from calculating when to disable TXP and DXP interrupts.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>upload of TxFIFO is on-going or not started</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TxFIFO upload is finished</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDR</name>
                <description>underrun
This bit is cleared when SPI is re-enabled or by writing 1 to UDRC bit of SPI_IFCR optionally.
Note: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when available) this flag applies to Master and Slave mode</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no underrun</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>underrun detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVR</name>
                <description>overrun
This bit is cleared when SPI is re-enabled or by writing 1 to OVRC bit of SPI_IFCR optionally.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no overrun</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>overrun detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CRCE</name>
                <description>CRC error
This bit is cleared when SPI is re-enabled or by writing 1 to CRCEC bit of SPI_IFCR optionally.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no CRC error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CRC error detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIFRE</name>
                <description>TI frame format error
This bit is cleared by writing 1 to TIFREC bit of SPI_IFCR exclusively.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no TI Frame Error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TI frame error detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODF</name>
                <description>mode fault
This bit is cleared by writing 1 to MODFC bit of SPI_IFCR exclusively.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no mode fault</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>mode fault detected. When MODF is set, SPE and IOLOCK bits of SPI_CR1 register are reset and their setting is blocked. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSP</name>
                <description>suspension status
In Master mode, SUSP is set by hardware either as soon as the current frame is completed after CSUSP request is done or at master automatic suspend receive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.
SUSP generates an interrupt when EOTIE is set.
This bit has to be cleared prior SPI is disabled and this is done by writing 1 to SUSPC bit of SPI_IFCR exclusively.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI not suspended (Master mode active or other mode). </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master mode is suspended (current frame completed).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXC</name>
                <description>TxFIFO transmission complete
The flag behavior depends on TSIZE setting.
When TSIZE=0 the TXC is changed by hardware exclusively and it raises each time the TxFIFO becomes empty and there is no activity on the bus.
If TSIZE &lt;&gt;0 there is no specific reason to monitor TXC as it just copies the EOT flag value including its software clearing. The TXC generates an interrupt when EOTIE is set.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>current data transaction is still ongoing, data is available in TxFIFO or last frame transmission is on going. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>last TxFIFO frame transmission complete</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXPLVL</name>
                <description>RxFIFO packing level
When RXWNE=0 and data size is set up to 16-bit, the value gives number of remaining data frames persisting at RxFIFO.
Note: (*): Optional value when data size is set up to 8-bit only.
When data size is greater than 16-bit, these bits are always read as 00. In that consequence, the single data frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if data size is set from 17 to 24 bits. The user then must apply other methods like TSIZE&gt;0 or FTHLV=0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no next frame is available at RxFIFO</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>1 frame is available</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 frames are available*</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>3 frames are available*</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXWNE</name>
                <description>RxFIFO word not empty
Note: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0] information about RxFIFO occupancy by residual data.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>less than four bytes of RxFIFO space is occupied by data</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>at least four bytes of RxFIFO space is occupied by data </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIZE</name>
                <description>number of data frames remaining in current TSIZE session
The value is not quite reliable when traffic is ongoing on bus or during autonomous operation in low-power mode.
Note: CTSIZE[15:0] bits are not available in instances with limited set of features.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_IFCR</name>
            <displayName>SPI_IFCR</displayName>
            <description>SPI/I2S interrupt/status flags clear register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EOTC</name>
                <description>end of transfer flag clear
Writing a 1 into this bit clears EOT flag in the SPI_SR register</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXTFC</name>
                <description>transmission transfer filled flag clear
Writing a 1 into this bit clears TXTF flag in the SPI_SR register</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UDRC</name>
                <description>underrun flag clear
Writing a 1 into this bit clears UDR flag in the SPI_SR register</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>OVRC</name>
                <description>overrun flag clear
Writing a 1 into this bit clears OVR flag in the SPI_SR register</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CRCEC</name>
                <description>CRC error flag clear
Writing a 1 into this bit clears CRCE flag in the SPI_SR register</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TIFREC</name>
                <description>TI frame format error flag clear
Writing a 1 into this bit clears TIFRE flag in the SPI_SR register</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MODFC</name>
                <description>mode fault flag clear
Writing a 1 into this bit clears MODF flag in the SPI_SR register</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SUSPC</name>
                <description>SUSPend flag clear
Writing a 1 into this bit clears SUSP flag in the SPI_SR register</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_TXDR</name>
            <displayName>SPI_TXDR</displayName>
            <description>SPI/I2S transmit data register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXDR</name>
                <description>transmit data register
The register serves as an interface with TxFIFO. A write to it accesses TxFIFO.
Note: In SPI mode, data is always right-aligned. Alignment of data at I2S mode depends on DATLEN and DATFMT setting. Unused bits are ignored when writing to the register, and read as zero when the register is read.
Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written by single access.
halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be written by single access.
word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be written by single access.
Write access of this register less than the configured data size is forbidden.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_RXDR</name>
            <displayName>SPI_RXDR</displayName>
            <description>SPI/I2S receive data register </description>
            <addressOffset>0x30</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXDR</name>
                <description>receive data register
The register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.
Note: In SPI mode, data is always right-aligned. Alignment of data at I2S mode depends on DATLEN and DATFMT setting. Unused bits are read as zero when the register is read. Writing to the register is ignored.
Note: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read by single access
halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read by single access
word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be read by single access.
Read access of this register less than the configured data size is forbidden.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_CRCPOLY</name>
            <displayName>SPI_CRCPOLY</displayName>
            <description>SPI/I2S polynomial register </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000107</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CRCPOLY</name>
                <description>CRC polynomial register
This register contains the polynomial for the CRC calculation.
The default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is compatible with setting 0x07 used at some other ST products with fixed length of the polynomial string where the most significant bit of the string is always kept hidden.
Length of the polynomial is given by the most significant bit of the value stored at this register. It has to be set greater than DSIZE. CRC33_17 bit has to be set additionally with CRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is enabled (to keep polynomial length grater than data size).
Note: CRCPOLY[31:16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_TXCRC</name>
            <displayName>SPI_TXCRC</displayName>
            <description>SPI/I2S transmitter CRC register </description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TXCRC</name>
                <description>CRC register for transmitter
When CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value of the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.
The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.
Note: a read to this register when the communication is ongoing could return an incorrect value.
Note: not used for the I2S mode.
Note: TXCRC[31-16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_RXCRC</name>
            <displayName>SPI_RXCRC</displayName>
            <description>SPI/I2S receiver CRC register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RXCRC</name>
                <description>CRC register for receiver
When CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value of the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.
The number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.
Note: a read to this register when the communication is ongoing could return an incorrect value.
Not used for the I2S mode.
RXCRC[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.
Note: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_UDRDR</name>
            <displayName>SPI_UDRDR</displayName>
            <description>SPI/I2S underrun data register </description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UDRDR</name>
                <description>data at slave underrun condition
The register is taken into account in Slave mode and at underrun condition only. The number of bits considered depends on DSIZE bit settings of the SPI_CFG1 register. Underrun condition handling depends on setting UDRCFG bit at SPI_CFG1 register.
Note: UDRDR[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constraint when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SPI_I2SCFGR</name>
            <displayName>SPI_I2SCFGR</displayName>
            <description>SPI/I2S configuration register </description>
            <addressOffset>0x50</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>I2SMOD</name>
                <description>I2S mode selection</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI mode is selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>I2S/PCM mode is selected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SCFG</name>
                <description>I2S configuration mode
others, not used</description>
                <bitOffset>1</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>slave - transmit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>slave - receive</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>master - transmit</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>master - receive</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>slave - Full Duplex</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>master - Full Duplex</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SSTD</name>
                <description>I2S standard selection
For more details on I2S standards, refer to</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>I2S Philips standard.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>MSB justified standard (left justified)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>LSB justified standard (right justified)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>PCM standard</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCMSYNC</name>
                <description>PCM frame synchronization</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>short frame synchronization</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>long frame synchronization</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATLEN</name>
                <description>data length to be transferred</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>16-bit data length</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>24-bit data length</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>32-bit data length</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Not allowed</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CHLEN</name>
                <description>channel length (number of bits per audio channel)</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>16-bit wide</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>32-bit wide</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKPOL</name>
                <description>serial audio clock polarity</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the falling edge of CK and the signals received by the SPI/I2S (i.e. SDI and WS) are read of the rising edge of CK. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the rising edge of CK and the signals received by the SPI/I2S (i.e. SDI and WS) are read of the falling edge of CK. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIXCH</name>
                <description>fixed channel length in slave</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the channel length in Slave mode is different from 16 or 32 bits (CHLEN not taken into account)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the channel length in Slave mode is supposed to be 16 or 32 bits (according to CHLEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WSINV</name>
                <description>word select inversion
This bit is used to invert the default polarity of WS signal.
WS is LOW.
In PCM mode the start of frame is indicated by a rising edge.
WS is HIGH.
In PCM mode the start of frame is indicated by a falling edge.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>in I2S Philips standard, Left channel is transfered when WS is LOW, and right channel when WS is HIGH. In MSB or LSB justified mode, Left channel is transfered when WS is HIGH, and right channel when </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>in I2S Philips standard, Left channel is transfered when WS is HIGH, and right channel when WS is LOW.In MSB or LSB justified mode, Left channel is transfered when WS is LOW, and right channel when </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATFMT</name>
                <description>data format</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The data inside the SPI_RXDR or SPI_TXDR are right aligned</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The data inside the SPI_RXDR or SPI_TXDR are left aligned.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>I2SDIV</name>
                <description>I2S linear prescaler
I2SDIV can take any values except the value 1, when ODD is also equal to 1.
Refer to  for details</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ODD</name>
                <description>odd factor for the prescaler
Refer to  for details</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Real divider value is = I2SDIV *2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Real divider value is = (I2SDIV * 2) + 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MCKOE</name>
                <description>master clock output enable</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Master clock output is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Master clock output is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	      
    <peripheral derivedFrom="SPI1">
      <name>SPI2</name>
      <baseAddress>0x40003800</baseAddress>
      <interrupt>
        <name>SPI2</name>
        <description>SPI2 global interrupt</description>
        <value>56</value>
      </interrupt>
    </peripheral>    
    <peripheral derivedFrom="SPI1">
      <name>SPI3</name>
      <baseAddress>0x40003C00</baseAddress>
      <interrupt>
        <name>SPI3</name>
        <description>SPI3 global interrupt</description>
        <value>57</value>
      </interrupt>
    </peripheral>
	<peripheral>
        <name>TIM2</name>
        <description>General-purpose timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40000000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM2</name>
          <description>TIM2 global interrupt</description>
          <value>45</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM2_CR1</name>
            <displayName>TIM2_CR1</displayName>
            <description>TIM2 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter used as upcounter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter used as downcounter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMS</name>
                <description>Center-aligned mode selection
Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = ttim_ker_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 � ttim_ker_ck</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 � ttim_ker_ck</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DITHEN</name>
                <description>Dithering Enable
Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Dithering disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Dithering enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CR2</name>
            <displayName>TIM2_CR2</displayName>
            <description>TIM2 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS1</name>
                <description>Master mode selection
These bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:
tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Others: Reserved
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.When the Counter Enable signal is controlled by the trigger input, there is a delay on </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred (tim_trgo).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Encoder Clock output - The encoder clock signal is used as trigger output (tim_trgo). This code is valid for the following SMS[3:0] values: 0001, 0010, 0011, 1010, 1011, 1100, 1101, 1110, 1111. Any other SMS[3:0] code is not allowed and may lead to unexpected behavior.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI1S</name>
                <description>tim_ti1 selection</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The tim_ti1_in[15..0] multiplexer output is to tim_ti1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The tim_ti1_in[15..0], tim_ti2_in[15..0] and tim_ti3_in[15..0] multiplexers outputs are XORed and connected to the tim_ti1 input. See also sensors on page 558.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS2</name>
                <description>Master mode selection
These bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:
tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Others: Reserved
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.When the Counter Enable signal is controlled by the trigger input, there is a delay on </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred (tim_trgo).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Encoder Clock output - The encoder clock signal is used as trigger output (tim_trgo). This code is valid for the following SMS[3:0] values: 0001, 0010, 0011, 1010, 1011, 1100, 1101, 1110, 1111. Any other SMS[3:0] code is not allowed and may lead to unexpected behavior.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_SMCR</name>
            <displayName>TIM2_SMCR</displayName>
            <description>TIM2 slave mode control register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMS1</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter, generates an update of the registers and starts the counter.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Combined gated + reset mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops and is reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Encoder mode: Clock plus direction, x2 mode.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Encoder mode: Clock plus direction, x1 mode, tim_ti2fp2 edge sensitivity is set by CC2P.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Encoder mode: Directional Clock, x2 mode.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Encoder mode: Directional Clock, x1 mode, tim_ti1fp1 and tim_ti2fp2 edge sensitivity is set by CC1P and CC2P.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti1fp1 edges only, edge sensitivity is set by CC1P.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti2fp2 edges only, edge sensitivity is set by CC2P.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OCCS</name>
                <description>OCREF clear selection
This bit is used to select the OCREF clear source
Note: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to ‘0’. .</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ocref_clr_int is connected to the tim_ocref_clr input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ocref_clr_int is connected to tim_etrf</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS1</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for product specific implementation details.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal trigger 0 (tim_itr0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal trigger 1 (tim_itr1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal trigger 2 (tim_itr2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal trigger 3 (tim_itr3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>tim_ti1 edge detector (tim_ti1f_ed)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered timer input 1 (tim_ti1fp1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered timer input 2 (tim_ti2fp2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External trigger input (tim_etrf)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal trigger 4 (tim_itr4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal trigger 5 (tim_itr5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal trigger 6 (tim_itr6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal trigger 7 (tim_itr7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal trigger 8 (tim_itr8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Internal trigger 9 (tim_itr9)</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Internal trigger 10 (tim_itr10)</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Internal trigger 11 (tim_itr11)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Internal trigger 12 (tim_itr12)</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>Internal trigger 13 (tim_itr13)</description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x12</name>
                    <description>Internal trigger 14 (tim_itr14)</description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>Internal trigger 15 (tim_itr15)</description>
                    <value>0x13</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSM</name>
                <description>Master/Slave mode</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The effect of an event on the trigger input (tim_trgi) is delayed to allow a perfect synchronization between the current timer and its slaves (through tim_trgo). It is useful if we want to synchronize several timers on a single external event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETF</name>
                <description>External trigger filter
This bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=ftim_ker_ck, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=ftim_ker_ck, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=ftim_ker_ck, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETPS</name>
                <description>External trigger prescaler
External trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Prescaler OFF</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etrp frequency divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tim_etrp frequency divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>tim_etrp frequency divided by 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ECE</name>
                <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>External clock mode 2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>External clock mode 2 enabled. The counter is clocked by any active edge on the tim_etrf signal.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETP</name>
                <description>External trigger polarity
This bit selects whether tim_etr_in or tim_etr_in is used for trigger operations</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_etr_in is non-inverted, active at high level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etr_in is inverted, active at low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMS2</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter, generates an update of the registers and starts the counter.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Combined gated + reset mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops and is reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Encoder mode: Clock plus direction, x2 mode.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Encoder mode: Clock plus direction, x1 mode, tim_ti2fp2 edge sensitivity is set by CC2P.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Encoder mode: Directional Clock, x2 mode.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Encoder mode: Directional Clock, x1 mode, tim_ti1fp1 and tim_ti2fp2 edge sensitivity is set by CC1P and CC2P.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti1fp1 edges only, edge sensitivity is set by CC1P.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti2fp2 edges only, edge sensitivity is set by CC2P.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS2</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for product specific implementation details.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal trigger 0 (tim_itr0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal trigger 1 (tim_itr1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal trigger 2 (tim_itr2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal trigger 3 (tim_itr3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>tim_ti1 edge detector (tim_ti1f_ed)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered timer input 1 (tim_ti1fp1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered timer input 2 (tim_ti2fp2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External trigger input (tim_etrf)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal trigger 4 (tim_itr4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal trigger 5 (tim_itr5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal trigger 6 (tim_itr6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal trigger 7 (tim_itr7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal trigger 8 (tim_itr8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Internal trigger 9 (tim_itr9)</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Internal trigger 10 (tim_itr10)</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Internal trigger 11 (tim_itr11)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Internal trigger 12 (tim_itr12)</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>Internal trigger 13 (tim_itr13)</description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x12</name>
                    <description>Internal trigger 14 (tim_itr14)</description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>Internal trigger 15 (tim_itr15)</description>
                    <value>0x13</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMSPE</name>
                <description>SMS preload enable
This bit selects whether the SMS[3:0] bitfield is preloaded</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SMS[3:0] bitfield is not preloaded</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SMS[3:0] preload is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMSPS</name>
                <description>SMS preload source
This bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The transfer is triggered by the Timer’s Update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The transfer is triggered by the Index event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_DIER</name>
            <displayName>TIM2_DIER</displayName>
            <description>TIM2 DMA/Interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/Compare 2 interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3IE</name>
                <description>Capture/Compare 3 interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4IE</name>
                <description>Capture/Compare 4 interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIE</name>
                <description>Trigger interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2DE</name>
                <description>Capture/Compare 2 DMA request enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3DE</name>
                <description>Capture/Compare 3 DMA request enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4DE</name>
                <description>Capture/Compare 4 DMA request enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TDE</name>
                <description>Trigger DMA request enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDXIE</name>
                <description>Index interrupt enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRIE</name>
                <description>Direction change interrupt enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Direction change interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Direction change interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IERRIE</name>
                <description>Index error interrupt enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index error interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index error interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TERRIE</name>
                <description>Transition error interrupt enable</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transition error interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transition error interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_SR</name>
            <displayName>TIM2_SR</displayName>
            <description>TIM2 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow and if UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3IF</name>
                <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4IF</name>
                <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIF</name>
                <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OF</name>
                <description>Capture/compare 2 overcapture flag
refer to CC1OF description</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3OF</name>
                <description>Capture/Compare 3 overcapture flag
refer to CC1OF description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4OF</name>
                <description>Capture/Compare 4 overcapture flag
refer to CC1OF description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IDXF</name>
                <description>Index interrupt flag
This flag is set by hardware when an index event is detected. It is cleared by software by
writing it to ‘0’.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No index event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An index event has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRF</name>
                <description>Direction change interrupt flag
This flag is set by hardware when the direction changes in encoder mode (DIR bit value in
TIMx_CR is changing). It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No direction change</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Direction change</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IERRF</name>
                <description>Index error interrupt flag
This flag is set by hardware when an index error is detected. It is cleared by software by
writing it to ‘0’.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No index error has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An index error has been detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TERRF</name>
                <description>Transition error interrupt flag
This flag is set by hardware when a transition error is detected in encoder mode. It is cleared
by software by writing it to ‘0’.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No encoder transition error has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An encoder transition error has been detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_EGR</name>
            <displayName>TIM2_EGR</displayName>
            <description>TIM2 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2G</name>
                <description>Capture/compare 2 generation
Refer to CC1G description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC3G</name>
                <description>Capture/compare 3 generation
Refer to CC1G description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC4G</name>
                <description>Capture/compare 4 generation
Refer to CC1G description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TG</name>
                <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CCMR1_Input</name>
            <displayName>TIM2_CCMR1_Input</displayName>
            <description>TIM2 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=ftim_ker_ck, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=ftim_ker_ck, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=ftim_ker_ck, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2PSC</name>
                <description>Input capture 2 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC2F</name>
                <description>Input capture 2 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>		  
		  <register>
            <name>TIM2_CCMR1_Output</name>
            <displayName>TIM2_CCMR1_Output</displayName>
            <description>TIM2 capture/compare mode register 1 [alternate]</description>
            <alternateRegister>TIM2_CCMR1_Input</alternateRegister>
			<addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 is derived. tim_oc1ref is active high whereas tim_oc1 active level depends on CC1P bit.
Note: In PWM mode, the tim_ocref_clr level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - tim_oc1ref is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - tim_oc1ref is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref=0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (tim_oc1ref=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc is the logical OR between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc is the logical AND between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1CE</name>
                <description>Output compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_oc1ref is not affected by the tim_ocref_clr_int input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_oc1ref is cleared as soon as a High level is detected on tim_ocref_clr_int input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2FE</name>
                <description>Output compare 2 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output compare 2 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M1</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2CE</name>
                <description>Output compare 2 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 is derived. tim_oc1ref is active high whereas tim_oc1 active level depends on CC1P bit.
Note: In PWM mode, the tim_ocref_clr level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - tim_oc1ref is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - tim_oc1ref is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref=0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (tim_oc1ref=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc is the logical OR between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc is the logical AND between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2M2</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			</fields>
          </register>
          <register>
            <name>TIM2_CCMR2_Input</name>
            <displayName>TIM2_CCMR2_Input</displayName>
            <description>TIM2 capture/compare mode register 2 [alternate]</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC3PSC</name>
                <description>Input capture 3 prescaler</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC3F</name>
                <description>Input capture 3 filter</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC4PSC</name>
                <description>Input capture 4 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC4F</name>
                <description>Input capture 4 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>TIM2_CCMR2_Output</name>
            <displayName>TIM2_CCMR2_Output</displayName>
            <description>TIM2 capture/compare mode register 2 [alternate]</description>
            <alternateRegister>TIM2_CCMR2_Input</alternateRegister>
			<addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			 <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC3FE</name>
                <description>Output compare 3 fast enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3PE</name>
                <description>Output compare 3 preload enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M1</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3CE</name>
                <description>Output compare 3 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC4FE</name>
                <description>Output compare 4 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4PE</name>
                <description>Output compare 4 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M1</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4CE</name>
                <description>Output compare 4 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M2</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M2</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			</fields>
          </register>
          <register>
            <name>TIM2_CCER</name>
            <displayName>TIM2_CCER</displayName>
            <description>TIM2 capture/compare enable register</description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared in this case.
CC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2E</name>
                <description>Capture/Compare 2 output enable.
Refer to CC1E description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2P</name>
                <description>Capture/Compare 2 output Polarity.
refer to CC1P description</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2NP</name>
                <description>Capture/Compare 2 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3E</name>
                <description>Capture/Compare 3 output enable.
Refer to CC1E description</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3P</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1P description</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3NP</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4E</name>
                <description>Capture/Compare 4 output enable.
refer to CC1E description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4P</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1P description</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4NP</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CNT</name>
            <displayName>TIM2_CNT</displayName>
            <description>TIM2 counter </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>or UIFCPY: Value depends on IUFREMAP in TIMx_CR1.
If UIFREMAP = 0
nullMost significant bit of counter value
If UIFREMAP = 1
UIFCPY: UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register
nullLeast significant part of counter value
Non-dithering mode (DITHEN = 0)
The register holds the counter value.
Dithering mode (DITHEN = 1)
The register holds the non-dithered part in CNT[30:0]. The fractional part is not available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_PSC</name>
            <displayName>TIM2_PSC</displayName>
            <description>TIM2 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency tim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_ARR</name>
            <displayName>TIM2_ARR</displayName>
            <description>TIM2 auto-reload register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.
Non-dithering mode (DITHEN = 0)
The register holds the auto-reload value.
Dithering mode (DITHEN = 1)
The register holds the integer part in ARR[31:4]. The ARR[3:0] bitfield contains the dithered part.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CCR1</name>
            <displayName>TIM2_CCR1</displayName>
            <description>TIM2 capture/compare register 1 </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR1[31:4]. The CCR1[3:0] bitfield contains the dithered part.
If channel CC1 is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The register holds the capture value.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR1[31:0]. The CCR1[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CCR2</name>
            <displayName>TIM2_CCR2</displayName>
            <description>TIM2 capture/compare register 2 </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR2</name>
                <description>Capture/compare 2 value
If channel CC2 is configured as output:
CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR2[31:4]. The CCR2[3:0] bitfield contains the dithered part.
If channel CC2 is configured as input:
CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The register holds the capture value.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR2[31:0]. The CCR2[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CCR3</name>
            <displayName>TIM2_CCR3</displayName>
            <description>TIM2 capture/compare register 3 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR3</name>
                <description>Capture/compare 3 value
If channel CC3 is configured as output:
CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR3[31:4]. The CCR3[3:0] bitfield contains the dithered part.
If channel CC3 is configured as input:
CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The register holds the capture value.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR3[31:0]. The CCR3[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_CCR4</name>
            <displayName>TIM2_CCR4</displayName>
            <description>TIM2 capture/compare register 4 </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR4</name>
                <description>Capture/compare 4 value
If channel CC4 is configured as output:
CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR4[31:4]. The CCR4[3:0] bitfield contains the dithered part.
If channel CC4 is configured as input:
CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The register holds the capture value.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR4[31:0]. The CCR4[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_ECR</name>
            <displayName>TIM2_ECR</displayName>
            <description>TIM2 timer encoder control register</description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IE</name>
                <description>Index enable
This bit indicates if the Index event resets the counter.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDIR</name>
                <description>Index direction
This bit indicates in which direction the Index event resets the counter.
Note: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index resets the counter whatever the direction</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index resets the counter when up-counting only</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index resets the counter when down-counting only</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBLK</name>
                <description>Index blanking
This bit indicates if the Index event is conditioned by the tim_ti3 input</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index always active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index disabled hen tim_ti3 input is active, as per CC3P bitfield</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index disabled when tim_ti4 input is active, as per CC4P bitfield</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIDX</name>
                <description>First index
This bit indicates if the first index only is taken into account</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index is always active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the first Index only resets the counter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IPOS</name>
                <description>Index positioning
In quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.
In directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.
x0: Index resets the counter when clock is 0
x1: Index resets the counter when clock is 1
Note: IPOS[1] bit is not significant</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index resets the counter when AB = 00</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index resets the counter when AB = 01</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index resets the counter when AB = 10</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Index resets the counter when AB = 11</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PW</name>
                <description>Pulse width
This bitfield defines the pulse duration, as following:
tPW = PW[7:0] x tPWG</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWPRSC</name>
                <description>Pulse width prescaler
This bitfield sets the clock prescaler for the pulse generator, as following:
tPWG = (2(PWPRSC[2:0])) x ttim_ker_ck</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_TISEL</name>
            <displayName>TIM2_TISEL</displayName>
            <description>TIM2 timer input selection register</description>
            <addressOffset>0x5c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>Selects tim_ti1[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti1_in0: TIMx_CH1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti1_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti1_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI2SEL</name>
                <description>Selects tim_ti2[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti2_in0: TIMx_CH2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti2_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti2_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI3SEL</name>
                <description>Selects tim_ti3[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti3_in0: TIMx_CH3</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti3_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti3_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI4SEL</name>
                <description>Selects tim_ti4[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti4_in0: TIMx_CH4</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti4_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti4_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_AF1</name>
            <displayName>TIM2_AF1</displayName>
            <description>TIM2 alternate function register 1</description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ETRSEL</name>
                <description>etr_in source selection
These bits select the etr_in input source.
...
Refer to  for product specific implementation.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_etr0: TIMx_ETR input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etr1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_etr15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_AF2</name>
            <displayName>TIM2_AF2</displayName>
            <description>TIM2 alternate function register 2</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OCRSEL</name>
                <description>ocref_clr source selection
These bits select the ocref_clr input source.
...
Refer to  for product specific implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ocref_clr0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ocref_clr1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>tim_ocref_clr7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_DCR</name>
            <displayName>TIM2_DCR</displayName>
            <description>TIM2 DMA control register</description>
            <addressOffset>0x3dc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...
Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIM2_CR1.
If DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:
(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL
In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA
According to the configuration of the DMA Data Size, several cases may occur:
If the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.
If the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1A</name>
                    <description>26 transfers</description>
                    <value>0x1A</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBSS</name>
                <description>DMA burst source selection
This bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CC3</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>CC4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>COM</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Trigger</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM2_DMAR</name>
            <displayName>TIM2_DMAR</displayName>
            <description>TIM2 DMA address for full transfer</description>
            <addressOffset>0x3e0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address
(TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral>
        <name>TIM3</name>
        <description>General-purpose timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40000400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM3</name>
          <description>TIM3 global interrupt</description>
          <value>46</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM3_CR1</name>
            <displayName>TIM3_CR1</displayName>
            <description>TIM3 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generate an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the bit CEN)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter used as upcounter</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter used as downcounter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMS</name>
                <description>Center-aligned mode selection
Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CKD</name>
                <description>Clock division
This bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tDTS = ttim_ker_ck</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tDTS = 2 � ttim_ker_ck</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tDTS = 4 � ttim_ker_ck</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DITHEN</name>
                <description>Dithering Enable
Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Dithering disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Dithering enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CR2</name>
            <displayName>TIM3_CR2</displayName>
            <description>TIM3 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCDS</name>
                <description>Capture/compare DMA selection</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CCx DMA request sent when CCx event occurs</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CCx DMA requests sent when update event occurs</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS1</name>
                <description>Master mode selection
These bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:
tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Others: Reserved
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.When the Counter Enable signal is controlled by the trigger input, there is a delay on </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred (tim_trgo).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Encoder Clock output - The encoder clock signal is used as trigger output (tim_trgo). This code is valid for the following SMS[3:0] values: 0001, 0010, 0011, 1010, 1011, 1100, 1101, 1110, 1111. Any other SMS[3:0] code is not allowed and may lead to unexpected behavior.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI1S</name>
                <description>tim_ti1 selection</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The tim_ti1_in[15..0] multiplexer output is to tim_ti1 input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The tim_ti1_in[15..0], tim_ti2_in[15..0] and tim_ti3_in[15..0] multiplexers outputs are XORed and connected to the tim_ti1 input. See also sensors on page 558.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MMS2</name>
                <description>Master mode selection
These bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:
tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Others: Reserved
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as trigger output (tim_trgo). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on tim_trgo is delayed compared to the actual reset.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, CNT_EN, is used as trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.When the Counter Enable signal is controlled by the trigger input, there is a delay on </description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred (tim_trgo).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Compare - tim_oc1refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Compare - tim_oc2refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Compare - tim_oc3refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Compare - tim_oc4refc signal is used as trigger output (tim_trgo)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Encoder Clock output - The encoder clock signal is used as trigger output (tim_trgo). This code is valid for the following SMS[3:0] values: 0001, 0010, 0011, 1010, 1011, 1100, 1101, 1110, 1111. Any other SMS[3:0] code is not allowed and may lead to unexpected behavior.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_SMCR</name>
            <displayName>TIM3_SMCR</displayName>
            <description>TIM3 slave mode control register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SMS1</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter, generates an update of the registers and starts the counter.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Combined gated + reset mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops and is reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Encoder mode: Clock plus direction, x2 mode.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Encoder mode: Clock plus direction, x1 mode, tim_ti2fp2 edge sensitivity is set by CC2P.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Encoder mode: Directional Clock, x2 mode.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Encoder mode: Directional Clock, x1 mode, tim_ti1fp1 and tim_ti2fp2 edge sensitivity is set by CC1P and CC2P.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti1fp1 edges only, edge sensitivity is set by CC1P.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti2fp2 edges only, edge sensitivity is set by CC2P.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OCCS</name>
                <description>OCREF clear selection
This bit is used to select the OCREF clear source
Note: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to ‘0’. .</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ocref_clr_int is connected to the tim_ocref_clr input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ocref_clr_int is connected to tim_etrf</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS1</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for product specific implementation details.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal trigger 0 (tim_itr0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal trigger 1 (tim_itr1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal trigger 2 (tim_itr2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal trigger 3 (tim_itr3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>tim_ti1 edge detector (tim_ti1f_ed)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered timer input 1 (tim_ti1fp1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered timer input 2 (tim_ti2fp2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External trigger input (tim_etrf)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal trigger 4 (tim_itr4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal trigger 5 (tim_itr5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal trigger 6 (tim_itr6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal trigger 7 (tim_itr7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal trigger 8 (tim_itr8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Internal trigger 9 (tim_itr9)</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Internal trigger 10 (tim_itr10)</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Internal trigger 11 (tim_itr11)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Internal trigger 12 (tim_itr12)</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>Internal trigger 13 (tim_itr13)</description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x12</name>
                    <description>Internal trigger 14 (tim_itr14)</description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>Internal trigger 15 (tim_itr15)</description>
                    <value>0x13</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSM</name>
                <description>Master/Slave mode</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The effect of an event on the trigger input (tim_trgi) is delayed to allow a perfect synchronization between the current timer and its slaves (through tim_trgo). It is useful if we want to synchronize several timers on a single external event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETF</name>
                <description>External trigger filter
This bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=ftim_ker_ck, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=ftim_ker_ck, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=ftim_ker_ck, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETPS</name>
                <description>External trigger prescaler
External trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Prescaler OFF</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etrp frequency divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>tim_etrp frequency divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>tim_etrp frequency divided by 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ECE</name>
                <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>External clock mode 2 disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>External clock mode 2 enabled. The counter is clocked by any active edge on the tim_etrf signal.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ETP</name>
                <description>External trigger polarity
This bit selects whether tim_etr_in or tim_etr_in is used for trigger operations</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_etr_in is non-inverted, active at high level or rising edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etr_in is inverted, active at low level or falling edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMS2</name>
                <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Encoder mode 1 - Counter counts up/down on tim_ti1fp1 edge depending on tim_ti2fp2 level.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Encoder mode 2 - Counter counts up/down on tim_ti2fp2 edge depending on tim_ti1fp1 level.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Encoder mode 3 - Counter counts up/down on both tim_ti1fp1 and tim_ti2fp2 edges depending on the level of the other input.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Reset Mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter and generates an update of the registers.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Gated Mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Trigger Mode - The counter starts at a rising edge of the trigger tim_trgi (but it is not reset). Only the start of the counter is controlled.</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External Clock Mode 1 - Rising edges of the selected trigger (tim_trgi) clock the counter.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Combined reset + trigger mode - Rising edge of the selected trigger input (tim_trgi) reinitializes the counter, generates an update of the registers and starts the counter.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Combined gated + reset mode - The counter clock is enabled when the trigger input (tim_trgi) is high. The counter stops and is reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Encoder mode: Clock plus direction, x2 mode.</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Encoder mode: Clock plus direction, x1 mode, tim_ti2fp2 edge sensitivity is set by CC2P.</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Encoder mode: Directional Clock, x2 mode.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Encoder mode: Directional Clock, x1 mode, tim_ti1fp1 and tim_ti2fp2 edge sensitivity is set by CC1P and CC2P.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti1fp1 edges only, edge sensitivity is set by CC1P.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Quadrature encoder mode: x1 mode, counting on tim_ti2fp2 edges only, edge sensitivity is set by CC2P.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TS2</name>
                <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for product specific implementation details.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Internal trigger 0 (tim_itr0)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Internal trigger 1 (tim_itr1)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Internal trigger 2 (tim_itr2)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Internal trigger 3 (tim_itr3)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>tim_ti1 edge detector (tim_ti1f_ed)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Filtered timer input 1 (tim_ti1fp1)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>Filtered timer input 2 (tim_ti2fp2)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>External trigger input (tim_etrf)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Internal trigger 4 (tim_itr4)</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Internal trigger 5 (tim_itr5)</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>Internal trigger 6 (tim_itr6)</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>Internal trigger 7 (tim_itr7)</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Internal trigger 8 (tim_itr8)</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Internal trigger 9 (tim_itr9)</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Internal trigger 10 (tim_itr10)</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Internal trigger 11 (tim_itr11)</description>
                    <value>0xF</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x10</name>
                    <description>Internal trigger 12 (tim_itr12)</description>
                    <value>0x10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x11</name>
                    <description>Internal trigger 13 (tim_itr13)</description>
                    <value>0x11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x12</name>
                    <description>Internal trigger 14 (tim_itr14)</description>
                    <value>0x12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x13</name>
                    <description>Internal trigger 15 (tim_itr15)</description>
                    <value>0x13</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMSPE</name>
                <description>SMS preload enable
This bit selects whether the SMS[3:0] bitfield is preloaded</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SMS[3:0] bitfield is not preloaded</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SMS[3:0] preload is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SMSPS</name>
                <description>SMS preload source
This bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The transfer is triggered by the Timer’s Update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The transfer is triggered by the Index event</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DIER</name>
            <displayName>TIM3_DIER</displayName>
            <description>TIM3 DMA/Interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IE</name>
                <description>Capture/Compare 1 interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IE</name>
                <description>Capture/Compare 2 interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3IE</name>
                <description>Capture/Compare 3 interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4IE</name>
                <description>Capture/Compare 4 interrupt enable</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TIE</name>
                <description>Trigger interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1DE</name>
                <description>Capture/Compare 1 DMA request enable</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2DE</name>
                <description>Capture/Compare 2 DMA request enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC3DE</name>
                <description>Capture/Compare 3 DMA request enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC4DE</name>
                <description>Capture/Compare 4 DMA request enable</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TDE</name>
                <description>Trigger DMA request enable</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Trigger DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDXIE</name>
                <description>Index interrupt enable</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRIE</name>
                <description>Direction change interrupt enable</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Direction change interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Direction change interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IERRIE</name>
                <description>Index error interrupt enable</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index error interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index error interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TERRIE</name>
                <description>Transition error interrupt enable</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transition error interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transition error interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_SR</name>
            <displayName>TIM3_SR</displayName>
            <description>TIM3 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow and if UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1IF</name>
                <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No compare match / No input capture occurred</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A compare match or an input capture occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2IF</name>
                <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3IF</name>
                <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4IF</name>
                <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIF</name>
                <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No trigger event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Trigger interrupt pending.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1OF</name>
                <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overcapture has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2OF</name>
                <description>Capture/compare 2 overcapture flag
refer to CC1OF description</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3OF</name>
                <description>Capture/Compare 3 overcapture flag
refer to CC1OF description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4OF</name>
                <description>Capture/Compare 4 overcapture flag
refer to CC1OF description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IDXF</name>
                <description>Index interrupt flag
This flag is set by hardware when an index event is detected. It is cleared by software by
writing it to ‘0’.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No index event occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An index event has occurred</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRF</name>
                <description>Direction change interrupt flag
This flag is set by hardware when the direction changes in encoder mode (DIR bit value in
TIMx_CR is changing). It is cleared by software by writing it to ‘0’.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No direction change</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Direction change</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IERRF</name>
                <description>Index error interrupt flag
This flag is set by hardware when an index error is detected. It is cleared by software by
writing it to ‘0’.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No index error has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An index error has been detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TERRF</name>
                <description>Transition error interrupt flag
This flag is set by hardware when a transition error is detected in encoder mode. It is cleared
by software by writing it to ‘0’.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No encoder transition error has been detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An encoder transition error has been detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_EGR</name>
            <displayName>TIM3_EGR</displayName>
            <description>TIM3 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1G</name>
                <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A capture/compare event is generated on channel 1:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2G</name>
                <description>Capture/compare 2 generation
Refer to CC1G description</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC3G</name>
                <description>Capture/compare 3 generation
Refer to CC1G description</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CC4G</name>
                <description>Capture/compare 4 generation
Refer to CC1G description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TG</name>
                <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCMR1_Input</name>
            <displayName>TIM3_CCMR1_Input</displayName>
            <description>TIM3 capture/compare mode register 1 [alternate]</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1PSC</name>
                <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no prescaler, capture is done each time an edge is detected on the capture input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>capture is done once every 2 events</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>capture is done once every 4 events</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>capture is done once every 8 events</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC1F</name>
                <description>Input capture 1 filter
This bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No filter, sampling is done at fDTS</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>fSAMPLING=ftim_ker_ck, N=2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>fSAMPLING=ftim_ker_ck, N=4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>fSAMPLING=ftim_ker_ck, N=8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>fSAMPLING=fDTS/2, N=6</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>fSAMPLING=fDTS/2, N=8</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>fSAMPLING=fDTS/4, N=6</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>fSAMPLING=fDTS/4, N=8</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>fSAMPLING=fDTS/8, N=6</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>fSAMPLING=fDTS/8, N=8</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>fSAMPLING=fDTS/16, N=5</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>fSAMPLING=fDTS/16, N=6</description>
                    <value>0xB</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>fSAMPLING=fDTS/16, N=8</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>fSAMPLING=fDTS/32, N=5</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>fSAMPLING=fDTS/32, N=6</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>fSAMPLING=fDTS/32, N=8</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC2PSC</name>
                <description>Input capture 2 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC2F</name>
                <description>Input capture 2 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>TIM3_CCMR1_Output</name>
            <displayName>TIM3_CCMR1_Output</displayName>
            <description>TIM3 capture/compare mode register 1 [alternate]</description>
            <alternateRegister>TIM3_CCMR1_Input</alternateRegister>
			<addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			  <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 channel is configured as output.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti1.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_ti2.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC1 channel is configured as input, tim_ic1 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1FE</name>
                <description>Output compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1M1</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 is derived. tim_oc1ref is active high whereas tim_oc1 active level depends on CC1P bit.
Note: In PWM mode, the tim_ocref_clr level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - tim_oc1ref is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - tim_oc1ref is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref=0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (tim_oc1ref=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc is the logical OR between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc is the logical AND between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC1CE</name>
                <description>Output compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_oc1ref is not affected by the tim_ocref_clr_int input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_oc1ref is cleared as soon as a High level is detected on tim_ocref_clr_int input</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC2 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_ti1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2 channel is configured as input, tim_ic2 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2FE</name>
                <description>Output compare 2 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output compare 2 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M1</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2CE</name>
                <description>Output compare 2 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal tim_oc1ref from which tim_oc1 is derived. tim_oc1ref is active high whereas tim_oc1 active level depends on CC1P bit.
Note: In PWM mode, the tim_ocref_clr level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Set channel 1 to active level on match. tim_oc1ref signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Set channel 1 to inactive level on match. tim_oc1ref signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Toggle - tim_oc1ref toggles when TIMx_CNT=TIMx_CCR1.</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Force inactive level - tim_oc1ref is forced low.</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Force active level - tim_oc1ref is forced high.</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT&lt;TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (tim_oc1ref=0) as long as TIMx_CNT&gt;TIMx_CCR1 else active (tim_oc1ref=1).</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT&lt;TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT&gt;TIMx_CCR1 else inactive.</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on tim_trgi signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xC</name>
                    <description>Combined PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc is the logical OR between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xC</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xD</name>
                    <description>Combined PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc is the logical AND between tim_oc1ref and tim_oc2ref.</description>
                    <value>0xD</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xE</name>
                    <description>Asymmetric PWM mode 1 - tim_oc1ref has the same behavior as in PWM mode 1. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xE</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>Asymmetric PWM mode 2 - tim_oc1ref has the same behavior as in PWM mode 2. tim_oc1refc outputs tim_oc1ref when the counter is counting up, tim_oc2ref when it is counting down.</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC2M2</name>
                <description>Output compare 2 mode
refer to OC1M description on bits 6:4</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
			  </field>
			</fields>
          </register>
          <register>
            <name>TIM3_CCMR2_Input</name>
            <displayName>TIM3_CCMR2_Input</displayName>
            <description>TIM3 capture/compare mode register 2 [alternate]</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC3PSC</name>
                <description>Input capture 3 prescaler</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC3F</name>
                <description>Input capture 3 filter</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IC4PSC</name>
                <description>Input capture 4 prescaler</description>
                <bitOffset>10</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IC4F</name>
                <description>Input capture 4 filter</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
		  <register>
            <name>TIM3_CCMR2_Output</name>
            <displayName>TIM3_CCMR2_Output</displayName>
            <description>TIM3 capture/compare mode register 2 [alternate]</description>
            <alternateRegister>TIM3_CCMR2_Input</alternateRegister>
			<addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
			  <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC3 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti3</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_ti4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC3 channel is configured as input, tim_ic3 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC3FE</name>
                <description>Output compare 3 fast enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3PE</name>
                <description>Output compare 3 preload enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M1</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3CE</name>
                <description>Output compare 3 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CC4 channel is configured as output</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti4</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_ti3</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC4 channel is configured as input, tim_ic4 is mapped on tim_trc. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OC4FE</name>
                <description>Output compare 4 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4PE</name>
                <description>Output compare 4 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M1</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>12</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4CE</name>
                <description>Output compare 4 clear enable</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M2</name>
                <description>Output compare 3 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M2</name>
                <description>Output compare 4 mode
Refer to OC1M description (bits 6:4 in TIMx_CCMR1 register)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
			</fields>
          </register>
          <register>
            <name>TIM3_CCER</name>
            <displayName>TIM3_CCER</displayName>
            <description>TIM3 capture/compare enable register</description>
            <addressOffset>0x20</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CC1E</name>
                <description>Capture/Compare 1 output enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Capture mode disabled / OC1 is not active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Capture mode enabled / OC1 signal is output on the corresponding output pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1P</name>
                <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CC1NP</name>
                <description>Capture/Compare 1 output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared in this case.
CC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2E</name>
                <description>Capture/Compare 2 output enable.
Refer to CC1E description</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2P</name>
                <description>Capture/Compare 2 output Polarity.
refer to CC1P description</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC2NP</name>
                <description>Capture/Compare 2 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3E</name>
                <description>Capture/Compare 3 output enable.
Refer to CC1E description</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3P</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1P description</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC3NP</name>
                <description>Capture/Compare 3 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4E</name>
                <description>Capture/Compare 4 output enable.
refer to CC1E description</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4P</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1P description</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4NP</name>
                <description>Capture/Compare 4 output Polarity.
Refer to CC1NP description</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CNT</name>
            <displayName>TIM3_CNT</displayName>
            <description>TIM3 counter </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value‘
Non-dithering mode (DITHEN = 0)
The register holds the counter value.
Dithering mode (DITHEN = 1)
The register holds the non-dithered part in CNT[15:0]. The fractional part is not available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>Value depends on IUFREMAP in TIMx_CR1.
If UIFREMAP = 0
Reserved
If UIFREMAP = 1
UIFCPY: UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_PSC</name>
            <displayName>TIM3_PSC</displayName>
            <description>TIM3 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency tim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_ARR</name>
            <displayName>TIM3_ARR</displayName>
            <description>TIM3 auto-reload register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Low Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.
Non-dithering mode (DITHEN = 0)
The register holds the auto-reload value.
Dithering mode (DITHEN = 1)
The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR1</name>
            <displayName>TIM3_CCR1</displayName>
            <description>TIM3 capture/compare register 1 </description>
            <addressOffset>0x34</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR1</name>
                <description>Capture/compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.
If channel CC1 is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The CCR1[15:0] bits hold the capture value. The CCR1[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR1[19:0]. The CCR1[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR2</name>
            <displayName>TIM3_CCR2</displayName>
            <description>TIM3 capture/compare register 2 </description>
            <addressOffset>0x38</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR2</name>
                <description>Capture/compare 1 value
If channel CC2 is configured as output:
CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value in CCR2[15:0]. The CCR2[19:16] bits are reset.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR2[19:4]. The CCR2[3:0] bitfield contains the dithered part.
If channel CC2 is configured as input:
CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The CCR2[15:0] bits hold the capture value. The CCR2[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR2[19:0]. The CCR2[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR3</name>
            <displayName>TIM3_CCR3</displayName>
            <description>TIM3 capture/compare register 3 </description>
            <addressOffset>0x3c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR3</name>
                <description>Capture/compare 3 value
If channel CC3 is configured as output:
CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value in CCR3[15:0]. The CCR3[19:16] bits are reset.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR3[19:4]. The CCR3[3:0] bitfield contains the dithered part.
If channel CC3 is configured as input:
CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The CCR3[15:0] bits hold the capture value. The CCR3[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR3[19:0]. The CCR3[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_CCR4</name>
            <displayName>TIM3_CCR4</displayName>
            <description>TIM3 capture/compare register 4 </description>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CCR4</name>
                <description>Capture/compare 4 value
If channel CC4 is configured as output:
CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.
Non-dithering mode (DITHEN = 0)
The register holds the compare value in CCR4[15:0]. The CCR4[19:16] bits are reset.
Dithering mode (DITHEN = 1)
The register holds the integer part in CCR4[19:4]. The CCR4[3:0] bitfield contains the dithered part.
If channel CC4 is configured as input:
CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.
Non-dithering mode (DITHEN = 0)
The CCR4[15:0] bits hold the capture value. The CCR4[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the capture in CCR4[19:0]. The CCR4[3:0] bits are reset.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_ECR</name>
            <displayName>TIM3_ECR</displayName>
            <description>TIM3 timer encoder control register</description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IE</name>
                <description>Index enable
This bit indicates if the Index event resets the counter.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDIR</name>
                <description>Index direction
This bit indicates in which direction the Index event resets the counter.
Note: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled).</description>
                <bitOffset>1</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index resets the counter whatever the direction</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index resets the counter when up-counting only</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index resets the counter when down-counting only</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IBLK</name>
                <description>Index blanking
This bit indicates if the Index event is conditioned by the tim_ti3 input</description>
                <bitOffset>3</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index always active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index disabled hen tim_ti3 input is active, as per CC3P bitfield</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index disabled when tim_ti4 input is active, as per CC4P bitfield</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FIDX</name>
                <description>First index
This bit indicates if the first index only is taken into account</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index is always active</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the first Index only resets the counter</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IPOS</name>
                <description>Index positioning
In quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.
In directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.
x0: Index resets the counter when clock is 0
x1: Index resets the counter when clock is 1
Note: IPOS[1] bit is not significant</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Index resets the counter when AB = 00</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Index resets the counter when AB = 01</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Index resets the counter when AB = 10</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Index resets the counter when AB = 11</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PW</name>
                <description>Pulse width
This bitfield defines the pulse duration, as following:
tPW = PW[7:0] x tPWG</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PWPRSC</name>
                <description>Pulse width prescaler
This bitfield sets the clock prescaler for the pulse generator, as following:
tPWG = (2(PWPRSC[2:0])) x ttim_ker_ck</description>
                <bitOffset>24</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_TISEL</name>
            <displayName>TIM3_TISEL</displayName>
            <description>TIM3 timer input selection register</description>
            <addressOffset>0x5c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TI1SEL</name>
                <description>Selects tim_ti1[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti1_in0: TIMx_CH1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti1_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti1_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI2SEL</name>
                <description>Selects tim_ti2[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti2_in0: TIMx_CH2</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti2_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti2_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI3SEL</name>
                <description>Selects tim_ti3[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti3_in0: TIMx_CH3</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti3_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti3_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TI4SEL</name>
                <description>Selects tim_ti4[0..15] input
...
Refer to  for product specific implementation.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ti4_in0: TIMx_CH4</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ti4_in1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_ti4_in15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_AF1</name>
            <displayName>TIM3_AF1</displayName>
            <description>TIM3 alternate function register 1</description>
            <addressOffset>0x60</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ETRSEL</name>
                <description>etr_in source selection
These bits select the etr_in input source.
...
Refer to  for product specific implementation.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_etr0: TIMx_ETR input</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_etr1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xF</name>
                    <description>tim_etr15</description>
                    <value>0xF</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_AF2</name>
            <displayName>TIM3_AF2</displayName>
            <description>TIM3 alternate function register 2</description>
            <addressOffset>0x64</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OCRSEL</name>
                <description>ocref_clr source selection
These bits select the ocref_clr input source.
...
Refer to  for product specific implementation.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>tim_ocref_clr0</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>tim_ocref_clr1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>tim_ocref_clr7</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DCR</name>
            <displayName>TIM3_DCR</displayName>
            <description>TIM3 DMA control register</description>
            <addressOffset>0x3dc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBA</name>
                <description>DMA base address
This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_CR1,</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_CR2,</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TIMx_SMCR,</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBL</name>
                <description>DMA burst length
This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...
Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIM2_CR1.
If DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:
(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL
In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA
According to the configuration of the DMA Data Size, several cases may occur:
If the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.
If the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 transfer</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>2 transfers</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>3 transfers</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1A</name>
                    <description>26 transfers</description>
                    <value>0x1A</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DBSS</name>
                <description>DMA burst source selection
This bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).
Others: reserved</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CC1</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CC2</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CC3</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>CC4</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>COM</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>Trigger</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM3_DMAR</name>
            <displayName>TIM3_DMAR</displayName>
            <description>TIM3 DMA address for full transfer</description>
            <addressOffset>0x3e0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMAB</name>
                <description>DMA register for burst accesses
A read or write operation to the DMAR register accesses the register located at the address
(TIMx_CR1 address) + (DBA + DMA index) x 4
where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>TIM6</name>
        <description>Basic timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40001000</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM6</name>
          <description>TIM6 global interrupt</description>
          <value>49</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM6_CR1</name>
            <displayName>TIM6_CR1</displayName>
            <description>TIM6 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generates an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the CEN bit).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DITHEN</name>
                <description>Dithering enable
Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Dithering disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Dithering enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_CR2</name>
            <displayName>TIM6_CR2</displayName>
            <description>TIM6 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>MMS</name>
                <description>Master mode selection
These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
Note: The clock of the slave timer or he peripheral receiving the tim_trgo must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as a trigger output (tim_trgo).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, tim_cnt_en, is used as a trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated when the CEN control bit is written.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as a trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_DIER</name>
            <displayName>TIM6_DIER</displayName>
            <description>TIM6 DMA/Interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_SR</name>
            <displayName>TIM6_SR</displayName>
            <description>TIM6 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
On counter overflow if UDIS = 0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_EGR</name>
            <displayName>TIM6_EGR</displayName>
            <description>TIM6 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_CNT</name>
            <displayName>TIM6_CNT</displayName>
            <description>TIM6 counter</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value
Non-dithering mode (DITHEN = 0)
The register holds the counter value.
Dithering mode (DITHEN = 1)
The register only holds the non-dithered part in CNT[15:0]. The fractional part is not available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_PSC</name>
            <displayName>TIM6_PSC</displayName>
            <description>TIM6 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency ftim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).
PSC contains the value to be loaded into the active prescaler register at each update event.
(including when the counter is cleared through UG bit of TIMx_EGR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM6_ARR</name>
            <displayName>TIM6_ARR</displayName>
            <description>TIM6 auto-reload register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded into the actual auto-reload register.
Refer to  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.
Non-dithering mode (DITHEN = 0)
The register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	
    <peripheral>
        <name>TIM7</name>
        <description>Basic timers</description>
		<groupName>TIM</groupName>
        <baseAddress>0x40001400</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
		<interrupt>
          <name>TIM7</name>
          <description>TIM7 global interrupt</description>
          <value>50</value>
        </interrupt>
        <registers>
          <register>
            <name>TIM7_CR1</name>
            <displayName>TIM7_CR1</displayName>
            <description>TIM7 control register 1</description>
            <addressOffset>0x0</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CEN</name>
                <description>Counter enable
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDIS</name>
                <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>UEV enabled. The Update (UEV) event is generated by one of the following events:</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>URS</name>
                <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Any of the following events generates an update interrupt or DMA request if enabled. These events can be: </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Only counter overflow/underflow generates an update interrupt or DMA request if enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OPM</name>
                <description>One-pulse mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Counter is not stopped at update event</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Counter stops counting at the next update event (clearing the CEN bit).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ARPE</name>
                <description>Auto-reload preload enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TIMx_ARR register is not buffered.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TIMx_ARR register is buffered.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UIFREMAP</name>
                <description>UIF status bit remapping</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DITHEN</name>
                <description>Dithering enable
Note: The DITHEN bit can only be modified when CEN bit is reset.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Dithering disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Dithering enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_CR2</name>
            <displayName>TIM7_CR2</displayName>
            <description>TIM7 control register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>MMS</name>
                <description>Master mode selection
These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
Note: The clock of the slave timer or he peripheral receiving the tim_trgo must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Reset - the UG bit from the TIMx_EGR register is used as a trigger output (tim_trgo).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enable - the Counter enable signal, tim_cnt_en, is used as a trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated when the CEN control bit is written.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Update - The update event is selected as a trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_DIER</name>
            <displayName>TIM7_DIER</displayName>
            <description>TIM7 DMA/Interrupt enable register</description>
            <addressOffset>0xc</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIE</name>
                <description>Update interrupt enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDE</name>
                <description>Update DMA request enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Update DMA request disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update DMA request enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_SR</name>
            <displayName>TIM7_SR</displayName>
            <description>TIM7 status register</description>
            <addressOffset>0x10</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UIF</name>
                <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
On counter overflow if UDIS = 0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No update occurred.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Update interrupt pending. This bit is set by hardware when the registers are updated:</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_EGR</name>
            <displayName>TIM7_EGR</displayName>
            <description>TIM7 event generation register</description>
            <addressOffset>0x14</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>UG</name>
                <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No action.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_CNT</name>
            <displayName>TIM7_CNT</displayName>
            <description>TIM7 counter</description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Counter value
Non-dithering mode (DITHEN = 0)
The register holds the counter value.
Dithering mode (DITHEN = 1)
The register only holds the non-dithered part in CNT[15:0]. The fractional part is not available.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_PSC</name>
            <displayName>TIM7_PSC</displayName>
            <description>TIM7 prescaler</description>
            <addressOffset>0x28</addressOffset>
            <size>16</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
The counter clock frequency ftim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).
PSC contains the value to be loaded into the active prescaler register at each update event.
(including when the counter is cleared through UG bit of TIMx_EGR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM7_ARR</name>
            <displayName>TIM7_ARR</displayName>
            <description>TIM7 auto-reload register</description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000FFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARR</name>
                <description>Auto-reload value
ARR is the value to be loaded into the actual auto-reload register.
Refer to  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.
Non-dithering mode (DITHEN = 0)
The register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reserved.
Dithering mode (DITHEN = 1)
The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
        <name>USART1</name>
        <description>Universal synchronous asynchronous receiver transmitter</description>
        <groupName>USART</groupName>
        <baseAddress>0x40013800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <interrupt>
          <name>USART1</name>
          <description>USART1 global interrupt</description>
          <value>58</value>
        </interrupt>
        <registers>
          <register>
            <name>USART_CR1_enabled</name>
            <displayName>USART_CR1_enabled</displayName>
            <description>USART control register 1 [alternate] </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UE</name>
                <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1’. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever IDLE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNEIE</name>
                <description>RXFIFO not empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever ORE=1 or RXFNE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TC=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFNFIE</name>
                <description>TXFIFO not full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TXFNF =1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever PE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and Active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER8</name>
                <description>Oversampling mode
This bit can only be written when the USART is disabled (UE=0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Oversampling by 16</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Oversampling by 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTOIE</name>
                <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBIE</name>
                <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE=0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).
Note: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFEIE</name>
                <description>TXFIFO empty interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when TXFE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFFIE</name>
                <description>RXFIFO Full interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when RXFF=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
            <name>USART_CR1_disabled</name>
            <displayName>USART_CR1_disabled</displayName>
            <description>Control register 1</description>
            <alternateRegister>USART_CR1_enabled</alternateRegister>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <fields>
              <field>
                <name>UE</name>
                <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART prescaler and outputs disabled, low-power mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UESM</name>
                <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART not able to wake up the MCU from low-power mode.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART able to wake up the MCU from low-power mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver is enabled and begins searching for a start bit</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to ‘1’. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmitter is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmitter is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever IDLE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXNEIE</name>
                <description>Receive data register not empty
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever ORE=1 or RXNE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TC=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXEIE</name>
                <description>Transmit data register empty
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TXE =1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever PE=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Even parity</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Odd parity</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Parity control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity control enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Idle line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Address mark</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode permanently</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver can switch between Mute mode and Active mode. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the CMF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVER8</name>
                <description>Oversampling mode
This bit can only be written when the USART is disabled (UE=0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Oversampling by 16</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Oversampling by 8</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTOIE</name>
                <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the RTOF bit is set in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBIE</name>
                <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when the EOBF flag is set in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = ‘00’: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = ‘01’: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = ‘10’: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE=0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).
Note: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>FIFO mode is disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FIFO mode is enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
          </fields>
          </register>		  
          <register>
            <name>USART_CR2</name>
            <displayName>USART_CR2</displayName>
            <description>USART control register 2 </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SLVEN</name>
                <description>Synchronous Slave mode enable
When the SLVEN bit is set, the Synchronous slave mode is enabled.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Slave mode disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Slave mode enabled.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIS_NSS</name>
                <description>When the DIS_NSS bit is set, the NSS pin input is ignored.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SPI slave selection depends on NSS input pin.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SPI slave is always selected and NSS input pin is ignored.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADDM7</name>
                <description>7-bit Address Detection/4-bit Address Detection
This bit is for selection between 4-bit address detection or 7-bit address detection.
This bit can only be written when the USART is disabled (UE=0)
Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>4-bit address detection</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>7-bit address detection (in 8-bit data mode)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDL</name>
                <description>LIN break detection length
This bit is for selection between 11 bit or 10 bit break detection.
This bit can only be written when the USART is disabled (UE=0).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>10-bit break detection</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>11-bit break detection</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDIE</name>
                <description>LIN break detection interrupt enable
Break interrupt mask (break detection using break delimiter).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated whenever LBDF=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBCL</name>
                <description>Last bit clock pulse
This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in Synchronous mode.
The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.
This bit can only be written when the USART is disabled (UE=0).
Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The clock pulse of the last data bit is not output to the SCLK pin</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The clock pulse of the last data bit is output to the SCLK pin</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPHA</name>
                <description>Clock phase
This bit is used to select the phase of the clock output on the SCLK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see  and )
This bit can only be written when the USART is disabled (UE=0).
Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>The first clock transition is the first data capture edge</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The second clock transition is the first data capture edge</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPOL</name>
                <description>Clock polarity
This bit enables the user to select the polarity of the clock output on the SCLK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship
This bit can only be written when the USART is disabled (UE=0).
Note: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Steady low value on SCLK pin outside transmission window</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Steady high value on SCLK pin outside transmission window</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CLKEN</name>
                <description>Clock enable
This bit enables the user to enable the SCLK pin.
This bit can only be written when the USART is disabled (UE=0).
Note: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to .
In Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected:
UE = 0
SCEN = 1
GTPR configuration
CLKEN= 1
UE = 1</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SCLK pin disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SCLK pin enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP</name>
                <description>stop bits
These bits are used for programming the stop bits.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>1 stop bit</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>0.5 stop bit.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>2 stop bits</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>1.5 stop bits</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LINEN</name>
                <description>LIN mode enable
This bit is set and cleared by software.
The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LIN mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LIN mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SWAP</name>
                <description>Swap TX/RX pins
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX/RX pins are used as defined in standard pinout</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXINV</name>
                <description>RX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the RX line.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RX pin signal works using the standard logic levels (VDD =1/idle, Gnd=0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RX pin signal values are inverted. ((VDD =0/mark, Gnd=1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXINV</name>
                <description>TX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the TX line.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TX pin signal works using the standard logic levels (VDD =1/idle, Gnd=0/mark) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TX pin signal values are inverted. ((VDD =0/mark, Gnd=1/idle). </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATAINV</name>
                <description>Binary data inversion
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L) </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H). The parity bit is also inverted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MSBFIRST</name>
                <description>Most significant bit first
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data is transmitted/received with data bit 0 first, following the start bit. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data is transmitted/received with the MSB (bit 7/8) first, following the start bit. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABREN</name>
                <description>Auto baud rate enable
This bit is set and cleared by software.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Auto baud rate detection is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Auto baud rate detection is enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABRMOD</name>
                <description>Auto baud rate mode
These bits are set and cleared by software.
This bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).
Note: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)
If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Measurement of the start bit is used to detect the baud rate. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Falling edge to falling edge measurement (the received frame must start with a single bit = 1 -&gt; Frame = Start10xxxxxx)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>0x7F frame detection.</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>0x55 frame detection</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTOEN</name>
                <description>Receiver timeout enable
This bit is set and cleared by software.
When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver timeout feature disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver timeout feature enabled. </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ADD</name>
                <description>Address of the USART node
These bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:
In Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.
In low-power mode: they are used for wake up from low-power mode on character match.
When WUS[1:0] is programmed to 0b00 (WUF active on address match), the wakeup from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.
In Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.
These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_CR3</name>
            <displayName>USART_CR3</displayName>
            <description>USART control register 3 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EIE</name>
                <description>Error interrupt enable
Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>interrupt generated when FE=1 or ORE=1 or NE=1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IREN</name>
                <description>IrDA mode enable
This bit is set and cleared by software.
This bit can only be written when the USART is disabled (UE=0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>IrDA disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>IrDA enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IRLP</name>
                <description>IrDA low-power
This bit is used for selecting between normal and low-power IrDA modes
This bit can only be written when the USART is disabled (UE=0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low-power mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HDSEL</name>
                <description>Half-duplex selection
Selection of Single-wire Half-duplex mode
This bit can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Half-duplex mode is not selected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Half-duplex mode is selected </description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NACK</name>
                <description>Smartcard NACK enable
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>NACK transmission in case of parity error is disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>NACK transmission during parity error is enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCEN</name>
                <description>Smartcard mode enable
This bit is used for enabling Smartcard mode.
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Smartcard mode disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Smartcard mode enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAR</name>
                <description>DMA enable receiver
This bit is set/reset by software</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for reception</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DMAT</name>
                <description>DMA enable transmitter
This bit is set/reset by software</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA mode is enabled for transmission</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA mode is disabled for transmission</description>
                    <value>0x0</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTSE</name>
                <description>RTS enable
This bit can only be written when the USART is disabled (UE=0).
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSE</name>
                <description>CTS enable
This bit can only be written when the USART is disabled (UE=0)
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CTS hardware flow control disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIE</name>
                <description>CTS interrupt enable
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt is inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>An interrupt is generated whenever CTSIF=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONEBIT</name>
                <description>One sample bit method enable
This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.
This bit can only be written when the USART is disabled (UE=0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Three sample bit method</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>One sample bit method</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVRDIS</name>
                <description>Overrun Disable
This bit is used to disable the receive overrun detection.
the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.
This bit can only be written when the USART is disabled (UE=0).
Note: This control bit enables checking the communication flow w/o reading the data</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Overrun Error Flag, ORE, is set when received data is not read before receiving new data. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun functionality is disabled. If new data is received while the RXNE flag is still set</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDRE</name>
                <description>DMA Disable on Reception Error
This bit can only be written when the USART is disabled (UE=0).
Note: The reception errors are: parity error, framing error or noise error.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred. (used for Smartcard mode)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE(RXFNE is case FIFO mode is enabled) before clearing the error flag.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEM</name>
                <description>Driver enable mode
This bit enables the user to activate the external transceiver control, through the DE signal.
This bit can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE function is disabled. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE function is enabled. The DE signal is output on the RTS pin.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEP</name>
                <description>Driver enable polarity selection
This bit can only be written when the USART is disabled (UE=0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>DE signal is active high. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DE signal is active low.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SCARCNT</name>
                <description>Smartcard auto-retry count
This bitfield specifies the number of retries for transmission and reception in Smartcard mode.
In Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).
In Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).
This bitfield must be programmed only when the USART is disabled (UE=0).
When the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission.
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>17</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>retransmission disabled - No automatic retransmission in Transmission mode. </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>number of automatic retransmission attempts (before signaling error)</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUS0</name>
                <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WUF active on address match (as defined by ADD[7:0] and ADDM7)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>WUF active on start bit detection</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>WUF active on RXNE/RXFNE. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUS1</name>
                <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the USART is disabled (UE=0).
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WUF active on address match (as defined by ADD[7:0] and ADDM7)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>WUF active on start bit detection</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>WUF active on RXNE/RXFNE. </description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUFIE</name>
                <description>Wakeup from low-power mode interrupt enable
This bit is set and cleared by software.
Note: WUFIE must be set before entering in low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever WUF=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTIE</name>
                <description>TXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCBGTIE</name>
                <description>Transmission Complete before guard time, interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated whenever TCBGT=1 in the USART_ISR register</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTCFG</name>
                <description>Receive FIFO threshold configuration
Remaining combinations: Reserved</description>
                <bitOffset>25</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO reaches 1/8 of its depth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reaches 1/4 of its depth</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>Receive FIFO reaches 1/2 of its depth</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>Receive FIFO reaches 3/4 of its depth</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>Receive FIFO reaches 7/8 of its depth</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>Receive FIFO becomes full</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFTIE</name>
                <description>RXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Interrupt inhibited</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFTCFG</name>
                <description>TXFIFO threshold configuration
Remaining combinations: Reserved</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO reaches 1/8 of its depth</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reaches 1/4 of its depth</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>TXFIFO reaches 1/2 of its depth</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>TXFIFO reaches 3/4 of its depth</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>TXFIFO reaches 7/8 of its depth</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>TXFIFO becomes empty</description>
                    <value>0x5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_BRR</name>
            <displayName>USART_BRR</displayName>
            <description>USART baud rate register </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BRR</name>
                <description>USART baud rate
BRR[15:4]
BRR[15:4] correspond to USARTDIV[15:4]
BRR[3:0]
When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].
When OVER8 = 1:
BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.
BRR[3] must be kept cleared.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_GTPR</name>
            <displayName>USART_GTPR</displayName>
            <description>USART guard time and prescaler register </description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PSC</name>
                <description>Prescaler value
PSC[7:0] = IrDA Normal and Low-power baud rate
This bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency:
The source clock is divided by the value given in the register (8 significant bits):
...
PSC[4:0]: Prescaler value
This bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock.
The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:
...
This bitfield can only be written when the USART is disabled (UE=0).
Note: Bits [7:5] must be kept cleared if Smartcard mode is used.
This bitfield is reserved and forced by hardware to ‘0’ when the Smartcard and IrDA modes are not supported. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                    <description>Reserved - do not program this value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                    <description>divides the source clock by 1</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_IRDA_LOW_POWER_AND_NORMAL_IRDA_MODE</name>
                    <description>divides the source clock by 2</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_SMARTCARD_MODE</name>
                    <description>Reserved - do not program this value</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_SMARTCARD_MODE</name>
                    <description>divides the source clock by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2_SMARTCARD_MODE</name>
                    <description>divides the source clock by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3_SMARTCARD_MODE</name>
                    <description>divides the source clock by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GT</name>
                <description>Guard time value
This bitfield is used to program the Guard time value in terms of number of baud clock periods.
This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.
This bitfield can only be written when the USART is disabled (UE=0).
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RTOR</name>
            <displayName>USART_RTOR</displayName>
            <description>USART receiver timeout register </description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RTO</name>
                <description>Receiver timeout value
This bitfield gives the Receiver timeout value in terms of number of bit duration.
In Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.
In Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.
Note: This value must only be programmed once per received character.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BLEN</name>
                <description>Block Length
This bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.
Examples:
BLEN = 0 -&gt; 0 information characters + LEC
BLEN = 1 -&gt; 0 information characters + CRC
BLEN = 255 -&gt; 254 information characters + CRC (total 256 characters))
In Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled).
This bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.
Note: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RQR</name>
            <displayName>USART_RQR</displayName>
            <description>USART request register </description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ABRRQ</name>
                <description>auto baud rate request
Writing 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>SBKRQ</name>
                <description>Send break request
Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.
Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>MMRQ</name>
                <description>Mute mode request
Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RXFRQ</name>
                <description>Receive data flush request
Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.
This enables to discard the received data without reading them, and avoid an overrun condition.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXFRQ</name>
                <description>Transmit data flush request
When FIFO mode is disabled, writing ‘1’ to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.
When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.
Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_ISR_enabled</name>
            <displayName>USART_ISR_enabled</displayName>
            <description>USART interrupt and status register </description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x000000C0</resetValue>
            <resetMask>0xF00FFFFF</resetMask>
            <fields>
              <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
An interrupt is generated if PEIE = 1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No parity error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Parity error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE = 1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Framing error is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Framing error or break character is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NE</name>
                <description>Noise detection flag
This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2317).
This error is associated with the character in the USART_RDR.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No noise is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Noise is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
An interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register.
Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No overrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Overrun error is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Idle line is detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Idle line is detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFNE</name>
                <description>RXFIFO not empty
RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.
RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
An interrupt is generated if RXFNEIE=1 in the USART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Data is not received</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Received data is ready to be read.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:
When TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set.
When TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.
When TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.
When TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.
An interrupt is generated if TCIE=1 in the USART_CR1 register.
TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFNF</name>
                <description>TXFIFO not full
TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.
An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.
Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time).
This bit is used during single buffer transmission.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmit FIFO is full</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmit FIFO is not full</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LBDF</name>
                <description>LIN break detection flag
This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LIN Break not detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>LIN break detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
An interrupt is generated if CTSIE=1 in the USART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No change occurred on the nCTS status line</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>A change occurred on the nCTS status line</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>nCTS line set</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>nCTS line reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RTOF</name>
                <description>Receiver timeout
This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
An interrupt is generated if RTOIE=1 in the USART_CR2 register.
In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Timeout value not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Timeout value reached without any data reception</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EOBF</name>
                <description>End of block flag
This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
An interrupt is generated if EOBIE = 1 in the USART_CR1 register.
It is cleared by software, writing 1 to EOBCF in the USART_ICR register.
Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>End of Block not reached</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>End of Block (number of characters) reached</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UDR</name>
                <description>SPI slave underrun error flag
In Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No underrun error</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>underrun error</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ABRE</name>
                <description>Auto baud rate error
This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ABRF</name>
                <description>Auto baud rate flag
This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)
It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USART is idle (no reception)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Reception on going</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
An interrupt is generated if CMIE=1in the USART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No Character match detected</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Character match detected</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No break character transmitted</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Break character transmitted</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receiver in Active mode</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receiver in Mute mode</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
An interrupt is generated if WUFIE=1 in the USART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
It can be used to verify that the USART is ready for reception before entering low-power mode.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TXFE</name>
                <description>TXFIFO Empty
This bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.
An interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO not empty.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO empty.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFF</name>
                <description>RXFIFO Full
This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.
An interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RXFIFO not full.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RXFIFO Full.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TCBGT</name>
                <description>Transmission complete before guard time flag
This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.
This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 2297.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RXFT</name>
                <description>RXFIFO threshold flag
This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register.
Note: When the RXFTCFG threshold is configured to ‘101’, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Receive FIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Receive FIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TXFT</name>
                <description>TXFIFO threshold flag
This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>TXFIFO does not reach the programmed threshold.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>TXFIFO reached the programmed threshold.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
		  <register>
			  <name>USART_ISR_disabled</name>
			  <displayName>USART_ISR_disabled</displayName>
			  <description>Interrupt and status register</description>
			  <alternateRegister>USART_ISR_enabled</alternateRegister>
			  <addressOffset>0x1C</addressOffset>
			  <size>0x20</size>
			  <access>read-only</access>
			  <resetValue>0x000000C0</resetValue>
			  <fields>
			    <field>
					<name>PE</name>
					<description>Parity error
	This bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
	An interrupt is generated if PEIE = 1 in the USART_CR1 register.
	Note: This error is associated with the character in the USART_RDR.</description>
					<bitOffset>0</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No parity error</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Parity error</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>FE</name>
					<description>Framing error
	This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
	When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
	An interrupt is generated if EIE = 1 in the USART_CR1 register.
	Note: This error is associated with the character in the USART_RDR.</description>
					<bitOffset>1</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No Framing error is detected</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Framing error or break character is detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>NE</name>
					<description>Noise detection flag
	This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.
	Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
	When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2317).
	This error is associated with the character in the USART_RDR.</description>
					<bitOffset>2</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No noise is detected</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Noise is detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>ORE</name>
					<description>Overrun error
	This bit is set by hardware when the data currently being received in the shift register is
	ready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
	An interrupt is generated if RXNEIE=1 or EIE = 1 in the USART_CR1 register.
	Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
	This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
					<bitOffset>3</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No overrun error</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Overrun error is detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>IDLE</name>
					<description>Idle line detected
	This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
	Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).
	If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.</description>
					<bitOffset>4</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No Idle line is detected</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Idle line is detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>RXNE</name>
					<description>Read data register not empty
	RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
	An interrupt is generated if RXNEIE=1 in the USART_CR1 register.</description>
					<bitOffset>5</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>Data is not received</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Received data is ready to be read.</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>TC</name>
					<description>Transmission complete
	This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag is set when the transmission of a frame containing data is complete and when TXE is set.
	An interrupt is generated if TCIE=1 in the USART_CR1 register.
	TC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register.</description>
					<bitOffset>6</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>TXE</name>
					<description>Transmit data register empty
	TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T=0 mode, in case of transmission failure).
	An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.</description>
					<bitOffset>7</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>Data register full</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Data register full</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>LBDF</name>
					<description>LIN break detection flag
	This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
	An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
	Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>8</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>LIN Break not detected</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>LIN break detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>CTSIF</name>
					<description>CTS interrupt flag
	This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
	An interrupt is generated if CTSIE=1 in the USART_CR3 register.
	Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
					<bitOffset>9</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No change occurred on the nCTS status line</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>A change occurred on the nCTS status line</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>CTS</name>
					<description>CTS flag
	This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
	Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
					<bitOffset>10</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>nCTS line set</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>nCTS line reset</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>RTOF</name>
					<description>Receiver timeout
	This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
	An interrupt is generated if RTOIE=1 in the USART_CR2 register.
	In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
	Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
	The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
	If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
					<bitOffset>11</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>Timeout value not reached</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Timeout value reached without any data reception</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>EOBF</name>
					<description>End of block flag
	This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
	An interrupt is generated if EOBIE = 1 in the USART_CR1 register.
	It is cleared by software, writing 1 to EOBCF in the USART_ICR register.
	Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>12</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>End of Block not reached</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>End of Block (number of characters) reached</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>UDR</name>
					<description>SPI slave underrun error flag
	In Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
	Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>13</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No underrun error</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>underrun error</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>ABRE</name>
					<description>Auto baud rate error
	This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
	It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.
	Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
					<bitOffset>14</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>ABRF</name>
					<description>Auto baud rate flag
	This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXNE and FE are also set in this case)
	It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
	Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
					<bitOffset>15</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>BUSY</name>
					<description>Busy flag
	This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
					<bitOffset>16</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>USART is idle (no reception)</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Reception on going</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>CMF</name>
					<description>Character match flag
	This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
	An interrupt is generated if CMIE=1in the USART_CR1 register.</description>
					<bitOffset>17</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No Character match detected</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Character match detected</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>SBKF</name>
					<description>Send break flag
	This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
					<bitOffset>18</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>No break character transmitted</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Break character transmitted</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>RWU</name>
					<description>Receiver wakeup from Mute mode
	This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
	When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
	Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>19</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>Receiver in Active mode</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Receiver in Mute mode</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
				  <field>
					<name>WUF</name>
					<description>Wakeup from low-power mode flag
	This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
	An interrupt is generated if WUFIE=1 in the USART_CR3 register.
	Note: When UESM is cleared, WUF flag is also cleared.
	If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>20</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>TEACK</name>
					<description>Transmit enable acknowledge flag
	This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
	It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.</description>
					<bitOffset>21</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>REACK</name>
					<description>Receive enable acknowledge flag
	This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
	It can be used to verify that the USART is ready for reception before entering low-power mode.
	Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
					<bitOffset>22</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
				  </field>
				  <field>
					<name>TCBGT</name>
					<description>Transmission complete before guard time flag
	This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
	It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.
	This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
	Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 2297.</description>
					<bitOffset>25</bitOffset>
					<bitWidth>1</bitWidth>
					<access>read-only</access>
					<enumeratedValues>
					  <enumeratedValue>
						<name>B_0x0</name>
						<description>Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)</description>
						<value>0x0</value>
					  </enumeratedValue>
					  <enumeratedValue>
						<name>B_0x1</name>
						<description>Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).</description>
						<value>0x1</value>
					  </enumeratedValue>
					</enumeratedValues>
				  </field>
			</fields>
		  </register>		  
          <register>
            <name>USART_ICR</name>
            <displayName>USART_ICR</displayName>
            <description>USART interrupt flag clear register </description>
            <addressOffset>0x20</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PECF</name>
                <description>Parity error clear flag
Writing 1 to this bit clears the PE flag in the USART_ISR register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FECF</name>
                <description>Framing error clear flag
Writing 1 to this bit clears the FE flag in the USART_ISR register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>NECF</name>
                <description>Noise detected clear flag
Writing 1 to this bit clears the NE flag in the USART_ISR register.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>ORECF</name>
                <description>Overrun error clear flag
Writing 1 to this bit clears the ORE flag in the USART_ISR register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>IDLECF</name>
                <description>Idle line detected clear flag
Writing 1 to this bit clears the IDLE flag in the USART_ISR register.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TXFECF</name>
                <description>TXFIFO empty clear flag
Writing 1 to this bit clears the TXFE flag in the USART_ISR register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TCCF</name>
                <description>Transmission complete clear flag
Writing 1 to this bit clears the TC flag in the USART_ISR register.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>TCBGTCF</name>
                <description>Transmission complete before Guard time clear flag
Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>LBDCF</name>
                <description>LIN break detection clear flag
Writing 1 to this bit clears the LBDF flag in the USART_ISR register.
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CTSCF</name>
                <description>CTS clear flag
Writing 1 to this bit clears the CTSIF flag in the USART_ISR register.
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>RTOCF</name>
                <description>Receiver timeout clear flag
Writing 1 to this bit clears the RTOF flag in the USART_ISR register.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page 2297.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>EOBCF</name>
                <description>End of block clear flag
Writing 1 to this bit clears the EOBF flag in the USART_ISR register.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>UDRCF</name>
                <description>SPI slave underrun clear flag
Writing 1 to this bit clears the UDRF flag in the USART_ISR register.
Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CMCF</name>
                <description>Character match clear flag
Writing 1 to this bit clears the CMF flag in the USART_ISR register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>WUCF</name>
                <description>Wakeup from low-power mode clear flag
Writing 1 to this bit clears the WUF flag in the USART_ISR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_RDR</name>
            <displayName>USART_RDR</displayName>
            <description>USART receive data register </description>
            <addressOffset>0x24</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDR</name>
                <description>Receive data value
Contains the received data character.
The RDR register provides the parallel interface between the input shift register and the internal bus (see ).
When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_TDR</name>
            <displayName>USART_TDR</displayName>
            <description>USART transmit data register </description>
            <addressOffset>0x28</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDR</name>
                <description>Transmit data value
Contains the data character to be transmitted.
The USART_TDR register provides the parallel interface between the internal bus and the output shift register (see ).
When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.
Note: This register must be written only when TXE/TXFNF=1.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USART_PRESC</name>
            <displayName>USART_PRESC</displayName>
            <description>USART prescaler register </description>
            <addressOffset>0x2c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRESCALER</name>
                <description>Clock prescaler
The USART input clock can be divided by a prescaler factor:
Remaining combinations: Reserved
Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to ‘1011’ i.e. input clock divided by 256.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>input clock not divided</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>input clock divided by 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>input clock divided by 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>input clock divided by 6</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>input clock divided by 8</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>input clock divided by 10</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>input clock divided by 12</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>input clock divided by 16</description>
                    <value>0x7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x8</name>
                    <description>input clock divided by 32</description>
                    <value>0x8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x9</name>
                    <description>input clock divided by 64</description>
                    <value>0x9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xA</name>
                    <description>input clock divided by 128</description>
                    <value>0xA</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0xB</name>
                    <description>input clock divided by 256</description>
                    <value>0xB</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>	  	
    <peripheral derivedFrom="USART1">
      <name>USART2</name>
      <baseAddress>0x40004400</baseAddress>
      <interrupt>
        <name>USART2</name>
        <description>USART2 global interrupt</description>
        <value>59</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="USART1">
      <name>USART3</name>
      <baseAddress>0x40004800</baseAddress>
      <interrupt>
        <name>USART3</name>
        <description>USART3 global interrupt</description>
        <value>60</value>
      </interrupt>
    </peripheral> 
	<peripheral>
      <name>USB</name>
      <description>USB full speed</description>
      <groupName>USB</groupName>
      <baseAddress>0x40016000</baseAddress>
      <addressBlock>
      <offset>0x0</offset>
      <size>0x400</size>
      <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USB_FS</name>
        <description>USB OTG FS global interrupt</description>
        <value>74</value>
      </interrupt>
      <registers>
          <register>
            <name>USB_CHEP0R</name>
            <displayName>USB_CHEP0R</displayName>
            <description>USB endpoint/channel 0 register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP1R</name>
            <displayName>USB_CHEP1R</displayName>
            <description>USB endpoint/channel 1 register</description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP2R</name>
            <displayName>USB_CHEP2R</displayName>
            <description>USB endpoint/channel 2 register</description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP3R</name>
            <displayName>USB_CHEP3R</displayName>
            <description>USB endpoint/channel 3 register</description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP4R</name>
            <displayName>USB_CHEP4R</displayName>
            <description>USB endpoint/channel 4 register</description>
            <addressOffset>0x10</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP5R</name>
            <displayName>USB_CHEP5R</displayName>
            <description>USB endpoint/channel 5 register</description>
            <addressOffset>0x14</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP6R</name>
            <displayName>USB_CHEP6R</displayName>
            <description>USB endpoint/channel 6 register</description>
            <addressOffset>0x18</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CHEP7R</name>
            <displayName>USB_CHEP7R</displayName>
            <description>USB endpoint/channel 7 register</description>
            <addressOffset>0x1c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EA</name>
                <description>endpoint/channel address
Device mode
Software must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.
Host mode
Software must write in this field the 4-bit address used to identify the channel addressed by the host transaction.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>STATTX</name>
                <description>Status bits, for transmission transfers
Device mode
These bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.
Double-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can only be “VALID” or “DISABLED”. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to ‘STALL’ or ‘NAK’ for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
The STATTX bits contain the information about the channel status. Refer to  for the full descriptions (“Host mode” descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGTX</name>
                <description>Data toggle, for transmission transfers
If the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.
If the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)
If the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTTX</name>
                <description>Valid USB transaction transmitted
Device mode
This bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written.
Host mode
Same as VTRX behavior but for USB OUT and SETUP transactions.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EPKIND</name>
                <description>endpoint/channel kind
The meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.
DBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.
STATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UTYPE</name>
                <description>USB type of transaction
These bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.
Bulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.
The usage of isochronous channels/endpoints is explained in transfers in Device mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP</name>
                <description>Setup transaction completed
Device mode
This bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.
Host mode
This bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>STATRX</name>
                <description>Status bits, for reception transfers
Device mode
These bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.
Double-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).
If the endpoint is defined as isochronous, its status can be only “VALID” or “DISABLED”, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to ‘STALL’ or ‘NAK’ for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.
Host mode
These bits are the host application controls to start, retry, or abort host transactions driven by the channel.
These bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:
-	DISABLE
DISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.
-	VALID
A host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.
VALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.
- NAK
NAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE
- STALL
STALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DTOGRX</name>
                <description>Data Toggle, for reception transfers
If the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).
If the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).
If the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.
This bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>VTRX</name>
                <description>USB valid transaction received
Device mode
This bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.
A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.
This bit is read/write but only 0 can be written, writing 1 has no effect.
Host mode
This bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.
- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.
- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.
- A transaction ended with ACK handshake sets this bit
If double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.
If double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.
- A transaction ended with error sets this bit.
Errors can be seen via the bits ERR_RX (host mode only).
This bit is read/write but only 0 can be written, writing 1 has no effect.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEVADDR</name>
                <description>Host mode
Device address assigned to the endpoint during the enumeration process.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NAK</name>
                <description>Host mode
This bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device.</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LS_EP</name>
                <description>Low speed endpoint – host with HUB only
Host mode
This bit is set by the software to send an LS transaction to the corresponding endpoint.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Full speed endpoint</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Low speed endpoint</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERR_TX</name>
                <description>Received error for an OUT/SETUP transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_RX</name>
                <description>Received error for an IN transaction
Host mode
This bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THREE_ERR_TX</name>
                <description>Three errors for an OUT or SETUP transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>27</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THREE_ERR_RX</name>
                <description>Three errors for an IN transaction
Host mode
This bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.
Coding of the received error:</description>
                <bitOffset>29</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Less than 3 errors received.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>More than 3 errors received, last error is timeout error.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>More than 3 errors received, last error is data error (CRC error).</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>More than 3 errors received, last error is protocol error (invalid PID, false EOP, bitstuffing error, SYNC error).</description>
                    <value>0x3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CNTR</name>
            <displayName>USB_CNTR</displayName>
            <addressOffset>0x40</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000003</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>USBRST</name>
                <description>USB Reset
Software can set this bit to reset the USB core, exactly as it happens when receiving a RESET signaling on the USB.The USB peripheral, in response to a RESET, resets its internal protocol state machine. Reception and transmission are disabled until the RST_DCON bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RST_DCON interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event.
Software sets this bit to drive USB reset state on the bus and initialize the device. USB reset terminates as soon as this bit is cleared by software.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_DEVICE_MODE</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_DEVICE_MODE</name>
                    <description>USB core is under reset</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_HOST_MODE</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_HOST_MODE</name>
                    <description>USB reset driven</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PDWN</name>
                <description>Power down
This bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Exit power down.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Enter power down mode.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPRDY</name>
                <description>Suspend state effective
This bit is set by hardware as soon as the suspend state entered through the SUSPEN control gets internally effective. In this state USB activity is suspended, USB clock is gated, transceiver is set in low power mode by disabling the differential receiver. Only asynchronous wakeup logic and single ended receiver is kept alive to detect remote wakeup or resume events.
Software must poll this bit to confirm it to be set before any STOP mode entry.
This bit is cleared by hardware simultaneously to the WAKEUP flag being set.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal operation</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Suspend state</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPEN</name>
                <description>Suspend state enable
Software can set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 3 ms. Software can also set this bit when the L1REQ interrupt is received with positive acknowledge sent.
As soon as the suspend state is propagated internally all device activity is stopped, USB clock is gated, USB transceiver is set into low power mode and the SUSPRDY bit is set by hardware. In the case that device application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the microcontroller to stop mode, as in the case of bus powered device application, it must first wait few cycles to see the SUSPRDY = 1 acknowledge the suspend request.
This bit is cleared by hardware simultaneous with the WAKEUP flag set.
Software can set this bit when host application has nothing scheduled for the next frames and wants to enter long term power saving. When set, it stops immediately SOF generation and any other host activity, gates the USB clock and sets the transceiver in low power mode. If any USB transaction is on-going at the time SUSPEN is set, suspend is entered at the end of the current transaction.
As soon as suspend state is propagated internally and gets effective the SUSPRDY bit is set. In the case that host application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the micro-controller to STOP mode, it must first wait few cycles to see SUSPRDY=1 acknowledge to the suspend request.
This bit is cleared by hardware simultaneous with the WAKEUP flag set.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0_DEVICE_MODE</name>
                    <description>No effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_DEVICE_MODE</name>
                    <description>Enter L1/L2 suspend</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x0_HOST_MODE</name>
                    <description>No effect.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1_HOST_MODE</name>
                    <description>Enter L1/L2 suspend</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>L2RES</name>
                <description>L2 remote wakeup / resume driver
Device mode
The microcontroller can set this bit to send remote wake-up signaling to the host. It must be activated, according to USB specifications, for no less than 1 ms and no more than 15 ms after which the host PC is ready to drive the resume sequence up to its end.
Host mode
Software sets this bit to send resume signaling to the device.
Software clears this bit to send end of resume to device and restart SOF generation.
In the context of remote wake up, this bit is to be set following the WAKEUP interrupt.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Send L2 resume signaling to device</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>L1RES</name>
                <description>L1 remote wakeup / resume driver
Device mode
Software sets this bit to send a LPM L1 50 μs remote wakeup signaling to the host. After the signaling ends, this bit is cleared by hardware.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No effect</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Send 50 μs remote-wakeup signaling to host</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>L1REQM</name>
                <description>LPM L1 state request interrupt mask</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>LPM L1 state request (L1REQ) interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>L1REQ interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ESOFM</name>
                <description>Expected start of frame interrupt mask</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Expected start of frame (ESOF) interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ESOF interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SOFM</name>
                <description>Start of frame interrupt mask</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>SOF interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SOF interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RST_DCONM</name>
                <description>USB reset request (Device mode) or device connect/disconnect (Host mode) interrupt mask</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>RESET interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>RESET interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SUSPM</name>
                <description>Suspend mode interrupt mask</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Suspend mode request (SUSP) interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>SUSP interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WKUPM</name>
                <description>Wakeup interrupt mask</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>WKUP interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>WKUP interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ERRM</name>
                <description>Error interrupt mask</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>ERR interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>ERR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PMAOVRM</name>
                <description>Packet memory area over / underrun interrupt mask</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>PMAOVR interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PMAOVR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CTRM</name>
                <description>Correct transfer interrupt mask</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Correct transfer (CTR) interrupt disabled.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CTR interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>THR512M</name>
                <description>512 byte threshold interrupt mask</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>512 byte threshold interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>512 byte threshold interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDISCM</name>
                <description>Device disconnection mask
Host mode</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Device disconnection interrupt disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Device disconnection interrupt enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HOST</name>
                <description>HOST mode
HOST bit selects betweens host or device USB mode of operation. It must be set before enabling the USB peripheral by the function enable bit.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>USB Device function</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>USB host function</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_ISTR</name>
            <displayName>USB_ISTR</displayName>
            <description>USB interrupt status register </description>
            <addressOffset>0x44</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IDN</name>
                <description>Device Endpoint / host channel identification number
These bits are written by the hardware according to the host channel or device endpoint number, which generated the interrupt request. If several endpoint/channel transactions are pending, the hardware writes the identification number related to the endpoint/channel having the highest priority defined in the following way: two levels are defined, in order of priority: isochronous and double-buffered bulk channels/endpoints are considered first and then the others are examined. If more than one endpoint/channel from the same set is requesting an interrupt, the IDN bits in USB_ISTR register are assigned according to the lowest requesting register, CHEP0R having the highest priority followed by CHEP1R and so on. The application software can assign a register to each endpoint/channel according to this priority scheme, so as to order the concurring endpoint/channel requests in a suitable way. These bits are read only.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIR</name>
                <description>Direction of transaction
This bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.
If DIR bit = 0, VTTX bit is set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC).
If DIR bit = 1, VTRX bit or both VTTX/VTRX are set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed.
This information can be used by the application software to access the USB_CHEPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>L1REQ</name>
                <description>LPM L1 state request
Device mode
This bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ESOF</name>
                <description>Expected start of frame
Device mode
This bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each 1 ms, but if the device does not receive it properly, the suspend timer issues this interrupt. If three consecutive ESOF interrupts are generated (for example three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the suspend timer is not yet locked. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOF</name>
                <description>Start of frame
This bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 1 ms synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this could be useful for isochronous applications). This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RST_DCON</name>
                <description>USB reset request (Device mode) or device connect/disconnect (Host mode)
Device mode
This bit is set by hardware when an USB reset is released by the host and the bus returns to idle. USB reset state is internally detected after the sampling of 60 consecutive SE0 cycles.
Host mode
This bit is set by hardware when device connection or device disconnection is detected. Device connection is signaled after J state is sampled for 22 cycles consecutively from unconnected state. Device disconnection is signaled after SE0 state is seen for 22 bit times consecutively from connected state.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>Suspend mode request
Device mode
This bit is set by the hardware when no traffic has been received for 3 ms, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (SUSPEN=1) until the end of resume sequence. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WKUP</name>
                <description>Wakeup
This bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the SUSPRDY bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (for example wakeup unit) about the start of the resume process. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR</name>
                <description>Error
This flag is set whenever one of the errors listed below has occurred:
NANS:	No ANSwer. The timeout for a host response has expired.
CRC:	Cyclic redundancy check error. One of the received CRCs, either in the token or in the data, was wrong.
BST:	Bit stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or CRC.
FVIO:	Framing format violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.).
The USB software can usually ignore errors, since the USB peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (for example loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PMAOVR</name>
                <description>Packet memory area over / underrun
This bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host retries the transaction. The PMAOVR interrupt should never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR</name>
                <description>Completed transfer in host mode
This bit is set by the hardware to indicate that an endpoint/channel has successfully completed a transaction; using DIR and IDN bits software can determine which endpoint/channel requested the interrupt. This bit is read-only.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>THR512</name>
                <description>512 byte threshold interrupt
This bit is set to 1 by the hardware when 512 bytes have been transmitted or received during isochronous transfers. This bit is read/write but only 0 can be written and writing 1 has no effect. Note that no information is available to indicate the associated channel/endpoint, however in practice only one ISO endpoint/channel with such large packets can be supported, so that channel.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DDISC</name>
                <description>Device connection
Host mode
This bit is set when a device connection is detected. This bit is read/write but only 0 can be written and writing 1 has no effect.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DCON_STAT</name>
                <description>Device connection status
Host mode:
This bit contains information about device connection status. It is set by hardware when a LS/FS device is attached to the host while it is reset when the device is disconnected.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>No device connected </description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>FS or LS device connected to the host</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LS_DCON</name>
                <description>Low speed device connected
Host mode:
This bit is set by hardware when an LS device connection is detected. Device connection is signaled after LS J-state is sampled for 22 consecutive cycles of the USB clock (48 MHz) from the unconnected state.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_FNR</name>
            <displayName>USB_FNR</displayName>
            <description>USB frame number register </description>
            <addressOffset>0x48</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFF000</resetMask>
            <fields>
              <field>
                <name>FN</name>
                <description>Frame number
This bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for isochronous transfers. This bit field is updated on the generation of an SOF interrupt.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LSOF</name>
                <description>Lost SOF
Device mode
These bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LCK</name>
                <description>Locked
Device mode
This bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXDM</name>
                <description>Receive data - line status
This bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RXDP</name>
                <description>Receive data + line status
This bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_DADDR</name>
            <displayName>USB_DADDR</displayName>
			<description>USB_DADDR</description>
            <addressOffset>0x4c</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADD</name>
                <description>Device address
Device mode
These bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the endpoint/channel address (EA) field in the associated USB_CHEPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint.
Host mode
These bits contain the address transmitted with the LPM transaction</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EF</name>
                <description>Enable function
This bit is set by the software to enable the USB Device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at 0 no transactions are handled, irrespective of the settings of USB_CHEPnR registers.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_LPMCSR</name>
            <displayName>USB_LPMCSR</displayName>
			<description>USB_LPMCSR</description>
            <addressOffset>0x54</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LPMEN</name>
                <description>LPM support enable
Device mode
This bit is set by the software to enable the LPM support within the USB Device. If this bit is at 0 no LPM transactions are handled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LPMACK</name>
                <description>LPM token acknowledge enable
Device mode:
The NYET/ACK is returned only on a successful LPM transaction:
No errors in both the EXT token and the LPM token (else ERROR)
A valid bLinkState = 0001B (L1) is received (else STALL)</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>the valid LPM token is NYET.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>the valid LPM token is ACK.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>REMWAKE</name>
                <description>bRemoteWake value
Device mode
This bit contains the bRemoteWake value received with last ACKed LPM Token</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BESL</name>
                <description>BESL value
Device mode
These bits contain the BESL value received with last ACKed LPM Token</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_BCDR</name>
            <displayName>USB_BCDR</displayName>
			<description>USB_BCDR</description>
            <addressOffset>0x58</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BCDEN</name>
                <description>Battery charging detector (BCD) enable
Device mode
This bit is set by the software to enable the BCD support within the USB Device. When enabled, the USB PHY is fully controlled by BCD and cannot be used for normal communication. Once the BCD discovery is finished, the BCD should be placed in OFF mode by clearing this bit to 0 in order to allow the normal USB operation.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DCDEN</name>
                <description>Data contact detection (DCD) mode enable
Device mode
This bit is set by the software to put the BCD into DCD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PDEN</name>
                <description>Primary detection (PD) mode enable
Device mode
This bit is set by the software to put the BCD into PD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SDEN</name>
                <description>Secondary detection (SD) mode enable
Device mode
This bit is set by the software to put the BCD into SD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DCDET</name>
                <description>Data contact detection (DCD) status
Device mode
This bit gives the result of DCD.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>data lines contact not detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>data lines contact detected.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PDET</name>
                <description>Primary detection (PD) status
Device mode
This bit gives the result of PD.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>no BCD support detected (connected to SDP or proprietary device).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>BCD support detected (connected to ACA, CDP or DCP).</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SDET</name>
                <description>Secondary detection (SD) status
Device mode
This bit gives the result of SD.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CDP detected.</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>DCP detected.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PS2DET</name>
                <description>DM pull-up detection status
Device mode
This bit is active only during PD and gives the result of comparison between DM voltage level and VLGC threshold. In normal situation, the DM level should be below this threshold. If it is above, it means that the DM is externally pulled high. This can be caused by connection to a PS2 port (which pulls-up both DP and DM lines) or to some proprietary charger not following the BCD specification.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Normal port detected (connected to SDP, ACA, CDP or DCP).</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>PS2 port or proprietary charger detected.</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DPPU_DPD</name>
                <description>DP pull-up / DPDM pull-down
Device mode
This bit is set by software to enable the embedded pull-up on DP line. Clearing it to 0 can be used to signal disconnect to the host when needed by the user software.
Host mode
This bit is set by software to enable the embedded pull-down on DP and DM lines.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </registers>
    </peripheral>
    <peripheral> 
      <name>WWDG</name>
      <description>System window watchdog</description>
      <groupName>WWDG</groupName>
      <baseAddress>0x40002C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WWDG</name>
        <description>Window Watchdog interrupt</description>
        <value>0</value>
      </interrupt>
      <registers>
          <register>
            <name>WWDG_CR</name>
            <displayName>WWDG_CR</displayName>
            <description>WWDG control register </description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>T</name>
                <description>7-bit counter (MSB to LSB)
These bits contain the value of the watchdog counter, decremented every
(4096 x 2WDGTB[2:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGA</name>
                <description>Activation bit
This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>Watchdog disabled</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>Watchdog enabled</description>
                    <value>0x1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_CFR</name>
            <displayName>WWDG_CFR</displayName>
            <description>WWDG configuration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
            <resetValue>0x0000007F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>W</name>
                <description>7-bit window value
These bits contain the window value to be compared with the down-counter.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EWI</name>
                <description>Early wakeup interrupt
When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDGTB</name>
                <description>Timer base
The timebase of the prescaler can be modified as follows:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>B_0x0</name>
                    <description>CK counter clock (PCLK div 4096) div 1</description>
                    <value>0x0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x1</name>
                    <description>CK counter clock (PCLK div 4096) div 2</description>
                    <value>0x1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x2</name>
                    <description>CK counter clock (PCLK div 4096) div 4</description>
                    <value>0x2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x3</name>
                    <description>CK counter clock (PCLK div 4096) div 8</description>
                    <value>0x3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x4</name>
                    <description>CK counter clock (PCLK div 4096) div 16</description>
                    <value>0x4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x5</name>
                    <description>CK counter clock (PCLK div 4096) div 32</description>
                    <value>0x5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x6</name>
                    <description>CK counter clock (PCLK div 4096) div 64</description>
                    <value>0x6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>B_0x7</name>
                    <description>CK counter clock (PCLK div 4096) div 128</description>
                    <value>0x7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>WWDG_SR</name>
            <displayName>WWDG_SR</displayName>
            <description>WWDG status register </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>EWIF</name>
                <description>Early wakeup interrupt flag
This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing ‘0’. Writing ‘1’ has no effect. This bit is also set if the interrupt is not enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
      </registers>
    </peripheral>			
  </peripherals>
</device>
